var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));

// node_modules/eventemitter3/index.js
var require_eventemitter3 = __commonJS({
  "node_modules/eventemitter3/index.js"(exports, module) {
    "use strict";
    var has = Object.prototype.hasOwnProperty;
    var prefix = "~";
    function Events() {
    }
    if (Object.create) {
      Events.prototype = /* @__PURE__ */ Object.create(null);
      if (!new Events().__proto__) prefix = false;
    }
    function EE(fn, context, once) {
      this.fn = fn;
      this.context = context;
      this.once = once || false;
    }
    function addListener(emitter, event, fn, context, once) {
      if (typeof fn !== "function") {
        throw new TypeError("The listener must be a function");
      }
      var listener = new EE(fn, context || emitter, once), evt = prefix ? prefix + event : event;
      if (!emitter._events[evt]) emitter._events[evt] = listener, emitter._eventsCount++;
      else if (!emitter._events[evt].fn) emitter._events[evt].push(listener);
      else emitter._events[evt] = [emitter._events[evt], listener];
      return emitter;
    }
    function clearEvent(emitter, evt) {
      if (--emitter._eventsCount === 0) emitter._events = new Events();
      else delete emitter._events[evt];
    }
    function EventEmitter5() {
      this._events = new Events();
      this._eventsCount = 0;
    }
    EventEmitter5.prototype.eventNames = function eventNames() {
      var names = [], events, name;
      if (this._eventsCount === 0) return names;
      for (name in events = this._events) {
        if (has.call(events, name)) names.push(prefix ? name.slice(1) : name);
      }
      if (Object.getOwnPropertySymbols) {
        return names.concat(Object.getOwnPropertySymbols(events));
      }
      return names;
    };
    EventEmitter5.prototype.listeners = function listeners(event) {
      var evt = prefix ? prefix + event : event, handlers = this._events[evt];
      if (!handlers) return [];
      if (handlers.fn) return [handlers.fn];
      for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {
        ee[i] = handlers[i].fn;
      }
      return ee;
    };
    EventEmitter5.prototype.listenerCount = function listenerCount(event) {
      var evt = prefix ? prefix + event : event, listeners = this._events[evt];
      if (!listeners) return 0;
      if (listeners.fn) return 1;
      return listeners.length;
    };
    EventEmitter5.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
      var evt = prefix ? prefix + event : event;
      if (!this._events[evt]) return false;
      var listeners = this._events[evt], len = arguments.length, args, i;
      if (listeners.fn) {
        if (listeners.once) this.removeListener(event, listeners.fn, void 0, true);
        switch (len) {
          case 1:
            return listeners.fn.call(listeners.context), true;
          case 2:
            return listeners.fn.call(listeners.context, a1), true;
          case 3:
            return listeners.fn.call(listeners.context, a1, a2), true;
          case 4:
            return listeners.fn.call(listeners.context, a1, a2, a3), true;
          case 5:
            return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
          case 6:
            return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
        }
        for (i = 1, args = new Array(len - 1); i < len; i++) {
          args[i - 1] = arguments[i];
        }
        listeners.fn.apply(listeners.context, args);
      } else {
        var length = listeners.length, j;
        for (i = 0; i < length; i++) {
          if (listeners[i].once) this.removeListener(event, listeners[i].fn, void 0, true);
          switch (len) {
            case 1:
              listeners[i].fn.call(listeners[i].context);
              break;
            case 2:
              listeners[i].fn.call(listeners[i].context, a1);
              break;
            case 3:
              listeners[i].fn.call(listeners[i].context, a1, a2);
              break;
            case 4:
              listeners[i].fn.call(listeners[i].context, a1, a2, a3);
              break;
            default:
              if (!args) for (j = 1, args = new Array(len - 1); j < len; j++) {
                args[j - 1] = arguments[j];
              }
              listeners[i].fn.apply(listeners[i].context, args);
          }
        }
      }
      return true;
    };
    EventEmitter5.prototype.on = function on(event, fn, context) {
      return addListener(this, event, fn, context, false);
    };
    EventEmitter5.prototype.once = function once(event, fn, context) {
      return addListener(this, event, fn, context, true);
    };
    EventEmitter5.prototype.removeListener = function removeListener(event, fn, context, once) {
      var evt = prefix ? prefix + event : event;
      if (!this._events[evt]) return this;
      if (!fn) {
        clearEvent(this, evt);
        return this;
      }
      var listeners = this._events[evt];
      if (listeners.fn) {
        if (listeners.fn === fn && (!once || listeners.once) && (!context || listeners.context === context)) {
          clearEvent(this, evt);
        }
      } else {
        for (var i = 0, events = [], length = listeners.length; i < length; i++) {
          if (listeners[i].fn !== fn || once && !listeners[i].once || context && listeners[i].context !== context) {
            events.push(listeners[i]);
          }
        }
        if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;
        else clearEvent(this, evt);
      }
      return this;
    };
    EventEmitter5.prototype.removeAllListeners = function removeAllListeners(event) {
      var evt;
      if (event) {
        evt = prefix ? prefix + event : event;
        if (this._events[evt]) clearEvent(this, evt);
      } else {
        this._events = new Events();
        this._eventsCount = 0;
      }
      return this;
    };
    EventEmitter5.prototype.off = EventEmitter5.prototype.removeListener;
    EventEmitter5.prototype.addListener = EventEmitter5.prototype.on;
    EventEmitter5.prefixed = prefix;
    EventEmitter5.EventEmitter = EventEmitter5;
    if ("undefined" !== typeof module) {
      module.exports = EventEmitter5;
    }
  }
});

// node_modules/hls.js/dist/hls.light.js
var require_hls_light = __commonJS({
  "node_modules/hls.js/dist/hls.light.js"(exports, module) {
    (function __HLS_WORKER_BUNDLE__(__IN_WORKER__) {
      (function(global, factory) {
        typeof exports === "object" && typeof module !== "undefined" ? module.exports = factory() : typeof define === "function" && define.amd ? define(factory) : (global = typeof globalThis !== "undefined" ? globalThis : global || self, global.Hls = factory());
      })(this, function() {
        "use strict";
        function _construct2(t, e, r) {
          if (_isNativeReflectConstruct4()) return Reflect.construct.apply(null, arguments);
          var o = [null];
          o.push.apply(o, e);
          var p = new (t.bind.apply(t, o))();
          return r && _setPrototypeOf4(p, r.prototype), p;
        }
        function _defineProperties4(e, r) {
          for (var t = 0; t < r.length; t++) {
            var o = r[t];
            o.enumerable = o.enumerable || false, o.configurable = true, "value" in o && (o.writable = true), Object.defineProperty(e, _toPropertyKey4(o.key), o);
          }
        }
        function _createClass4(e, r, t) {
          return r && _defineProperties4(e.prototype, r), t && _defineProperties4(e, t), Object.defineProperty(e, "prototype", {
            writable: false
          }), e;
        }
        function _defineProperty4(e, r, t) {
          return (r = _toPropertyKey4(r)) in e ? Object.defineProperty(e, r, {
            value: t,
            enumerable: true,
            configurable: true,
            writable: true
          }) : e[r] = t, e;
        }
        function _extends() {
          return _extends = Object.assign ? Object.assign.bind() : function(n) {
            for (var e = 1; e < arguments.length; e++) {
              var t = arguments[e];
              for (var r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]);
            }
            return n;
          }, _extends.apply(null, arguments);
        }
        function _getPrototypeOf4(t) {
          return _getPrototypeOf4 = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t2) {
            return t2.__proto__ || Object.getPrototypeOf(t2);
          }, _getPrototypeOf4(t);
        }
        function _inheritsLoose(t, o) {
          t.prototype = Object.create(o.prototype), t.prototype.constructor = t, _setPrototypeOf4(t, o);
        }
        function _isNativeFunction2(t) {
          try {
            return -1 !== Function.toString.call(t).indexOf("[native code]");
          } catch (n) {
            return "function" == typeof t;
          }
        }
        function _isNativeReflectConstruct4() {
          try {
            var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
            }));
          } catch (t2) {
          }
          return (_isNativeReflectConstruct4 = function() {
            return !!t;
          })();
        }
        function ownKeys3(e, r) {
          var t = Object.keys(e);
          if (Object.getOwnPropertySymbols) {
            var o = Object.getOwnPropertySymbols(e);
            r && (o = o.filter(function(r2) {
              return Object.getOwnPropertyDescriptor(e, r2).enumerable;
            })), t.push.apply(t, o);
          }
          return t;
        }
        function _objectSpread23(e) {
          for (var r = 1; r < arguments.length; r++) {
            var t = null != arguments[r] ? arguments[r] : {};
            r % 2 ? ownKeys3(Object(t), true).forEach(function(r2) {
              _defineProperty4(e, r2, t[r2]);
            }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys3(Object(t)).forEach(function(r2) {
              Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
            });
          }
          return e;
        }
        function _setPrototypeOf4(t, e) {
          return _setPrototypeOf4 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t2, e2) {
            return t2.__proto__ = e2, t2;
          }, _setPrototypeOf4(t, e);
        }
        function _toPrimitive4(t, r) {
          if ("object" != typeof t || !t) return t;
          var e = t[Symbol.toPrimitive];
          if (void 0 !== e) {
            var i = e.call(t, r);
            if ("object" != typeof i) return i;
            throw new TypeError("@@toPrimitive must return a primitive value.");
          }
          return ("string" === r ? String : Number)(t);
        }
        function _toPropertyKey4(t) {
          var i = _toPrimitive4(t, "string");
          return "symbol" == typeof i ? i : i + "";
        }
        function _wrapNativeSuper2(t) {
          var r = "function" == typeof Map ? /* @__PURE__ */ new Map() : void 0;
          return _wrapNativeSuper2 = function(t2) {
            if (null === t2 || !_isNativeFunction2(t2)) return t2;
            if ("function" != typeof t2) throw new TypeError("Super expression must either be null or a function");
            if (void 0 !== r) {
              if (r.has(t2)) return r.get(t2);
              r.set(t2, Wrapper);
            }
            function Wrapper() {
              return _construct2(t2, arguments, _getPrototypeOf4(this).constructor);
            }
            return Wrapper.prototype = Object.create(t2.prototype, {
              constructor: {
                value: Wrapper,
                enumerable: false,
                writable: true,
                configurable: true
              }
            }), _setPrototypeOf4(Wrapper, t2);
          }, _wrapNativeSuper2(t);
        }
        function uuid() {
          try {
            return crypto.randomUUID();
          } catch (error) {
            try {
              var url = URL.createObjectURL(new Blob());
              var _uuid = url.toString();
              URL.revokeObjectURL(url);
              return _uuid.slice(_uuid.lastIndexOf("/") + 1);
            } catch (error2) {
              var dt = (/* @__PURE__ */ new Date()).getTime();
              var _uuid2 = "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function(c) {
                var r = (dt + Math.random() * 16) % 16 | 0;
                dt = Math.floor(dt / 16);
                return (c == "x" ? r : r & 3 | 8).toString(16);
              });
              return _uuid2;
            }
          }
        }
        function getDefaultExportFromCjs(x) {
          return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x["default"] : x;
        }
        var eventemitter3 = { exports: {} };
        var hasRequiredEventemitter3;
        function requireEventemitter3() {
          if (hasRequiredEventemitter3) return eventemitter3.exports;
          hasRequiredEventemitter3 = 1;
          (function(module2) {
            var has = Object.prototype.hasOwnProperty, prefix = "~";
            function Events2() {
            }
            if (Object.create) {
              Events2.prototype = /* @__PURE__ */ Object.create(null);
              if (!new Events2().__proto__) prefix = false;
            }
            function EE(fn, context, once) {
              this.fn = fn;
              this.context = context;
              this.once = once || false;
            }
            function addListener(emitter, event, fn, context, once) {
              if (typeof fn !== "function") {
                throw new TypeError("The listener must be a function");
              }
              var listener = new EE(fn, context || emitter, once), evt = prefix ? prefix + event : event;
              if (!emitter._events[evt]) emitter._events[evt] = listener, emitter._eventsCount++;
              else if (!emitter._events[evt].fn) emitter._events[evt].push(listener);
              else emitter._events[evt] = [emitter._events[evt], listener];
              return emitter;
            }
            function clearEvent(emitter, evt) {
              if (--emitter._eventsCount === 0) emitter._events = new Events2();
              else delete emitter._events[evt];
            }
            function EventEmitter6() {
              this._events = new Events2();
              this._eventsCount = 0;
            }
            EventEmitter6.prototype.eventNames = function eventNames() {
              var names = [], events, name;
              if (this._eventsCount === 0) return names;
              for (name in events = this._events) {
                if (has.call(events, name)) names.push(prefix ? name.slice(1) : name);
              }
              if (Object.getOwnPropertySymbols) {
                return names.concat(Object.getOwnPropertySymbols(events));
              }
              return names;
            };
            EventEmitter6.prototype.listeners = function listeners(event) {
              var evt = prefix ? prefix + event : event, handlers = this._events[evt];
              if (!handlers) return [];
              if (handlers.fn) return [handlers.fn];
              for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {
                ee[i] = handlers[i].fn;
              }
              return ee;
            };
            EventEmitter6.prototype.listenerCount = function listenerCount(event) {
              var evt = prefix ? prefix + event : event, listeners = this._events[evt];
              if (!listeners) return 0;
              if (listeners.fn) return 1;
              return listeners.length;
            };
            EventEmitter6.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
              var evt = prefix ? prefix + event : event;
              if (!this._events[evt]) return false;
              var listeners = this._events[evt], len = arguments.length, args, i;
              if (listeners.fn) {
                if (listeners.once) this.removeListener(event, listeners.fn, void 0, true);
                switch (len) {
                  case 1:
                    return listeners.fn.call(listeners.context), true;
                  case 2:
                    return listeners.fn.call(listeners.context, a1), true;
                  case 3:
                    return listeners.fn.call(listeners.context, a1, a2), true;
                  case 4:
                    return listeners.fn.call(listeners.context, a1, a2, a3), true;
                  case 5:
                    return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
                  case 6:
                    return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
                }
                for (i = 1, args = new Array(len - 1); i < len; i++) {
                  args[i - 1] = arguments[i];
                }
                listeners.fn.apply(listeners.context, args);
              } else {
                var length = listeners.length, j;
                for (i = 0; i < length; i++) {
                  if (listeners[i].once) this.removeListener(event, listeners[i].fn, void 0, true);
                  switch (len) {
                    case 1:
                      listeners[i].fn.call(listeners[i].context);
                      break;
                    case 2:
                      listeners[i].fn.call(listeners[i].context, a1);
                      break;
                    case 3:
                      listeners[i].fn.call(listeners[i].context, a1, a2);
                      break;
                    case 4:
                      listeners[i].fn.call(listeners[i].context, a1, a2, a3);
                      break;
                    default:
                      if (!args) for (j = 1, args = new Array(len - 1); j < len; j++) {
                        args[j - 1] = arguments[j];
                      }
                      listeners[i].fn.apply(listeners[i].context, args);
                  }
                }
              }
              return true;
            };
            EventEmitter6.prototype.on = function on(event, fn, context) {
              return addListener(this, event, fn, context, false);
            };
            EventEmitter6.prototype.once = function once(event, fn, context) {
              return addListener(this, event, fn, context, true);
            };
            EventEmitter6.prototype.removeListener = function removeListener(event, fn, context, once) {
              var evt = prefix ? prefix + event : event;
              if (!this._events[evt]) return this;
              if (!fn) {
                clearEvent(this, evt);
                return this;
              }
              var listeners = this._events[evt];
              if (listeners.fn) {
                if (listeners.fn === fn && (!once || listeners.once) && (!context || listeners.context === context)) {
                  clearEvent(this, evt);
                }
              } else {
                for (var i = 0, events = [], length = listeners.length; i < length; i++) {
                  if (listeners[i].fn !== fn || once && !listeners[i].once || context && listeners[i].context !== context) {
                    events.push(listeners[i]);
                  }
                }
                if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;
                else clearEvent(this, evt);
              }
              return this;
            };
            EventEmitter6.prototype.removeAllListeners = function removeAllListeners(event) {
              var evt;
              if (event) {
                evt = prefix ? prefix + event : event;
                if (this._events[evt]) clearEvent(this, evt);
              } else {
                this._events = new Events2();
                this._eventsCount = 0;
              }
              return this;
            };
            EventEmitter6.prototype.off = EventEmitter6.prototype.removeListener;
            EventEmitter6.prototype.addListener = EventEmitter6.prototype.on;
            EventEmitter6.prefixed = prefix;
            EventEmitter6.EventEmitter = EventEmitter6;
            {
              module2.exports = EventEmitter6;
            }
          })(eventemitter3);
          return eventemitter3.exports;
        }
        var eventemitter3Exports = requireEventemitter3();
        var EventEmitter5 = /* @__PURE__ */ getDefaultExportFromCjs(eventemitter3Exports);
        var urlToolkit = { exports: {} };
        var hasRequiredUrlToolkit;
        function requireUrlToolkit() {
          if (hasRequiredUrlToolkit) return urlToolkit.exports;
          hasRequiredUrlToolkit = 1;
          (function(module2, exports2) {
            (function(root) {
              var URL_REGEX = /^(?=((?:[a-zA-Z0-9+\-.]+:)?))\1(?=((?:\/\/[^\/?#]*)?))\2(?=((?:(?:[^?#\/]*\/)*[^;?#\/]*)?))\3((?:;[^?#]*)?)(\?[^#]*)?(#[^]*)?$/;
              var FIRST_SEGMENT_REGEX = /^(?=([^\/?#]*))\1([^]*)$/;
              var SLASH_DOT_REGEX = /(?:\/|^)\.(?=\/)/g;
              var SLASH_DOT_DOT_REGEX = /(?:\/|^)\.\.\/(?!\.\.\/)[^\/]*(?=\/)/g;
              var URLToolkit = {
                // If opts.alwaysNormalize is true then the path will always be normalized even when it starts with / or //
                // E.g
                // With opts.alwaysNormalize = false (default, spec compliant)
                // http://a.com/b/cd + /e/f/../g => http://a.com/e/f/../g
                // With opts.alwaysNormalize = true (not spec compliant)
                // http://a.com/b/cd + /e/f/../g => http://a.com/e/g
                buildAbsoluteURL: function(baseURL, relativeURL, opts) {
                  opts = opts || {};
                  baseURL = baseURL.trim();
                  relativeURL = relativeURL.trim();
                  if (!relativeURL) {
                    if (!opts.alwaysNormalize) {
                      return baseURL;
                    }
                    var basePartsForNormalise = URLToolkit.parseURL(baseURL);
                    if (!basePartsForNormalise) {
                      throw new Error("Error trying to parse base URL.");
                    }
                    basePartsForNormalise.path = URLToolkit.normalizePath(
                      basePartsForNormalise.path
                    );
                    return URLToolkit.buildURLFromParts(basePartsForNormalise);
                  }
                  var relativeParts = URLToolkit.parseURL(relativeURL);
                  if (!relativeParts) {
                    throw new Error("Error trying to parse relative URL.");
                  }
                  if (relativeParts.scheme) {
                    if (!opts.alwaysNormalize) {
                      return relativeURL;
                    }
                    relativeParts.path = URLToolkit.normalizePath(relativeParts.path);
                    return URLToolkit.buildURLFromParts(relativeParts);
                  }
                  var baseParts = URLToolkit.parseURL(baseURL);
                  if (!baseParts) {
                    throw new Error("Error trying to parse base URL.");
                  }
                  if (!baseParts.netLoc && baseParts.path && baseParts.path[0] !== "/") {
                    var pathParts = FIRST_SEGMENT_REGEX.exec(baseParts.path);
                    baseParts.netLoc = pathParts[1];
                    baseParts.path = pathParts[2];
                  }
                  if (baseParts.netLoc && !baseParts.path) {
                    baseParts.path = "/";
                  }
                  var builtParts = {
                    // 2c) Otherwise, the embedded URL inherits the scheme of
                    // the base URL.
                    scheme: baseParts.scheme,
                    netLoc: relativeParts.netLoc,
                    path: null,
                    params: relativeParts.params,
                    query: relativeParts.query,
                    fragment: relativeParts.fragment
                  };
                  if (!relativeParts.netLoc) {
                    builtParts.netLoc = baseParts.netLoc;
                    if (relativeParts.path[0] !== "/") {
                      if (!relativeParts.path) {
                        builtParts.path = baseParts.path;
                        if (!relativeParts.params) {
                          builtParts.params = baseParts.params;
                          if (!relativeParts.query) {
                            builtParts.query = baseParts.query;
                          }
                        }
                      } else {
                        var baseURLPath = baseParts.path;
                        var newPath = baseURLPath.substring(0, baseURLPath.lastIndexOf("/") + 1) + relativeParts.path;
                        builtParts.path = URLToolkit.normalizePath(newPath);
                      }
                    }
                  }
                  if (builtParts.path === null) {
                    builtParts.path = opts.alwaysNormalize ? URLToolkit.normalizePath(relativeParts.path) : relativeParts.path;
                  }
                  return URLToolkit.buildURLFromParts(builtParts);
                },
                parseURL: function(url) {
                  var parts = URL_REGEX.exec(url);
                  if (!parts) {
                    return null;
                  }
                  return {
                    scheme: parts[1] || "",
                    netLoc: parts[2] || "",
                    path: parts[3] || "",
                    params: parts[4] || "",
                    query: parts[5] || "",
                    fragment: parts[6] || ""
                  };
                },
                normalizePath: function(path) {
                  path = path.split("").reverse().join("").replace(SLASH_DOT_REGEX, "");
                  while (path.length !== (path = path.replace(SLASH_DOT_DOT_REGEX, "")).length) {
                  }
                  return path.split("").reverse().join("");
                },
                buildURLFromParts: function(parts) {
                  return parts.scheme + parts.netLoc + parts.path + parts.params + parts.query + parts.fragment;
                }
              };
              module2.exports = URLToolkit;
            })();
          })(urlToolkit);
          return urlToolkit.exports;
        }
        var urlToolkitExports = requireUrlToolkit();
        var isFiniteNumber = Number.isFinite || function(value) {
          return typeof value === "number" && isFinite(value);
        };
        var isSafeInteger = Number.isSafeInteger || function(value) {
          return typeof value === "number" && Math.abs(value) <= MAX_SAFE_INTEGER;
        };
        var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || 9007199254740991;
        var ErrorTypes = /* @__PURE__ */ function(ErrorTypes2) {
          ErrorTypes2["NETWORK_ERROR"] = "networkError";
          ErrorTypes2["MEDIA_ERROR"] = "mediaError";
          ErrorTypes2["KEY_SYSTEM_ERROR"] = "keySystemError";
          ErrorTypes2["MUX_ERROR"] = "muxError";
          ErrorTypes2["OTHER_ERROR"] = "otherError";
          return ErrorTypes2;
        }({});
        var ErrorDetails = /* @__PURE__ */ function(ErrorDetails2) {
          ErrorDetails2["KEY_SYSTEM_NO_KEYS"] = "keySystemNoKeys";
          ErrorDetails2["KEY_SYSTEM_NO_ACCESS"] = "keySystemNoAccess";
          ErrorDetails2["KEY_SYSTEM_NO_SESSION"] = "keySystemNoSession";
          ErrorDetails2["KEY_SYSTEM_NO_CONFIGURED_LICENSE"] = "keySystemNoConfiguredLicense";
          ErrorDetails2["KEY_SYSTEM_LICENSE_REQUEST_FAILED"] = "keySystemLicenseRequestFailed";
          ErrorDetails2["KEY_SYSTEM_SERVER_CERTIFICATE_REQUEST_FAILED"] = "keySystemServerCertificateRequestFailed";
          ErrorDetails2["KEY_SYSTEM_SERVER_CERTIFICATE_UPDATE_FAILED"] = "keySystemServerCertificateUpdateFailed";
          ErrorDetails2["KEY_SYSTEM_SESSION_UPDATE_FAILED"] = "keySystemSessionUpdateFailed";
          ErrorDetails2["KEY_SYSTEM_STATUS_OUTPUT_RESTRICTED"] = "keySystemStatusOutputRestricted";
          ErrorDetails2["KEY_SYSTEM_STATUS_INTERNAL_ERROR"] = "keySystemStatusInternalError";
          ErrorDetails2["KEY_SYSTEM_DESTROY_MEDIA_KEYS_ERROR"] = "keySystemDestroyMediaKeysError";
          ErrorDetails2["KEY_SYSTEM_DESTROY_CLOSE_SESSION_ERROR"] = "keySystemDestroyCloseSessionError";
          ErrorDetails2["KEY_SYSTEM_DESTROY_REMOVE_SESSION_ERROR"] = "keySystemDestroyRemoveSessionError";
          ErrorDetails2["MANIFEST_LOAD_ERROR"] = "manifestLoadError";
          ErrorDetails2["MANIFEST_LOAD_TIMEOUT"] = "manifestLoadTimeOut";
          ErrorDetails2["MANIFEST_PARSING_ERROR"] = "manifestParsingError";
          ErrorDetails2["MANIFEST_INCOMPATIBLE_CODECS_ERROR"] = "manifestIncompatibleCodecsError";
          ErrorDetails2["LEVEL_EMPTY_ERROR"] = "levelEmptyError";
          ErrorDetails2["LEVEL_LOAD_ERROR"] = "levelLoadError";
          ErrorDetails2["LEVEL_LOAD_TIMEOUT"] = "levelLoadTimeOut";
          ErrorDetails2["LEVEL_PARSING_ERROR"] = "levelParsingError";
          ErrorDetails2["LEVEL_SWITCH_ERROR"] = "levelSwitchError";
          ErrorDetails2["AUDIO_TRACK_LOAD_ERROR"] = "audioTrackLoadError";
          ErrorDetails2["AUDIO_TRACK_LOAD_TIMEOUT"] = "audioTrackLoadTimeOut";
          ErrorDetails2["SUBTITLE_LOAD_ERROR"] = "subtitleTrackLoadError";
          ErrorDetails2["SUBTITLE_TRACK_LOAD_TIMEOUT"] = "subtitleTrackLoadTimeOut";
          ErrorDetails2["FRAG_LOAD_ERROR"] = "fragLoadError";
          ErrorDetails2["FRAG_LOAD_TIMEOUT"] = "fragLoadTimeOut";
          ErrorDetails2["FRAG_DECRYPT_ERROR"] = "fragDecryptError";
          ErrorDetails2["FRAG_PARSING_ERROR"] = "fragParsingError";
          ErrorDetails2["FRAG_GAP"] = "fragGap";
          ErrorDetails2["REMUX_ALLOC_ERROR"] = "remuxAllocError";
          ErrorDetails2["KEY_LOAD_ERROR"] = "keyLoadError";
          ErrorDetails2["KEY_LOAD_TIMEOUT"] = "keyLoadTimeOut";
          ErrorDetails2["BUFFER_ADD_CODEC_ERROR"] = "bufferAddCodecError";
          ErrorDetails2["BUFFER_INCOMPATIBLE_CODECS_ERROR"] = "bufferIncompatibleCodecsError";
          ErrorDetails2["BUFFER_APPEND_ERROR"] = "bufferAppendError";
          ErrorDetails2["BUFFER_APPENDING_ERROR"] = "bufferAppendingError";
          ErrorDetails2["BUFFER_STALLED_ERROR"] = "bufferStalledError";
          ErrorDetails2["BUFFER_FULL_ERROR"] = "bufferFullError";
          ErrorDetails2["BUFFER_SEEK_OVER_HOLE"] = "bufferSeekOverHole";
          ErrorDetails2["BUFFER_NUDGE_ON_STALL"] = "bufferNudgeOnStall";
          ErrorDetails2["ASSET_LIST_LOAD_ERROR"] = "assetListLoadError";
          ErrorDetails2["ASSET_LIST_LOAD_TIMEOUT"] = "assetListLoadTimeout";
          ErrorDetails2["ASSET_LIST_PARSING_ERROR"] = "assetListParsingError";
          ErrorDetails2["INTERSTITIAL_ASSET_ITEM_ERROR"] = "interstitialAssetItemError";
          ErrorDetails2["INTERNAL_EXCEPTION"] = "internalException";
          ErrorDetails2["INTERNAL_ABORTED"] = "aborted";
          ErrorDetails2["ATTACH_MEDIA_ERROR"] = "attachMediaError";
          ErrorDetails2["UNKNOWN"] = "unknown";
          return ErrorDetails2;
        }({});
        var Events = /* @__PURE__ */ function(Events2) {
          Events2["MEDIA_ATTACHING"] = "hlsMediaAttaching";
          Events2["MEDIA_ATTACHED"] = "hlsMediaAttached";
          Events2["MEDIA_DETACHING"] = "hlsMediaDetaching";
          Events2["MEDIA_DETACHED"] = "hlsMediaDetached";
          Events2["MEDIA_ENDED"] = "hlsMediaEnded";
          Events2["STALL_RESOLVED"] = "hlsStallResolved";
          Events2["BUFFER_RESET"] = "hlsBufferReset";
          Events2["BUFFER_CODECS"] = "hlsBufferCodecs";
          Events2["BUFFER_CREATED"] = "hlsBufferCreated";
          Events2["BUFFER_APPENDING"] = "hlsBufferAppending";
          Events2["BUFFER_APPENDED"] = "hlsBufferAppended";
          Events2["BUFFER_EOS"] = "hlsBufferEos";
          Events2["BUFFERED_TO_END"] = "hlsBufferedToEnd";
          Events2["BUFFER_FLUSHING"] = "hlsBufferFlushing";
          Events2["BUFFER_FLUSHED"] = "hlsBufferFlushed";
          Events2["MANIFEST_LOADING"] = "hlsManifestLoading";
          Events2["MANIFEST_LOADED"] = "hlsManifestLoaded";
          Events2["MANIFEST_PARSED"] = "hlsManifestParsed";
          Events2["LEVEL_SWITCHING"] = "hlsLevelSwitching";
          Events2["LEVEL_SWITCHED"] = "hlsLevelSwitched";
          Events2["LEVEL_LOADING"] = "hlsLevelLoading";
          Events2["LEVEL_LOADED"] = "hlsLevelLoaded";
          Events2["LEVEL_UPDATED"] = "hlsLevelUpdated";
          Events2["LEVEL_PTS_UPDATED"] = "hlsLevelPtsUpdated";
          Events2["LEVELS_UPDATED"] = "hlsLevelsUpdated";
          Events2["AUDIO_TRACKS_UPDATED"] = "hlsAudioTracksUpdated";
          Events2["AUDIO_TRACK_SWITCHING"] = "hlsAudioTrackSwitching";
          Events2["AUDIO_TRACK_SWITCHED"] = "hlsAudioTrackSwitched";
          Events2["AUDIO_TRACK_LOADING"] = "hlsAudioTrackLoading";
          Events2["AUDIO_TRACK_LOADED"] = "hlsAudioTrackLoaded";
          Events2["AUDIO_TRACK_UPDATED"] = "hlsAudioTrackUpdated";
          Events2["SUBTITLE_TRACKS_UPDATED"] = "hlsSubtitleTracksUpdated";
          Events2["SUBTITLE_TRACKS_CLEARED"] = "hlsSubtitleTracksCleared";
          Events2["SUBTITLE_TRACK_SWITCH"] = "hlsSubtitleTrackSwitch";
          Events2["SUBTITLE_TRACK_LOADING"] = "hlsSubtitleTrackLoading";
          Events2["SUBTITLE_TRACK_LOADED"] = "hlsSubtitleTrackLoaded";
          Events2["SUBTITLE_TRACK_UPDATED"] = "hlsSubtitleTrackUpdated";
          Events2["SUBTITLE_FRAG_PROCESSED"] = "hlsSubtitleFragProcessed";
          Events2["CUES_PARSED"] = "hlsCuesParsed";
          Events2["NON_NATIVE_TEXT_TRACKS_FOUND"] = "hlsNonNativeTextTracksFound";
          Events2["INIT_PTS_FOUND"] = "hlsInitPtsFound";
          Events2["FRAG_LOADING"] = "hlsFragLoading";
          Events2["FRAG_LOAD_EMERGENCY_ABORTED"] = "hlsFragLoadEmergencyAborted";
          Events2["FRAG_LOADED"] = "hlsFragLoaded";
          Events2["FRAG_DECRYPTED"] = "hlsFragDecrypted";
          Events2["FRAG_PARSING_INIT_SEGMENT"] = "hlsFragParsingInitSegment";
          Events2["FRAG_PARSING_USERDATA"] = "hlsFragParsingUserdata";
          Events2["FRAG_PARSING_METADATA"] = "hlsFragParsingMetadata";
          Events2["FRAG_PARSED"] = "hlsFragParsed";
          Events2["FRAG_BUFFERED"] = "hlsFragBuffered";
          Events2["FRAG_CHANGED"] = "hlsFragChanged";
          Events2["FPS_DROP"] = "hlsFpsDrop";
          Events2["FPS_DROP_LEVEL_CAPPING"] = "hlsFpsDropLevelCapping";
          Events2["MAX_AUTO_LEVEL_UPDATED"] = "hlsMaxAutoLevelUpdated";
          Events2["ERROR"] = "hlsError";
          Events2["DESTROYING"] = "hlsDestroying";
          Events2["KEY_LOADING"] = "hlsKeyLoading";
          Events2["KEY_LOADED"] = "hlsKeyLoaded";
          Events2["LIVE_BACK_BUFFER_REACHED"] = "hlsLiveBackBufferReached";
          Events2["BACK_BUFFER_REACHED"] = "hlsBackBufferReached";
          Events2["STEERING_MANIFEST_LOADED"] = "hlsSteeringManifestLoaded";
          Events2["ASSET_LIST_LOADING"] = "hlsAssetListLoading";
          Events2["ASSET_LIST_LOADED"] = "hlsAssetListLoaded";
          Events2["INTERSTITIALS_UPDATED"] = "hlsInterstitialsUpdated";
          Events2["INTERSTITIALS_BUFFERED_TO_BOUNDARY"] = "hlsInterstitialsBufferedToBoundary";
          Events2["INTERSTITIAL_ASSET_PLAYER_CREATED"] = "hlsInterstitialAssetPlayerCreated";
          Events2["INTERSTITIAL_STARTED"] = "hlsInterstitialStarted";
          Events2["INTERSTITIAL_ASSET_STARTED"] = "hlsInterstitialAssetStarted";
          Events2["INTERSTITIAL_ASSET_ENDED"] = "hlsInterstitialAssetEnded";
          Events2["INTERSTITIAL_ASSET_ERROR"] = "hlsInterstitialAssetError";
          Events2["INTERSTITIAL_ENDED"] = "hlsInterstitialEnded";
          Events2["INTERSTITIALS_PRIMARY_RESUMED"] = "hlsInterstitialsPrimaryResumed";
          Events2["PLAYOUT_LIMIT_REACHED"] = "hlsPlayoutLimitReached";
          Events2["EVENT_CUE_ENTER"] = "hlsEventCueEnter";
          return Events2;
        }({});
        var PlaylistContextType = {
          MANIFEST: "manifest",
          LEVEL: "level",
          AUDIO_TRACK: "audioTrack",
          SUBTITLE_TRACK: "subtitleTrack"
        };
        var PlaylistLevelType = {
          MAIN: "main",
          AUDIO: "audio",
          SUBTITLE: "subtitle"
        };
        var EWMA = /* @__PURE__ */ function() {
          function EWMA2(halfLife, estimate, weight) {
            if (estimate === void 0) {
              estimate = 0;
            }
            if (weight === void 0) {
              weight = 0;
            }
            this.halfLife = void 0;
            this.alpha_ = void 0;
            this.estimate_ = void 0;
            this.totalWeight_ = void 0;
            this.halfLife = halfLife;
            this.alpha_ = halfLife ? Math.exp(Math.log(0.5) / halfLife) : 0;
            this.estimate_ = estimate;
            this.totalWeight_ = weight;
          }
          var _proto = EWMA2.prototype;
          _proto.sample = function sample(weight, value) {
            var adjAlpha = Math.pow(this.alpha_, weight);
            this.estimate_ = value * (1 - adjAlpha) + adjAlpha * this.estimate_;
            this.totalWeight_ += weight;
          };
          _proto.getTotalWeight = function getTotalWeight() {
            return this.totalWeight_;
          };
          _proto.getEstimate = function getEstimate() {
            if (this.alpha_) {
              var zeroFactor = 1 - Math.pow(this.alpha_, this.totalWeight_);
              if (zeroFactor) {
                return this.estimate_ / zeroFactor;
              }
            }
            return this.estimate_;
          };
          return EWMA2;
        }();
        var EwmaBandWidthEstimator = /* @__PURE__ */ function() {
          function EwmaBandWidthEstimator2(slow, fast, defaultEstimate, defaultTTFB) {
            if (defaultTTFB === void 0) {
              defaultTTFB = 100;
            }
            this.defaultEstimate_ = void 0;
            this.minWeight_ = void 0;
            this.minDelayMs_ = void 0;
            this.slow_ = void 0;
            this.fast_ = void 0;
            this.defaultTTFB_ = void 0;
            this.ttfb_ = void 0;
            this.defaultEstimate_ = defaultEstimate;
            this.minWeight_ = 1e-3;
            this.minDelayMs_ = 50;
            this.slow_ = new EWMA(slow);
            this.fast_ = new EWMA(fast);
            this.defaultTTFB_ = defaultTTFB;
            this.ttfb_ = new EWMA(slow);
          }
          var _proto = EwmaBandWidthEstimator2.prototype;
          _proto.update = function update(slow, fast) {
            var slow_ = this.slow_, fast_ = this.fast_, ttfb_ = this.ttfb_;
            if (slow_.halfLife !== slow) {
              this.slow_ = new EWMA(slow, slow_.getEstimate(), slow_.getTotalWeight());
            }
            if (fast_.halfLife !== fast) {
              this.fast_ = new EWMA(fast, fast_.getEstimate(), fast_.getTotalWeight());
            }
            if (ttfb_.halfLife !== slow) {
              this.ttfb_ = new EWMA(slow, ttfb_.getEstimate(), ttfb_.getTotalWeight());
            }
          };
          _proto.sample = function sample(durationMs, numBytes) {
            durationMs = Math.max(durationMs, this.minDelayMs_);
            var numBits = 8 * numBytes;
            var durationS = durationMs / 1e3;
            var bandwidthInBps = numBits / durationS;
            this.fast_.sample(durationS, bandwidthInBps);
            this.slow_.sample(durationS, bandwidthInBps);
          };
          _proto.sampleTTFB = function sampleTTFB(ttfb) {
            var seconds = ttfb / 1e3;
            var weight = Math.sqrt(2) * Math.exp(-Math.pow(seconds, 2) / 2);
            this.ttfb_.sample(weight, Math.max(ttfb, 5));
          };
          _proto.canEstimate = function canEstimate() {
            return this.fast_.getTotalWeight() >= this.minWeight_;
          };
          _proto.getEstimate = function getEstimate() {
            if (this.canEstimate()) {
              return Math.min(this.fast_.getEstimate(), this.slow_.getEstimate());
            } else {
              return this.defaultEstimate_;
            }
          };
          _proto.getEstimateTTFB = function getEstimateTTFB() {
            if (this.ttfb_.getTotalWeight() >= this.minWeight_) {
              return this.ttfb_.getEstimate();
            } else {
              return this.defaultTTFB_;
            }
          };
          _proto.destroy = function destroy() {
          };
          return _createClass4(EwmaBandWidthEstimator2, [{
            key: "defaultEstimate",
            get: function get() {
              return this.defaultEstimate_;
            }
          }]);
        }();
        var Logger4 = function Logger5(label, logger5) {
          this.trace = void 0;
          this.debug = void 0;
          this.log = void 0;
          this.warn = void 0;
          this.info = void 0;
          this.error = void 0;
          var lb = "[" + label + "]:";
          this.trace = noop;
          this.debug = logger5.debug.bind(null, lb);
          this.log = logger5.log.bind(null, lb);
          this.warn = logger5.warn.bind(null, lb);
          this.info = logger5.info.bind(null, lb);
          this.error = logger5.error.bind(null, lb);
        };
        var noop = function noop2() {
        };
        var fakeLogger = {
          trace: noop,
          debug: noop,
          log: noop,
          warn: noop,
          info: noop,
          error: noop
        };
        function createLogger() {
          return _extends({}, fakeLogger);
        }
        function consolePrintFn(type, id) {
          var func = self.console[type];
          return func ? func.bind(self.console, (id ? "[" + id + "] " : "") + "[" + type + "] >") : noop;
        }
        function getLoggerFn(key, debugConfig, id) {
          return debugConfig[key] ? debugConfig[key].bind(debugConfig) : consolePrintFn(key, id);
        }
        var exportedLogger = createLogger();
        function enableLogs(debugConfig, context, id) {
          var newLogger = createLogger();
          if (typeof console === "object" && debugConfig === true || typeof debugConfig === "object") {
            var keys = [
              // Remove out from list here to hard-disable a log-level
              // 'trace',
              "debug",
              "log",
              "info",
              "warn",
              "error"
            ];
            keys.forEach(function(key) {
              newLogger[key] = getLoggerFn(key, debugConfig, id);
            });
            try {
              newLogger.log('Debug logs enabled for "' + context + '" in hls.js version 1.6.0');
            } catch (e) {
              return createLogger();
            }
            keys.forEach(function(key) {
              exportedLogger[key] = getLoggerFn(key, debugConfig);
            });
          } else {
            _extends(exportedLogger, newLogger);
          }
          return newLogger;
        }
        var logger4 = exportedLogger;
        var empty;
        var hasRequiredEmpty;
        function requireEmpty() {
          if (hasRequiredEmpty) return empty;
          hasRequiredEmpty = 1;
          empty = void 0;
          return empty;
        }
        var emptyExports = requireEmpty();
        var Cues = /* @__PURE__ */ getDefaultExportFromCjs(emptyExports);
        function utf8ArrayToStr(array, exitOnNull) {
          if (exitOnNull === void 0) {
            exitOnNull = false;
          }
          if (typeof TextDecoder !== "undefined") {
            var decoder = new TextDecoder("utf-8");
            var decoded = decoder.decode(array);
            if (exitOnNull) {
              var idx = decoded.indexOf("\0");
              return idx !== -1 ? decoded.substring(0, idx) : decoded;
            }
            return decoded.replace(/\0/g, "");
          }
          var len = array.length;
          var c;
          var char2;
          var char3;
          var out = "";
          var i = 0;
          while (i < len) {
            c = array[i++];
            if (c === 0 && exitOnNull) {
              return out;
            } else if (c === 0 || c === 3) {
              continue;
            }
            switch (c >> 4) {
              case 0:
              case 1:
              case 2:
              case 3:
              case 4:
              case 5:
              case 6:
              case 7:
                out += String.fromCharCode(c);
                break;
              case 12:
              case 13:
                char2 = array[i++];
                out += String.fromCharCode((c & 31) << 6 | char2 & 63);
                break;
              case 14:
                char2 = array[i++];
                char3 = array[i++];
                out += String.fromCharCode((c & 15) << 12 | (char2 & 63) << 6 | (char3 & 63) << 0);
                break;
            }
          }
          return out;
        }
        var Hex = {
          hexDump: function hexDump(array) {
            var str = "";
            for (var i = 0; i < array.length; i++) {
              var h = array[i].toString(16);
              if (h.length < 2) {
                h = "0" + h;
              }
              str += h;
            }
            return str;
          }
        };
        var LoadStats = function LoadStats2() {
          this.aborted = false;
          this.loaded = 0;
          this.retry = 0;
          this.total = 0;
          this.chunkCount = 0;
          this.bwEstimate = 0;
          this.loading = {
            start: 0,
            first: 0,
            end: 0
          };
          this.parsing = {
            start: 0,
            end: 0
          };
          this.buffering = {
            start: 0,
            first: 0,
            end: 0
          };
        };
        var ElementaryStreamTypes = {
          AUDIO: "audio",
          VIDEO: "video",
          AUDIOVIDEO: "audiovideo"
        };
        var BaseSegment = /* @__PURE__ */ function() {
          function BaseSegment2(base) {
            this._byteRange = null;
            this._url = null;
            this._stats = null;
            this._streams = null;
            this.base = void 0;
            this.relurl = void 0;
            if (typeof base === "string") {
              base = {
                url: base
              };
            }
            this.base = base;
            makeEnumerable(this, "stats");
          }
          var _proto = BaseSegment2.prototype;
          _proto.setByteRange = function setByteRange(value, previous) {
            var params = value.split("@", 2);
            var start;
            if (params.length === 1) {
              start = (previous == null ? void 0 : previous.byteRangeEndOffset) || 0;
            } else {
              start = parseInt(params[1]);
            }
            this._byteRange = [start, parseInt(params[0]) + start];
          };
          _proto.clearElementaryStreamInfo = function clearElementaryStreamInfo() {
            var elementaryStreams = this.elementaryStreams;
            elementaryStreams[ElementaryStreamTypes.AUDIO] = null;
            elementaryStreams[ElementaryStreamTypes.VIDEO] = null;
            elementaryStreams[ElementaryStreamTypes.AUDIOVIDEO] = null;
          };
          return _createClass4(BaseSegment2, [{
            key: "baseurl",
            get: function get() {
              return this.base.url;
            }
          }, {
            key: "byteRange",
            get: function get() {
              if (this._byteRange === null) {
                return [];
              }
              return this._byteRange;
            }
          }, {
            key: "byteRangeStartOffset",
            get: function get() {
              return this.byteRange[0];
            }
          }, {
            key: "byteRangeEndOffset",
            get: function get() {
              return this.byteRange[1];
            }
          }, {
            key: "elementaryStreams",
            get: function get() {
              if (this._streams === null) {
                var _this$_streams;
                this._streams = (_this$_streams = {}, _this$_streams[ElementaryStreamTypes.AUDIO] = null, _this$_streams[ElementaryStreamTypes.VIDEO] = null, _this$_streams[ElementaryStreamTypes.AUDIOVIDEO] = null, _this$_streams);
              }
              return this._streams;
            },
            set: function set(value) {
              this._streams = value;
            }
          }, {
            key: "hasStats",
            get: function get() {
              return this._stats !== null;
            }
          }, {
            key: "hasStreams",
            get: function get() {
              return this._streams !== null;
            }
          }, {
            key: "stats",
            get: function get() {
              if (this._stats === null) {
                this._stats = new LoadStats();
              }
              return this._stats;
            },
            set: function set(value) {
              this._stats = value;
            }
          }, {
            key: "url",
            get: function get() {
              if (!this._url && this.baseurl && this.relurl) {
                this._url = urlToolkitExports.buildAbsoluteURL(this.baseurl, this.relurl, {
                  alwaysNormalize: true
                });
              }
              return this._url || "";
            },
            set: function set(value) {
              this._url = value;
            }
          }]);
        }();
        function isMediaFragment(frag) {
          return frag.sn !== "initSegment";
        }
        var Fragment = /* @__PURE__ */ function(_BaseSegment2) {
          function Fragment2(type, base) {
            var _this;
            _this = _BaseSegment2.call(this, base) || this;
            _this._decryptdata = null;
            _this._programDateTime = null;
            _this._ref = null;
            _this._bitrate = void 0;
            _this.rawProgramDateTime = null;
            _this.tagList = [];
            _this.duration = 0;
            _this.sn = 0;
            _this.levelkeys = void 0;
            _this.type = void 0;
            _this.loader = null;
            _this.keyLoader = null;
            _this.level = -1;
            _this.cc = 0;
            _this.startPTS = void 0;
            _this.endPTS = void 0;
            _this.startDTS = void 0;
            _this.endDTS = void 0;
            _this.start = 0;
            _this.playlistOffset = 0;
            _this.deltaPTS = void 0;
            _this.maxStartPTS = void 0;
            _this.minEndPTS = void 0;
            _this.data = void 0;
            _this.bitrateTest = false;
            _this.title = null;
            _this.initSegment = null;
            _this.endList = void 0;
            _this.gap = void 0;
            _this.urlId = 0;
            _this.type = type;
            return _this;
          }
          _inheritsLoose(Fragment2, _BaseSegment2);
          var _proto2 = Fragment2.prototype;
          _proto2.addStart = function addStart(value) {
            this.setStart(this.start + value);
          };
          _proto2.setStart = function setStart(value) {
            this.start = value;
            if (this._ref) {
              this._ref.start = value;
            }
          };
          _proto2.setDuration = function setDuration(value) {
            this.duration = value;
            if (this._ref) {
              this._ref.duration = value;
            }
          };
          _proto2.setKeyFormat = function setKeyFormat(keyFormat) {
            if (this.levelkeys) {
              var key = this.levelkeys[keyFormat];
              if (key && !this._decryptdata) {
                this._decryptdata = key.getDecryptData(this.sn);
              }
            }
          };
          _proto2.abortRequests = function abortRequests() {
            var _this$loader, _this$keyLoader;
            (_this$loader = this.loader) == null ? void 0 : _this$loader.abort();
            (_this$keyLoader = this.keyLoader) == null ? void 0 : _this$keyLoader.abort();
          };
          _proto2.setElementaryStreamInfo = function setElementaryStreamInfo(type, startPTS, endPTS, startDTS, endDTS, partial) {
            if (partial === void 0) {
              partial = false;
            }
            var elementaryStreams = this.elementaryStreams;
            var info = elementaryStreams[type];
            if (!info) {
              elementaryStreams[type] = {
                startPTS,
                endPTS,
                startDTS,
                endDTS,
                partial
              };
              return;
            }
            info.startPTS = Math.min(info.startPTS, startPTS);
            info.endPTS = Math.max(info.endPTS, endPTS);
            info.startDTS = Math.min(info.startDTS, startDTS);
            info.endDTS = Math.max(info.endDTS, endDTS);
          };
          return _createClass4(Fragment2, [{
            key: "byteLength",
            get: function get() {
              if (this.hasStats) {
                var total = this.stats.total;
                if (total) {
                  return total;
                }
              }
              if (this.byteRange) {
                var start = this.byteRange[0];
                var end = this.byteRange[1];
                if (isFiniteNumber(start) && isFiniteNumber(end)) {
                  return end - start;
                }
              }
              return null;
            }
          }, {
            key: "bitrate",
            get: function get() {
              if (this.byteLength) {
                return this.byteLength * 8 / this.duration;
              }
              if (this._bitrate) {
                return this._bitrate;
              }
              return null;
            },
            set: function set(value) {
              this._bitrate = value;
            }
          }, {
            key: "decryptdata",
            get: function get() {
              var levelkeys = this.levelkeys;
              if (!levelkeys && !this._decryptdata) {
                return null;
              }
              if (!this._decryptdata && this.levelkeys && !this.levelkeys.NONE) {
                var key = this.levelkeys.identity;
                if (key) {
                  this._decryptdata = key.getDecryptData(this.sn);
                } else {
                  var keyFormats = Object.keys(this.levelkeys);
                  if (keyFormats.length === 1) {
                    return this._decryptdata = this.levelkeys[keyFormats[0]].getDecryptData(this.sn);
                  }
                }
              }
              return this._decryptdata;
            }
          }, {
            key: "end",
            get: function get() {
              return this.start + this.duration;
            }
          }, {
            key: "endProgramDateTime",
            get: function get() {
              if (this.programDateTime === null) {
                return null;
              }
              var duration = !isFiniteNumber(this.duration) ? 0 : this.duration;
              return this.programDateTime + duration * 1e3;
            }
          }, {
            key: "encrypted",
            get: function get() {
              var _this$_decryptdata;
              if ((_this$_decryptdata = this._decryptdata) != null && _this$_decryptdata.encrypted) {
                return true;
              } else if (this.levelkeys) {
                var keyFormats = Object.keys(this.levelkeys);
                var len = keyFormats.length;
                if (len > 1 || len === 1 && this.levelkeys[keyFormats[0]].encrypted) {
                  return true;
                }
              }
              return false;
            }
          }, {
            key: "programDateTime",
            get: function get() {
              if (this._programDateTime === null && this.rawProgramDateTime) {
                this.programDateTime = Date.parse(this.rawProgramDateTime);
              }
              return this._programDateTime;
            },
            set: function set(value) {
              if (!isFiniteNumber(value)) {
                this._programDateTime = this.rawProgramDateTime = null;
                return;
              }
              this._programDateTime = value;
            }
          }, {
            key: "ref",
            get: function get() {
              if (!isMediaFragment(this)) {
                return null;
              }
              if (!this._ref) {
                this._ref = {
                  base: this.base,
                  start: this.start,
                  duration: this.duration,
                  sn: this.sn,
                  programDateTime: this.programDateTime
                };
              }
              return this._ref;
            }
          }]);
        }(BaseSegment);
        var Part = /* @__PURE__ */ function(_BaseSegment3) {
          function Part2(partAttrs, frag, base, index, previous) {
            var _this2;
            _this2 = _BaseSegment3.call(this, base) || this;
            _this2.fragOffset = 0;
            _this2.duration = 0;
            _this2.gap = false;
            _this2.independent = false;
            _this2.relurl = void 0;
            _this2.fragment = void 0;
            _this2.index = void 0;
            _this2.duration = partAttrs.decimalFloatingPoint("DURATION");
            _this2.gap = partAttrs.bool("GAP");
            _this2.independent = partAttrs.bool("INDEPENDENT");
            _this2.relurl = partAttrs.enumeratedString("URI");
            _this2.fragment = frag;
            _this2.index = index;
            var byteRange = partAttrs.enumeratedString("BYTERANGE");
            if (byteRange) {
              _this2.setByteRange(byteRange, previous);
            }
            if (previous) {
              _this2.fragOffset = previous.fragOffset + previous.duration;
            }
            return _this2;
          }
          _inheritsLoose(Part2, _BaseSegment3);
          return _createClass4(Part2, [{
            key: "start",
            get: function get() {
              return this.fragment.start + this.fragOffset;
            }
          }, {
            key: "end",
            get: function get() {
              return this.start + this.duration;
            }
          }, {
            key: "loaded",
            get: function get() {
              var elementaryStreams = this.elementaryStreams;
              return !!(elementaryStreams.audio || elementaryStreams.video || elementaryStreams.audiovideo);
            }
          }]);
        }(BaseSegment);
        function getOwnPropertyDescriptorFromPrototypeChain(object, property) {
          var prototype = Object.getPrototypeOf(object);
          if (prototype) {
            var propertyDescriptor = Object.getOwnPropertyDescriptor(prototype, property);
            if (propertyDescriptor) {
              return propertyDescriptor;
            }
            return getOwnPropertyDescriptorFromPrototypeChain(prototype, property);
          }
        }
        function makeEnumerable(object, property) {
          var d = getOwnPropertyDescriptorFromPrototypeChain(object, property);
          if (d) {
            d.enumerable = true;
            Object.defineProperty(object, property, d);
          }
        }
        var UINT32_MAX$1 = Math.pow(2, 32) - 1;
        var push = [].push;
        var RemuxerTrackIdConfig = {
          video: 1,
          audio: 2,
          id3: 3,
          text: 4
        };
        function bin2str(data) {
          return String.fromCharCode.apply(null, data);
        }
        function readUint16(buffer, offset) {
          var val = buffer[offset] << 8 | buffer[offset + 1];
          return val < 0 ? 65536 + val : val;
        }
        function readUint32(buffer, offset) {
          var val = readSint32(buffer, offset);
          return val < 0 ? 4294967296 + val : val;
        }
        function readUint64(buffer, offset) {
          var result = readUint32(buffer, offset);
          result *= Math.pow(2, 32);
          result += readUint32(buffer, offset + 4);
          return result;
        }
        function readSint32(buffer, offset) {
          return buffer[offset] << 24 | buffer[offset + 1] << 16 | buffer[offset + 2] << 8 | buffer[offset + 3];
        }
        function writeUint32(buffer, offset, value) {
          buffer[offset] = value >> 24;
          buffer[offset + 1] = value >> 16 & 255;
          buffer[offset + 2] = value >> 8 & 255;
          buffer[offset + 3] = value & 255;
        }
        function hasMoofData(data) {
          var end = data.byteLength;
          for (var i = 0; i < end; ) {
            var size = readUint32(data, i);
            if (size > 8 && data[i + 4] === 109 && data[i + 5] === 111 && data[i + 6] === 111 && data[i + 7] === 102) {
              return true;
            }
            i = size > 1 ? i + size : end;
          }
          return false;
        }
        function findBox(data, path) {
          var results = [];
          if (!path.length) {
            return results;
          }
          var end = data.byteLength;
          for (var i = 0; i < end; ) {
            var size = readUint32(data, i);
            var type = bin2str(data.subarray(i + 4, i + 8));
            var endbox = size > 1 ? i + size : end;
            if (type === path[0]) {
              if (path.length === 1) {
                results.push(data.subarray(i + 8, endbox));
              } else {
                var subresults = findBox(data.subarray(i + 8, endbox), path.slice(1));
                if (subresults.length) {
                  push.apply(results, subresults);
                }
              }
            }
            i = endbox;
          }
          return results;
        }
        function parseSegmentIndex(sidx) {
          var references = [];
          var version2 = sidx[0];
          var index = 8;
          var timescale = readUint32(sidx, index);
          index += 4;
          var earliestPresentationTime = 0;
          var firstOffset = 0;
          if (version2 === 0) {
            earliestPresentationTime = readUint32(sidx, index);
            firstOffset = readUint32(sidx, index + 4);
            index += 8;
          } else {
            earliestPresentationTime = readUint64(sidx, index);
            firstOffset = readUint64(sidx, index + 8);
            index += 16;
          }
          index += 2;
          var startByte = sidx.length + firstOffset;
          var referencesCount = readUint16(sidx, index);
          index += 2;
          for (var i = 0; i < referencesCount; i++) {
            var referenceIndex = index;
            var referenceInfo = readUint32(sidx, referenceIndex);
            referenceIndex += 4;
            var referenceSize = referenceInfo & 2147483647;
            var referenceType = (referenceInfo & 2147483648) >>> 31;
            if (referenceType === 1) {
              logger4.warn("SIDX has hierarchical references (not supported)");
              return null;
            }
            var subsegmentDuration = readUint32(sidx, referenceIndex);
            referenceIndex += 4;
            references.push({
              referenceSize,
              subsegmentDuration,
              // unscaled
              info: {
                duration: subsegmentDuration / timescale,
                start: startByte,
                end: startByte + referenceSize - 1
              }
            });
            startByte += referenceSize;
            referenceIndex += 4;
            index = referenceIndex;
          }
          return {
            earliestPresentationTime,
            timescale,
            version: version2,
            referencesCount,
            references
          };
        }
        function parseInitSegment(initSegment) {
          var result = [];
          var traks = findBox(initSegment, ["moov", "trak"]);
          for (var i = 0; i < traks.length; i++) {
            var trak = traks[i];
            var tkhd = findBox(trak, ["tkhd"])[0];
            if (tkhd) {
              var version2 = tkhd[0];
              var trackId = readUint32(tkhd, version2 === 0 ? 12 : 20);
              var mdhd = findBox(trak, ["mdia", "mdhd"])[0];
              if (mdhd) {
                version2 = mdhd[0];
                var timescale = readUint32(mdhd, version2 === 0 ? 12 : 20);
                var hdlr = findBox(trak, ["mdia", "hdlr"])[0];
                if (hdlr) {
                  var hdlrType = bin2str(hdlr.subarray(8, 12));
                  var type = {
                    soun: ElementaryStreamTypes.AUDIO,
                    vide: ElementaryStreamTypes.VIDEO
                  }[hdlrType];
                  var stsdBox = findBox(trak, ["mdia", "minf", "stbl", "stsd"])[0];
                  var stsd = parseStsd(stsdBox);
                  if (type) {
                    result[trackId] = {
                      timescale,
                      type,
                      stsd
                    };
                    result[type] = _objectSpread23({
                      timescale,
                      id: trackId
                    }, stsd);
                  } else {
                    result[trackId] = {
                      timescale,
                      type: hdlrType,
                      stsd
                    };
                  }
                }
              }
            }
          }
          var trex = findBox(initSegment, ["moov", "mvex", "trex"]);
          trex.forEach(function(trex2) {
            var trackId2 = readUint32(trex2, 4);
            var track = result[trackId2];
            if (track) {
              track.default = {
                duration: readUint32(trex2, 12),
                flags: readUint32(trex2, 20)
              };
            }
          });
          return result;
        }
        function parseStsd(stsd) {
          var sampleEntries = stsd.subarray(8);
          var sampleEntriesEnd = sampleEntries.subarray(8 + 78);
          var fourCC = bin2str(sampleEntries.subarray(4, 8));
          var codec = fourCC;
          var supplemental;
          var encrypted = fourCC === "enca" || fourCC === "encv";
          if (encrypted) {
            var encBox = findBox(sampleEntries, [fourCC])[0];
            var encBoxChildren = encBox.subarray(fourCC === "enca" ? 28 : 78);
            var sinfs = findBox(encBoxChildren, ["sinf"]);
            sinfs.forEach(function(sinf) {
              var schm = findBox(sinf, ["schm"])[0];
              if (schm) {
                var scheme = bin2str(schm.subarray(4, 8));
                if (scheme === "cbcs" || scheme === "cenc") {
                  var frma = findBox(sinf, ["frma"])[0];
                  if (frma) {
                    codec = bin2str(frma);
                  }
                }
              }
            });
          }
          var codecFourCC = codec;
          switch (codec) {
            case "avc1":
            case "avc2":
            case "avc3":
            case "avc4": {
              var avcCBox = findBox(sampleEntriesEnd, ["avcC"])[0];
              codec += "." + toHex(avcCBox[1]) + toHex(avcCBox[2]) + toHex(avcCBox[3]);
              supplemental = parseSupplementalDoViCodec(codecFourCC === "avc1" ? "dva1" : "dvav", sampleEntriesEnd);
              break;
            }
            case "mp4a": {
              var codecBox = findBox(sampleEntries, [fourCC])[0];
              var esdsBox = findBox(codecBox.subarray(28), ["esds"])[0];
              if (esdsBox && esdsBox.length > 7) {
                var i = 4;
                if (esdsBox[i++] !== 3) {
                  break;
                }
                i = skipBERInteger(esdsBox, i);
                i += 2;
                var flags = esdsBox[i++];
                if (flags & 128) {
                  i += 2;
                }
                if (flags & 64) {
                  i += esdsBox[i++];
                }
                if (esdsBox[i++] !== 4) {
                  break;
                }
                i = skipBERInteger(esdsBox, i);
                var objectType = esdsBox[i++];
                if (objectType === 64) {
                  codec += "." + toHex(objectType);
                } else {
                  break;
                }
                i += 12;
                if (esdsBox[i++] !== 5) {
                  break;
                }
                i = skipBERInteger(esdsBox, i);
                var firstByte = esdsBox[i++];
                var audioObjectType = (firstByte & 248) >> 3;
                if (audioObjectType === 31) {
                  audioObjectType += 1 + ((firstByte & 7) << 3) + ((esdsBox[i] & 224) >> 5);
                }
                codec += "." + audioObjectType;
              }
              break;
            }
            case "hvc1":
            case "hev1": {
              var hvcCBoxes = findBox(sampleEntriesEnd, ["hvcC"]);
              if (hvcCBoxes) {
                var hvcCBox = hvcCBoxes[0];
                var profileByte = hvcCBox[1];
                var profileSpace = ["", "A", "B", "C"][profileByte >> 6];
                var generalProfileIdc = profileByte & 31;
                var profileCompat = readUint32(hvcCBox, 2);
                var tierFlag = (profileByte & 32) >> 5 ? "H" : "L";
                var levelIDC = hvcCBox[12];
                var constraintIndicator = hvcCBox.subarray(6, 12);
                codec += "." + profileSpace + generalProfileIdc;
                codec += "." + profileCompat.toString(16).toUpperCase();
                codec += "." + tierFlag + levelIDC;
                var constraintString = "";
                for (var _i = constraintIndicator.length; _i--; ) {
                  var _byte = constraintIndicator[_i];
                  if (_byte || constraintString) {
                    var encodedByte = _byte.toString(16).toUpperCase();
                    constraintString = "." + encodedByte + constraintString;
                  }
                }
                codec += constraintString;
              }
              supplemental = parseSupplementalDoViCodec(codecFourCC == "hev1" ? "dvhe" : "dvh1", sampleEntriesEnd);
              break;
            }
            case "dvh1":
            case "dvhe":
            case "dvav":
            case "dva1":
            case "dav1": {
              codec = parseSupplementalDoViCodec(codec, sampleEntriesEnd) || codec;
              break;
            }
            case "vp09": {
              var vpcCBox = findBox(sampleEntriesEnd, ["vpcC"])[0];
              var profile = vpcCBox[4];
              var level = vpcCBox[5];
              var bitDepth = vpcCBox[6] >> 4 & 15;
              codec += "." + addLeadingZero(profile) + "." + addLeadingZero(level) + "." + addLeadingZero(bitDepth);
              break;
            }
            case "av01": {
              var av1CBox = findBox(sampleEntriesEnd, ["av1C"])[0];
              var _profile = av1CBox[1] >>> 5;
              var _level = av1CBox[1] & 31;
              var _tierFlag = av1CBox[2] >>> 7 ? "H" : "M";
              var highBitDepth = (av1CBox[2] & 64) >> 6;
              var twelveBit = (av1CBox[2] & 32) >> 5;
              var _bitDepth = _profile === 2 && highBitDepth ? twelveBit ? 12 : 10 : highBitDepth ? 10 : 8;
              var monochrome = (av1CBox[2] & 16) >> 4;
              var chromaSubsamplingX = (av1CBox[2] & 8) >> 3;
              var chromaSubsamplingY = (av1CBox[2] & 4) >> 2;
              var chromaSamplePosition = av1CBox[2] & 3;
              var colorPrimaries = 1;
              var transferCharacteristics = 1;
              var matrixCoefficients = 1;
              var videoFullRangeFlag = 0;
              codec += "." + _profile + "." + addLeadingZero(_level) + _tierFlag + "." + addLeadingZero(_bitDepth) + "." + monochrome + "." + chromaSubsamplingX + chromaSubsamplingY + chromaSamplePosition + "." + addLeadingZero(colorPrimaries) + "." + addLeadingZero(transferCharacteristics) + "." + addLeadingZero(matrixCoefficients) + "." + videoFullRangeFlag;
              supplemental = parseSupplementalDoViCodec("dav1", sampleEntriesEnd);
              break;
            }
          }
          return {
            codec,
            encrypted,
            supplemental
          };
        }
        function parseSupplementalDoViCodec(fourCC, sampleEntriesEnd) {
          var dvvCResult = findBox(sampleEntriesEnd, ["dvvC"]);
          var dvXCBox = dvvCResult.length ? dvvCResult[0] : findBox(sampleEntriesEnd, ["dvcC"])[0];
          if (dvXCBox) {
            var doViProfile = dvXCBox[2] >> 1 & 127;
            var doViLevel = dvXCBox[2] << 5 & 32 | dvXCBox[3] >> 3 & 31;
            return fourCC + "." + addLeadingZero(doViProfile) + "." + addLeadingZero(doViLevel);
          }
        }
        function skipBERInteger(bytes, i) {
          var limit = i + 5;
          while (bytes[i++] & 128 && i < limit) {
          }
          return i;
        }
        function toHex(x) {
          return ("0" + x.toString(16).toUpperCase()).slice(-2);
        }
        function addLeadingZero(num) {
          return (num < 10 ? "0" : "") + num;
        }
        function patchEncyptionData(initSegment, decryptdata) {
          if (!initSegment || !decryptdata) {
            return initSegment;
          }
          var keyId = decryptdata.keyId;
          if (keyId && decryptdata.isCommonEncryption) {
            var traks = findBox(initSegment, ["moov", "trak"]);
            traks.forEach(function(trak) {
              var stsd = findBox(trak, ["mdia", "minf", "stbl", "stsd"])[0];
              var sampleEntries = stsd.subarray(8);
              var encBoxes = findBox(sampleEntries, ["enca"]);
              var isAudio = encBoxes.length > 0;
              if (!isAudio) {
                encBoxes = findBox(sampleEntries, ["encv"]);
              }
              encBoxes.forEach(function(enc) {
                var encBoxChildren = isAudio ? enc.subarray(28) : enc.subarray(78);
                var sinfBoxes = findBox(encBoxChildren, ["sinf"]);
                sinfBoxes.forEach(function(sinf) {
                  var tenc = parseSinf(sinf);
                  if (tenc) {
                    var tencKeyId = tenc.subarray(8, 24);
                    if (!tencKeyId.some(function(b) {
                      return b !== 0;
                    })) {
                      logger4.log("[eme] Patching keyId in 'enc" + (isAudio ? "a" : "v") + ">sinf>>tenc' box: " + Hex.hexDump(tencKeyId) + " -> " + Hex.hexDump(keyId));
                      tenc.set(keyId, 8);
                    }
                  }
                });
              });
            });
          }
          return initSegment;
        }
        function parseSinf(sinf) {
          var schm = findBox(sinf, ["schm"])[0];
          if (schm) {
            var scheme = bin2str(schm.subarray(4, 8));
            if (scheme === "cbcs" || scheme === "cenc") {
              return findBox(sinf, ["schi", "tenc"])[0];
            }
          }
          return null;
        }
        function getStartDTS(initData, fmp4) {
          return findBox(fmp4, ["moof", "traf"]).reduce(function(result, traf) {
            var tfdt = findBox(traf, ["tfdt"])[0];
            var version2 = tfdt[0];
            var start = findBox(traf, ["tfhd"]).reduce(function(result2, tfhd) {
              var id = readUint32(tfhd, 4);
              var track = initData[id];
              if (track) {
                var baseTime = readUint32(tfdt, 4);
                if (version2 === 1) {
                  if (baseTime === UINT32_MAX$1) {
                    logger4.warn("[mp4-demuxer]: Ignoring assumed invalid signed 64-bit track fragment decode time");
                    return result2;
                  }
                  baseTime *= UINT32_MAX$1 + 1;
                  baseTime += readUint32(tfdt, 8);
                }
                var scale = track.timescale || 9e4;
                var startTime = baseTime / scale;
                if (isFiniteNumber(startTime) && (result2 === null || startTime < result2)) {
                  return startTime;
                }
              }
              return result2;
            }, null);
            if (start !== null && isFiniteNumber(start) && (result === null || start < result)) {
              return start;
            }
            return result;
          }, null);
        }
        function getDuration(data, initData) {
          var rawDuration = 0;
          var videoDuration = 0;
          var audioDuration = 0;
          var trafs = findBox(data, ["moof", "traf"]);
          for (var i = 0; i < trafs.length; i++) {
            var traf = trafs[i];
            var tfhd = findBox(traf, ["tfhd"])[0];
            var id = readUint32(tfhd, 4);
            var track = initData[id];
            if (!track) {
              continue;
            }
            var trackDefault = track.default;
            var tfhdFlags = readUint32(tfhd, 0) | (trackDefault == null ? void 0 : trackDefault.flags);
            var sampleDuration = trackDefault == null ? void 0 : trackDefault.duration;
            if (tfhdFlags & 8) {
              if (tfhdFlags & 2) {
                sampleDuration = readUint32(tfhd, 12);
              } else {
                sampleDuration = readUint32(tfhd, 8);
              }
            }
            var timescale = track.timescale || 9e4;
            var truns = findBox(traf, ["trun"]);
            for (var j = 0; j < truns.length; j++) {
              rawDuration = computeRawDurationFromSamples(truns[j]);
              if (!rawDuration && sampleDuration) {
                var sampleCount = readUint32(truns[j], 4);
                rawDuration = sampleDuration * sampleCount;
              }
              if (track.type === ElementaryStreamTypes.VIDEO) {
                videoDuration += rawDuration / timescale;
              } else if (track.type === ElementaryStreamTypes.AUDIO) {
                audioDuration += rawDuration / timescale;
              }
            }
          }
          if (videoDuration === 0 && audioDuration === 0) {
            var sidxMinStart = Infinity;
            var sidxMaxEnd = 0;
            var sidxDuration = 0;
            var sidxs = findBox(data, ["sidx"]);
            for (var _i2 = 0; _i2 < sidxs.length; _i2++) {
              var sidx = parseSegmentIndex(sidxs[_i2]);
              if (sidx != null && sidx.references) {
                sidxMinStart = Math.min(sidxMinStart, sidx.earliestPresentationTime / sidx.timescale);
                var subSegmentDuration = sidx.references.reduce(function(dur, ref) {
                  return dur + ref.info.duration || 0;
                }, 0);
                sidxMaxEnd = Math.max(sidxMaxEnd, subSegmentDuration + sidx.earliestPresentationTime / sidx.timescale);
                sidxDuration = sidxMaxEnd - sidxMinStart;
              }
            }
            if (sidxDuration && isFiniteNumber(sidxDuration)) {
              return sidxDuration;
            }
          }
          if (videoDuration) {
            return videoDuration;
          }
          return audioDuration;
        }
        function computeRawDurationFromSamples(trun) {
          var flags = readUint32(trun, 0);
          var offset = 8;
          if (flags & 1) {
            offset += 4;
          }
          if (flags & 4) {
            offset += 4;
          }
          var duration = 0;
          var sampleCount = readUint32(trun, 4);
          for (var i = 0; i < sampleCount; i++) {
            if (flags & 256) {
              var sampleDuration = readUint32(trun, offset);
              duration += sampleDuration;
              offset += 4;
            }
            if (flags & 512) {
              offset += 4;
            }
            if (flags & 1024) {
              offset += 4;
            }
            if (flags & 2048) {
              offset += 4;
            }
          }
          return duration;
        }
        function offsetStartDTS(initData, fmp4, timeOffset) {
          findBox(fmp4, ["moof", "traf"]).forEach(function(traf) {
            findBox(traf, ["tfhd"]).forEach(function(tfhd) {
              var id = readUint32(tfhd, 4);
              var track = initData[id];
              if (!track) {
                return;
              }
              var timescale = track.timescale || 9e4;
              findBox(traf, ["tfdt"]).forEach(function(tfdt) {
                var version2 = tfdt[0];
                var offset = timeOffset * timescale;
                if (offset) {
                  var baseMediaDecodeTime = readUint32(tfdt, 4);
                  if (version2 === 0) {
                    baseMediaDecodeTime -= offset;
                    baseMediaDecodeTime = Math.max(baseMediaDecodeTime, 0);
                    writeUint32(tfdt, 4, baseMediaDecodeTime);
                  } else {
                    baseMediaDecodeTime *= Math.pow(2, 32);
                    baseMediaDecodeTime += readUint32(tfdt, 8);
                    baseMediaDecodeTime -= offset;
                    baseMediaDecodeTime = Math.max(baseMediaDecodeTime, 0);
                    var upper = Math.floor(baseMediaDecodeTime / (UINT32_MAX$1 + 1));
                    var lower = Math.floor(baseMediaDecodeTime % (UINT32_MAX$1 + 1));
                    writeUint32(tfdt, 4, upper);
                    writeUint32(tfdt, 8, lower);
                  }
                }
              });
            });
          });
        }
        function segmentValidRange(data) {
          var segmentedRange = {
            valid: null,
            remainder: null
          };
          var moofs = findBox(data, ["moof"]);
          if (moofs.length < 2) {
            segmentedRange.remainder = data;
            return segmentedRange;
          }
          var last = moofs[moofs.length - 1];
          segmentedRange.valid = data.slice(0, last.byteOffset - 8);
          segmentedRange.remainder = data.slice(last.byteOffset - 8);
          return segmentedRange;
        }
        function appendUint8Array(data1, data2) {
          var temp = new Uint8Array(data1.length + data2.length);
          temp.set(data1);
          temp.set(data2, data1.length);
          return temp;
        }
        function parseSamples(timeOffset, track) {
          var seiSamples = [];
          var videoData = track.samples;
          var timescale = track.timescale;
          var trackId = track.id;
          var isHEVCFlavor = false;
          var moofs = findBox(videoData, ["moof"]);
          moofs.map(function(moof) {
            var moofOffset = moof.byteOffset - 8;
            var trafs = findBox(moof, ["traf"]);
            trafs.map(function(traf) {
              var baseTime = findBox(traf, ["tfdt"]).map(function(tfdt) {
                var version2 = tfdt[0];
                var result = readUint32(tfdt, 4);
                if (version2 === 1) {
                  result *= Math.pow(2, 32);
                  result += readUint32(tfdt, 8);
                }
                return result / timescale;
              })[0];
              if (baseTime !== void 0) {
                timeOffset = baseTime;
              }
              return findBox(traf, ["tfhd"]).map(function(tfhd) {
                var id = readUint32(tfhd, 4);
                var tfhdFlags = readUint32(tfhd, 0) & 16777215;
                var baseDataOffsetPresent = (tfhdFlags & 1) !== 0;
                var sampleDescriptionIndexPresent = (tfhdFlags & 2) !== 0;
                var defaultSampleDurationPresent = (tfhdFlags & 8) !== 0;
                var defaultSampleDuration = 0;
                var defaultSampleSizePresent = (tfhdFlags & 16) !== 0;
                var defaultSampleSize = 0;
                var defaultSampleFlagsPresent = (tfhdFlags & 32) !== 0;
                var tfhdOffset = 8;
                if (id === trackId) {
                  if (baseDataOffsetPresent) {
                    tfhdOffset += 8;
                  }
                  if (sampleDescriptionIndexPresent) {
                    tfhdOffset += 4;
                  }
                  if (defaultSampleDurationPresent) {
                    defaultSampleDuration = readUint32(tfhd, tfhdOffset);
                    tfhdOffset += 4;
                  }
                  if (defaultSampleSizePresent) {
                    defaultSampleSize = readUint32(tfhd, tfhdOffset);
                    tfhdOffset += 4;
                  }
                  if (defaultSampleFlagsPresent) {
                    tfhdOffset += 4;
                  }
                  if (track.type === "video") {
                    isHEVCFlavor = isHEVC(track.codec);
                  }
                  findBox(traf, ["trun"]).map(function(trun) {
                    var version2 = trun[0];
                    var flags = readUint32(trun, 0) & 16777215;
                    var dataOffsetPresent = (flags & 1) !== 0;
                    var dataOffset = 0;
                    var firstSampleFlagsPresent = (flags & 4) !== 0;
                    var sampleDurationPresent = (flags & 256) !== 0;
                    var sampleDuration = 0;
                    var sampleSizePresent = (flags & 512) !== 0;
                    var sampleSize = 0;
                    var sampleFlagsPresent = (flags & 1024) !== 0;
                    var sampleCompositionOffsetsPresent = (flags & 2048) !== 0;
                    var compositionOffset = 0;
                    var sampleCount = readUint32(trun, 4);
                    var trunOffset = 8;
                    if (dataOffsetPresent) {
                      dataOffset = readUint32(trun, trunOffset);
                      trunOffset += 4;
                    }
                    if (firstSampleFlagsPresent) {
                      trunOffset += 4;
                    }
                    var sampleOffset = dataOffset + moofOffset;
                    for (var ix = 0; ix < sampleCount; ix++) {
                      if (sampleDurationPresent) {
                        sampleDuration = readUint32(trun, trunOffset);
                        trunOffset += 4;
                      } else {
                        sampleDuration = defaultSampleDuration;
                      }
                      if (sampleSizePresent) {
                        sampleSize = readUint32(trun, trunOffset);
                        trunOffset += 4;
                      } else {
                        sampleSize = defaultSampleSize;
                      }
                      if (sampleFlagsPresent) {
                        trunOffset += 4;
                      }
                      if (sampleCompositionOffsetsPresent) {
                        if (version2 === 0) {
                          compositionOffset = readUint32(trun, trunOffset);
                        } else {
                          compositionOffset = readSint32(trun, trunOffset);
                        }
                        trunOffset += 4;
                      }
                      if (track.type === ElementaryStreamTypes.VIDEO) {
                        var naluTotalSize = 0;
                        while (naluTotalSize < sampleSize) {
                          var naluSize = readUint32(videoData, sampleOffset);
                          sampleOffset += 4;
                          if (isSEIMessage(isHEVCFlavor, videoData[sampleOffset])) {
                            var data = videoData.subarray(sampleOffset, sampleOffset + naluSize);
                            parseSEIMessageFromNALu(data, isHEVCFlavor ? 2 : 1, timeOffset + compositionOffset / timescale, seiSamples);
                          }
                          sampleOffset += naluSize;
                          naluTotalSize += naluSize + 4;
                        }
                      }
                      timeOffset += sampleDuration / timescale;
                    }
                  });
                }
              });
            });
          });
          return seiSamples;
        }
        function isHEVC(codec) {
          if (!codec) {
            return false;
          }
          var baseCodec = codec.substring(0, 4);
          return baseCodec === "hvc1" || baseCodec === "hev1" || // Dolby Vision
          baseCodec === "dvh1" || baseCodec === "dvhe";
        }
        function isSEIMessage(isHEVCFlavor, naluHeader) {
          if (isHEVCFlavor) {
            var naluType = naluHeader >> 1 & 63;
            return naluType === 39 || naluType === 40;
          } else {
            var _naluType = naluHeader & 31;
            return _naluType === 6;
          }
        }
        function parseSEIMessageFromNALu(unescapedData, headerSize, pts, samples) {
          var data = discardEPB(unescapedData);
          var seiPtr = 0;
          seiPtr += headerSize;
          var payloadType = 0;
          var payloadSize = 0;
          var b = 0;
          while (seiPtr < data.length) {
            payloadType = 0;
            do {
              if (seiPtr >= data.length) {
                break;
              }
              b = data[seiPtr++];
              payloadType += b;
            } while (b === 255);
            payloadSize = 0;
            do {
              if (seiPtr >= data.length) {
                break;
              }
              b = data[seiPtr++];
              payloadSize += b;
            } while (b === 255);
            var leftOver = data.length - seiPtr;
            var payPtr = seiPtr;
            if (payloadSize < leftOver) {
              seiPtr += payloadSize;
            } else if (payloadSize > leftOver) {
              logger4.error("Malformed SEI payload. " + payloadSize + " is too small, only " + leftOver + " bytes left to parse.");
              break;
            }
            if (payloadType === 4) {
              var countryCode = data[payPtr++];
              if (countryCode === 181) {
                var providerCode = readUint16(data, payPtr);
                payPtr += 2;
                if (providerCode === 49) {
                  var userStructure = readUint32(data, payPtr);
                  payPtr += 4;
                  if (userStructure === 1195456820) {
                    var userDataType = data[payPtr++];
                    if (userDataType === 3) {
                      var firstByte = data[payPtr++];
                      var totalCCs = 31 & firstByte;
                      var enabled = 64 & firstByte;
                      var totalBytes = enabled ? 2 + totalCCs * 3 : 0;
                      var byteArray = new Uint8Array(totalBytes);
                      if (enabled) {
                        byteArray[0] = firstByte;
                        for (var i = 1; i < totalBytes; i++) {
                          byteArray[i] = data[payPtr++];
                        }
                      }
                      samples.push({
                        type: userDataType,
                        payloadType,
                        pts,
                        bytes: byteArray
                      });
                    }
                  }
                }
              }
            } else if (payloadType === 5) {
              if (payloadSize > 16) {
                var uuidStrArray = [];
                for (var _i3 = 0; _i3 < 16; _i3++) {
                  var _b = data[payPtr++].toString(16);
                  uuidStrArray.push(_b.length == 1 ? "0" + _b : _b);
                  if (_i3 === 3 || _i3 === 5 || _i3 === 7 || _i3 === 9) {
                    uuidStrArray.push("-");
                  }
                }
                var length = payloadSize - 16;
                var userDataBytes = new Uint8Array(length);
                for (var _i4 = 0; _i4 < length; _i4++) {
                  userDataBytes[_i4] = data[payPtr++];
                }
                samples.push({
                  payloadType,
                  pts,
                  uuid: uuidStrArray.join(""),
                  userData: utf8ArrayToStr(userDataBytes),
                  userDataBytes
                });
              }
            }
          }
        }
        function discardEPB(data) {
          var length = data.byteLength;
          var EPBPositions = [];
          var i = 1;
          while (i < length - 2) {
            if (data[i] === 0 && data[i + 1] === 0 && data[i + 2] === 3) {
              EPBPositions.push(i + 2);
              i += 2;
            } else {
              i++;
            }
          }
          if (EPBPositions.length === 0) {
            return data;
          }
          var newLength = length - EPBPositions.length;
          var newData = new Uint8Array(newLength);
          var sourceIndex = 0;
          for (i = 0; i < newLength; sourceIndex++, i++) {
            if (sourceIndex === EPBPositions[0]) {
              sourceIndex++;
              EPBPositions.shift();
            }
            newData[i] = data[sourceIndex];
          }
          return newData;
        }
        function parseEmsg(data) {
          var version2 = data[0];
          var schemeIdUri = "";
          var value = "";
          var timeScale = 0;
          var presentationTimeDelta = 0;
          var presentationTime = 0;
          var eventDuration = 0;
          var id = 0;
          var offset = 0;
          if (version2 === 0) {
            while (bin2str(data.subarray(offset, offset + 1)) !== "\0") {
              schemeIdUri += bin2str(data.subarray(offset, offset + 1));
              offset += 1;
            }
            schemeIdUri += bin2str(data.subarray(offset, offset + 1));
            offset += 1;
            while (bin2str(data.subarray(offset, offset + 1)) !== "\0") {
              value += bin2str(data.subarray(offset, offset + 1));
              offset += 1;
            }
            value += bin2str(data.subarray(offset, offset + 1));
            offset += 1;
            timeScale = readUint32(data, 12);
            presentationTimeDelta = readUint32(data, 16);
            eventDuration = readUint32(data, 20);
            id = readUint32(data, 24);
            offset = 28;
          } else if (version2 === 1) {
            offset += 4;
            timeScale = readUint32(data, offset);
            offset += 4;
            var leftPresentationTime = readUint32(data, offset);
            offset += 4;
            var rightPresentationTime = readUint32(data, offset);
            offset += 4;
            presentationTime = Math.pow(2, 32) * leftPresentationTime + rightPresentationTime;
            if (!isSafeInteger(presentationTime)) {
              presentationTime = Number.MAX_SAFE_INTEGER;
              logger4.warn("Presentation time exceeds safe integer limit and wrapped to max safe integer in parsing emsg box");
            }
            eventDuration = readUint32(data, offset);
            offset += 4;
            id = readUint32(data, offset);
            offset += 4;
            while (bin2str(data.subarray(offset, offset + 1)) !== "\0") {
              schemeIdUri += bin2str(data.subarray(offset, offset + 1));
              offset += 1;
            }
            schemeIdUri += bin2str(data.subarray(offset, offset + 1));
            offset += 1;
            while (bin2str(data.subarray(offset, offset + 1)) !== "\0") {
              value += bin2str(data.subarray(offset, offset + 1));
              offset += 1;
            }
            value += bin2str(data.subarray(offset, offset + 1));
            offset += 1;
          }
          var payload = data.subarray(offset, data.byteLength);
          return {
            schemeIdUri,
            value,
            timeScale,
            presentationTime,
            presentationTimeDelta,
            eventDuration,
            id,
            payload
          };
        }
        function getMediaSource2(preferManagedMediaSource) {
          if (preferManagedMediaSource === void 0) {
            preferManagedMediaSource = true;
          }
          if (typeof self === "undefined") return void 0;
          var mms = (preferManagedMediaSource || !self.MediaSource) && self.ManagedMediaSource;
          return mms || self.MediaSource || self.WebKitMediaSource;
        }
        function isManagedMediaSource(source) {
          return typeof self !== "undefined" && source === self.ManagedMediaSource;
        }
        function isCompatibleTrackChange(currentTracks, requiredTracks) {
          var trackNames = Object.keys(currentTracks);
          var requiredTrackNames = Object.keys(requiredTracks);
          var trackCount = trackNames.length;
          var requiredTrackCount = requiredTrackNames.length;
          return !trackCount || !requiredTrackCount || trackCount === requiredTrackCount && !trackNames.some(function(name) {
            return requiredTrackNames.indexOf(name) === -1;
          });
        }
        var userAgentHevcSupportIsInaccurate = function userAgentHevcSupportIsInaccurate2() {
          return /\(Windows.+Firefox\//i.test(navigator.userAgent);
        };
        var sampleEntryCodesISO = {
          audio: {
            a3ds: 1,
            "ac-3": 0.95,
            "ac-4": 1,
            alac: 0.9,
            alaw: 1,
            dra1: 1,
            "dts+": 1,
            "dts-": 1,
            dtsc: 1,
            dtse: 1,
            dtsh: 1,
            "ec-3": 0.9,
            enca: 1,
            fLaC: 0.9,
            // MP4-RA listed codec entry for FLAC
            flac: 0.9,
            // legacy browser codec name for FLAC
            FLAC: 0.9,
            // some manifests may list "FLAC" with Apple's tools
            g719: 1,
            g726: 1,
            m4ae: 1,
            mha1: 1,
            mha2: 1,
            mhm1: 1,
            mhm2: 1,
            mlpa: 1,
            mp4a: 1,
            "raw ": 1,
            Opus: 1,
            opus: 1,
            // browsers expect this to be lowercase despite MP4RA says 'Opus'
            samr: 1,
            sawb: 1,
            sawp: 1,
            sevc: 1,
            sqcp: 1,
            ssmv: 1,
            twos: 1,
            ulaw: 1
          },
          video: {
            avc1: 1,
            avc2: 1,
            avc3: 1,
            avc4: 1,
            avcp: 1,
            av01: 0.8,
            dav1: 0.8,
            drac: 1,
            dva1: 1,
            dvav: 1,
            dvh1: 0.7,
            dvhe: 0.7,
            encv: 1,
            hev1: 0.75,
            hvc1: 0.75,
            mjp2: 1,
            mp4v: 1,
            mvc1: 1,
            mvc2: 1,
            mvc3: 1,
            mvc4: 1,
            resv: 1,
            rv60: 1,
            s263: 1,
            svc1: 1,
            svc2: 1,
            "vc-1": 1,
            vp08: 1,
            vp09: 0.9
          },
          text: {
            stpp: 1,
            wvtt: 1
          }
        };
        function isCodecType(codec, type) {
          var typeCodes = sampleEntryCodesISO[type];
          return !!typeCodes && !!typeCodes[codec.slice(0, 4)];
        }
        function areCodecsMediaSourceSupported(codecs, type, preferManagedMediaSource) {
          if (preferManagedMediaSource === void 0) {
            preferManagedMediaSource = true;
          }
          return !codecs.split(",").some(function(codec) {
            return !isCodecMediaSourceSupported(codec, type, preferManagedMediaSource);
          });
        }
        function isCodecMediaSourceSupported(codec, type, preferManagedMediaSource) {
          var _MediaSource$isTypeSu;
          if (preferManagedMediaSource === void 0) {
            preferManagedMediaSource = true;
          }
          var MediaSource2 = getMediaSource2(preferManagedMediaSource);
          return (_MediaSource$isTypeSu = MediaSource2 == null ? void 0 : MediaSource2.isTypeSupported(mimeTypeForCodec(codec, type))) != null ? _MediaSource$isTypeSu : false;
        }
        function mimeTypeForCodec(codec, type) {
          return type + "/mp4;codecs=" + codec;
        }
        function videoCodecPreferenceValue(videoCodec) {
          if (videoCodec) {
            var fourCC = videoCodec.substring(0, 4);
            return sampleEntryCodesISO.video[fourCC];
          }
          return 2;
        }
        function codecsSetSelectionPreferenceValue(codecSet) {
          var limitedHevcSupport = userAgentHevcSupportIsInaccurate();
          return codecSet.split(",").reduce(function(num, fourCC) {
            var lowerPriority = limitedHevcSupport && isHEVC(fourCC);
            var preferenceValue = lowerPriority ? 9 : sampleEntryCodesISO.video[fourCC];
            if (preferenceValue) {
              return (preferenceValue * 2 + num) / (num ? 3 : 2);
            }
            return (sampleEntryCodesISO.audio[fourCC] + num) / (num ? 2 : 1);
          }, 0);
        }
        var CODEC_COMPATIBLE_NAMES = {};
        function getCodecCompatibleNameLower(lowerCaseCodec, preferManagedMediaSource) {
          if (preferManagedMediaSource === void 0) {
            preferManagedMediaSource = true;
          }
          if (CODEC_COMPATIBLE_NAMES[lowerCaseCodec]) {
            return CODEC_COMPATIBLE_NAMES[lowerCaseCodec];
          }
          var codecsToCheck = {
            // Idealy fLaC and Opus would be first (spec-compliant) but
            // some browsers will report that fLaC is supported then fail.
            // see: https://bugs.chromium.org/p/chromium/issues/detail?id=1422728
            flac: ["flac", "fLaC", "FLAC"],
            opus: ["opus", "Opus"],
            // Replace audio codec info if browser does not support mp4a.40.34,
            // and demuxer can fallback to 'audio/mpeg' or 'audio/mp4;codecs="mp3"'
            "mp4a.40.34": ["mp3"]
          }[lowerCaseCodec];
          for (var i = 0; i < codecsToCheck.length; i++) {
            var _getMediaSource;
            if (isCodecMediaSourceSupported(codecsToCheck[i], "audio", preferManagedMediaSource)) {
              CODEC_COMPATIBLE_NAMES[lowerCaseCodec] = codecsToCheck[i];
              return codecsToCheck[i];
            } else if (codecsToCheck[i] === "mp3" && (_getMediaSource = getMediaSource2(preferManagedMediaSource)) != null && _getMediaSource.isTypeSupported("audio/mpeg")) {
              return "";
            }
          }
          return lowerCaseCodec;
        }
        var AUDIO_CODEC_REGEXP = /flac|opus|mp4a\.40\.34/i;
        function getCodecCompatibleName(codec, preferManagedMediaSource) {
          if (preferManagedMediaSource === void 0) {
            preferManagedMediaSource = true;
          }
          return codec.replace(AUDIO_CODEC_REGEXP, function(m) {
            return getCodecCompatibleNameLower(m.toLowerCase(), preferManagedMediaSource);
          });
        }
        function replaceVideoCodec(originalCodecs, newVideoCodec) {
          var codecs = [];
          if (originalCodecs) {
            var allCodecs = originalCodecs.split(",");
            for (var i = 0; i < allCodecs.length; i++) {
              if (!isCodecType(allCodecs[i], "video")) {
                codecs.push(allCodecs[i]);
              }
            }
          }
          if (newVideoCodec) {
            codecs.push(newVideoCodec);
          }
          return codecs.join(",");
        }
        function pickMostCompleteCodecName(parsedCodec, levelCodec) {
          if (parsedCodec && (parsedCodec.length > 4 || ["ac-3", "ec-3", "alac", "fLaC", "Opus"].indexOf(parsedCodec) !== -1)) {
            return parsedCodec;
          }
          if (levelCodec) {
            var levelCodecs = levelCodec.split(",");
            if (levelCodecs.length > 1) {
              if (parsedCodec) {
                for (var i = levelCodecs.length; i--; ) {
                  if (levelCodecs[i].substring(0, 4) === parsedCodec.substring(0, 4)) {
                    return levelCodecs[i];
                  }
                }
              }
              return levelCodecs[0];
            }
          }
          return levelCodec || parsedCodec;
        }
        function convertAVC1ToAVCOTI(videoCodecs) {
          var codecs = videoCodecs.split(",");
          for (var i = 0; i < codecs.length; i++) {
            var avcdata = codecs[i].split(".");
            if (avcdata.length > 2) {
              var result = avcdata.shift() + ".";
              result += parseInt(avcdata.shift()).toString(16);
              result += ("000" + parseInt(avcdata.shift()).toString(16)).slice(-4);
              codecs[i] = result;
            }
          }
          return codecs.join(",");
        }
        function fillInMissingAV01Params(videoCodec) {
          if (videoCodec.startsWith("av01.")) {
            var av1params = videoCodec.split(".");
            var placeholders = ["0", "111", "01", "01", "01", "0"];
            for (var i = av1params.length; i > 4 && i < 10; i++) {
              av1params[i] = placeholders[i - 4];
            }
            return av1params.join(".");
          }
          return videoCodec;
        }
        function getM2TSSupportedAudioTypes(preferManagedMediaSource) {
          var MediaSource2 = getMediaSource2(preferManagedMediaSource) || {
            isTypeSupported: function isTypeSupported() {
              return false;
            }
          };
          return {
            mpeg: MediaSource2.isTypeSupported("audio/mpeg"),
            mp3: MediaSource2.isTypeSupported('audio/mp4; codecs="mp3"'),
            ac3: false
          };
        }
        function getCodecsForMimeType(mimeType) {
          return mimeType.replace(/^.+codecs=["']?([^"']+).*$/, "$1");
        }
        var HdcpLevels = ["NONE", "TYPE-0", "TYPE-1", null];
        function isHdcpLevel(value) {
          return HdcpLevels.indexOf(value) > -1;
        }
        var VideoRangeValues = ["SDR", "PQ", "HLG"];
        function isVideoRange(value) {
          return !!value && VideoRangeValues.indexOf(value) > -1;
        }
        var HlsSkip = {
          No: "",
          Yes: "YES",
          v2: "v2"
        };
        function getSkipValue(details) {
          var canSkipUntil = details.canSkipUntil, canSkipDateRanges = details.canSkipDateRanges, age = details.age;
          var playlistRecentEnough = age < canSkipUntil / 2;
          if (canSkipUntil && playlistRecentEnough) {
            if (canSkipDateRanges) {
              return HlsSkip.v2;
            }
            return HlsSkip.Yes;
          }
          return HlsSkip.No;
        }
        var HlsUrlParameters = /* @__PURE__ */ function() {
          function HlsUrlParameters2(msn, part, skip) {
            this.msn = void 0;
            this.part = void 0;
            this.skip = void 0;
            this.msn = msn;
            this.part = part;
            this.skip = skip;
          }
          var _proto = HlsUrlParameters2.prototype;
          _proto.addDirectives = function addDirectives(uri) {
            var url = new self.URL(uri);
            if (this.msn !== void 0) {
              url.searchParams.set("_HLS_msn", this.msn.toString());
            }
            if (this.part !== void 0) {
              url.searchParams.set("_HLS_part", this.part.toString());
            }
            if (this.skip) {
              url.searchParams.set("_HLS_skip", this.skip);
            }
            return url.href;
          };
          return HlsUrlParameters2;
        }();
        var Level = /* @__PURE__ */ function() {
          function Level2(data) {
            this._attrs = void 0;
            this.audioCodec = void 0;
            this.bitrate = void 0;
            this.codecSet = void 0;
            this.url = void 0;
            this.frameRate = void 0;
            this.height = void 0;
            this.id = void 0;
            this.name = void 0;
            this.supplemental = void 0;
            this.videoCodec = void 0;
            this.width = void 0;
            this.details = void 0;
            this.fragmentError = 0;
            this.loadError = 0;
            this.loaded = void 0;
            this.realBitrate = 0;
            this.supportedPromise = void 0;
            this.supportedResult = void 0;
            this._avgBitrate = 0;
            this._audioGroups = void 0;
            this._subtitleGroups = void 0;
            this._urlId = 0;
            this.url = [data.url];
            this._attrs = [data.attrs];
            this.bitrate = data.bitrate;
            if (data.details) {
              this.details = data.details;
            }
            this.id = data.id || 0;
            this.name = data.name;
            this.width = data.width || 0;
            this.height = data.height || 0;
            this.frameRate = data.attrs.optionalFloat("FRAME-RATE", 0);
            this._avgBitrate = data.attrs.decimalInteger("AVERAGE-BANDWIDTH");
            this.audioCodec = data.audioCodec;
            this.videoCodec = data.videoCodec;
            this.codecSet = [data.videoCodec, data.audioCodec].filter(function(c) {
              return !!c;
            }).map(function(s) {
              return s.substring(0, 4);
            }).join(",");
            if ("supplemental" in data) {
              var _data$supplemental;
              this.supplemental = data.supplemental;
              var supplementalVideo = (_data$supplemental = data.supplemental) == null ? void 0 : _data$supplemental.videoCodec;
              if (supplementalVideo && supplementalVideo !== data.videoCodec) {
                this.codecSet += "," + supplementalVideo.substring(0, 4);
              }
            }
            this.addGroupId("audio", data.attrs.AUDIO);
            this.addGroupId("text", data.attrs.SUBTITLES);
          }
          var _proto2 = Level2.prototype;
          _proto2.hasAudioGroup = function hasAudioGroup(groupId) {
            return hasGroup(this._audioGroups, groupId);
          };
          _proto2.hasSubtitleGroup = function hasSubtitleGroup(groupId) {
            return hasGroup(this._subtitleGroups, groupId);
          };
          _proto2.addGroupId = function addGroupId(type, groupId) {
            if (!groupId) {
              return;
            }
            if (type === "audio") {
              var audioGroups = this._audioGroups;
              if (!audioGroups) {
                audioGroups = this._audioGroups = [];
              }
              if (audioGroups.indexOf(groupId) === -1) {
                audioGroups.push(groupId);
              }
            } else if (type === "text") {
              var subtitleGroups = this._subtitleGroups;
              if (!subtitleGroups) {
                subtitleGroups = this._subtitleGroups = [];
              }
              if (subtitleGroups.indexOf(groupId) === -1) {
                subtitleGroups.push(groupId);
              }
            }
          };
          _proto2.addFallback = function addFallback() {
          };
          return _createClass4(Level2, [{
            key: "maxBitrate",
            get: function get() {
              return Math.max(this.realBitrate, this.bitrate);
            }
          }, {
            key: "averageBitrate",
            get: function get() {
              return this._avgBitrate || this.realBitrate || this.bitrate;
            }
          }, {
            key: "attrs",
            get: function get() {
              return this._attrs[0];
            }
          }, {
            key: "codecs",
            get: function get() {
              return this.attrs.CODECS || "";
            }
          }, {
            key: "pathwayId",
            get: function get() {
              return this.attrs["PATHWAY-ID"] || ".";
            }
          }, {
            key: "videoRange",
            get: function get() {
              return this.attrs["VIDEO-RANGE"] || "SDR";
            }
          }, {
            key: "score",
            get: function get() {
              return this.attrs.optionalFloat("SCORE", 0);
            }
          }, {
            key: "uri",
            get: function get() {
              return this.url[0] || "";
            }
          }, {
            key: "audioGroups",
            get: function get() {
              return this._audioGroups;
            }
          }, {
            key: "subtitleGroups",
            get: function get() {
              return this._subtitleGroups;
            }
          }, {
            key: "urlId",
            get: function get() {
              return 0;
            },
            set: function set(value) {
            }
          }, {
            key: "audioGroupIds",
            get: function get() {
              return this.audioGroups ? [this.audioGroupId] : void 0;
            }
          }, {
            key: "textGroupIds",
            get: function get() {
              return this.subtitleGroups ? [this.textGroupId] : void 0;
            }
          }, {
            key: "audioGroupId",
            get: function get() {
              var _this$audioGroups;
              return (_this$audioGroups = this.audioGroups) == null ? void 0 : _this$audioGroups[0];
            }
          }, {
            key: "textGroupId",
            get: function get() {
              var _this$subtitleGroups;
              return (_this$subtitleGroups = this.subtitleGroups) == null ? void 0 : _this$subtitleGroups[0];
            }
          }]);
        }();
        function hasGroup(groups, groupId) {
          if (!groupId || !groups) {
            return false;
          }
          return groups.indexOf(groupId) !== -1;
        }
        function isHdrSupported() {
          if (typeof matchMedia === "function") {
            var mediaQueryList = matchMedia("(dynamic-range: high)");
            var badQuery = matchMedia("bad query");
            if (mediaQueryList.media !== badQuery.media) {
              return mediaQueryList.matches === true;
            }
          }
          return false;
        }
        function getVideoSelectionOptions(currentVideoRange, videoPreference) {
          var preferHDR = false;
          var allowedVideoRanges = [];
          if (currentVideoRange) {
            preferHDR = currentVideoRange !== "SDR";
            allowedVideoRanges = [currentVideoRange];
          }
          if (videoPreference) {
            allowedVideoRanges = videoPreference.allowedVideoRanges || VideoRangeValues.slice(0);
            var allowAutoPreferHDR = allowedVideoRanges.join("") !== "SDR" && !videoPreference.videoCodec;
            preferHDR = videoPreference.preferHDR !== void 0 ? videoPreference.preferHDR : allowAutoPreferHDR && isHdrSupported();
            if (!preferHDR) {
              allowedVideoRanges = ["SDR"];
            }
          }
          return {
            preferHDR,
            allowedVideoRanges
          };
        }
        var omitCircularRefsReplacer = function omitCircularRefsReplacer2(replacer) {
          var known = /* @__PURE__ */ new WeakSet();
          return function(_, value) {
            if (replacer) {
              value = replacer(_, value);
            }
            if (typeof value === "object" && value !== null) {
              if (known.has(value)) {
                return;
              }
              known.add(value);
            }
            return value;
          };
        };
        var stringify2 = function stringify3(object, replacer) {
          return JSON.stringify(object, omitCircularRefsReplacer(replacer));
        };
        function getStartCodecTier(codecTiers, currentVideoRange, currentBw, audioPreference, videoPreference) {
          var codecSets = Object.keys(codecTiers);
          var channelsPreference = audioPreference == null ? void 0 : audioPreference.channels;
          var audioCodecPreference = audioPreference == null ? void 0 : audioPreference.audioCodec;
          var videoCodecPreference = videoPreference == null ? void 0 : videoPreference.videoCodec;
          var preferStereo = channelsPreference && parseInt(channelsPreference) === 2;
          var hasStereo = false;
          var hasCurrentVideoRange = false;
          var minHeight = Infinity;
          var minFramerate = Infinity;
          var minBitrate = Infinity;
          var minIndex = Infinity;
          var selectedScore = 0;
          var videoRanges = [];
          var _getVideoSelectionOpt = getVideoSelectionOptions(currentVideoRange, videoPreference), preferHDR = _getVideoSelectionOpt.preferHDR, allowedVideoRanges = _getVideoSelectionOpt.allowedVideoRanges;
          var _loop = function _loop2() {
            var tier = codecTiers[codecSets[i]];
            hasStereo || (hasStereo = tier.channels[2] > 0);
            minHeight = Math.min(minHeight, tier.minHeight);
            minFramerate = Math.min(minFramerate, tier.minFramerate);
            minBitrate = Math.min(minBitrate, tier.minBitrate);
            var matchingVideoRanges = allowedVideoRanges.filter(function(range) {
              return tier.videoRanges[range] > 0;
            });
            if (matchingVideoRanges.length > 0) {
              hasCurrentVideoRange = true;
            }
          };
          for (var i = codecSets.length; i--; ) {
            _loop();
          }
          minHeight = isFiniteNumber(minHeight) ? minHeight : 0;
          minFramerate = isFiniteNumber(minFramerate) ? minFramerate : 0;
          var maxHeight = Math.max(1080, minHeight);
          var maxFramerate = Math.max(30, minFramerate);
          minBitrate = isFiniteNumber(minBitrate) ? minBitrate : currentBw;
          currentBw = Math.max(minBitrate, currentBw);
          if (!hasCurrentVideoRange) {
            currentVideoRange = void 0;
          }
          var hasMultipleSets = codecSets.length > 1;
          var codecSet = codecSets.reduce(function(selected, candidate) {
            var candidateTier = codecTiers[candidate];
            if (candidate === selected) {
              return selected;
            }
            videoRanges = hasCurrentVideoRange ? allowedVideoRanges.filter(function(range) {
              return candidateTier.videoRanges[range] > 0;
            }) : [];
            if (hasMultipleSets) {
              if (candidateTier.minBitrate > currentBw) {
                logStartCodecCandidateIgnored(candidate, "min bitrate of " + candidateTier.minBitrate + " > current estimate of " + currentBw);
                return selected;
              }
              if (!candidateTier.hasDefaultAudio) {
                logStartCodecCandidateIgnored(candidate, "no renditions with default or auto-select sound found");
                return selected;
              }
              if (audioCodecPreference && candidate.indexOf(audioCodecPreference.substring(0, 4)) % 5 !== 0) {
                logStartCodecCandidateIgnored(candidate, 'audio codec preference "' + audioCodecPreference + '" not found');
                return selected;
              }
              if (channelsPreference && !preferStereo) {
                if (!candidateTier.channels[channelsPreference]) {
                  logStartCodecCandidateIgnored(candidate, "no renditions with " + channelsPreference + " channel sound found (channels options: " + Object.keys(candidateTier.channels) + ")");
                  return selected;
                }
              } else if ((!audioCodecPreference || preferStereo) && hasStereo && candidateTier.channels["2"] === 0) {
                logStartCodecCandidateIgnored(candidate, "no renditions with stereo sound found");
                return selected;
              }
              if (candidateTier.minHeight > maxHeight) {
                logStartCodecCandidateIgnored(candidate, "min resolution of " + candidateTier.minHeight + " > maximum of " + maxHeight);
                return selected;
              }
              if (candidateTier.minFramerate > maxFramerate) {
                logStartCodecCandidateIgnored(candidate, "min framerate of " + candidateTier.minFramerate + " > maximum of " + maxFramerate);
                return selected;
              }
              if (!videoRanges.some(function(range) {
                return candidateTier.videoRanges[range] > 0;
              })) {
                logStartCodecCandidateIgnored(candidate, "no variants with VIDEO-RANGE of " + stringify2(videoRanges) + " found");
                return selected;
              }
              if (videoCodecPreference && candidate.indexOf(videoCodecPreference.substring(0, 4)) % 5 !== 0) {
                logStartCodecCandidateIgnored(candidate, 'video codec preference "' + videoCodecPreference + '" not found');
                return selected;
              }
              if (candidateTier.maxScore < selectedScore) {
                logStartCodecCandidateIgnored(candidate, "max score of " + candidateTier.maxScore + " < selected max of " + selectedScore);
                return selected;
              }
            }
            if (selected && (codecsSetSelectionPreferenceValue(candidate) >= codecsSetSelectionPreferenceValue(selected) || candidateTier.fragmentError > codecTiers[selected].fragmentError)) {
              return selected;
            }
            minIndex = candidateTier.minIndex;
            selectedScore = candidateTier.maxScore;
            return candidate;
          }, void 0);
          return {
            codecSet,
            videoRanges,
            preferHDR,
            minFramerate,
            minBitrate,
            minIndex
          };
        }
        function logStartCodecCandidateIgnored(codeSet, reason) {
          logger4.log('[abr] start candidates with "' + codeSet + '" ignored because ' + reason);
        }
        function getAudioTracksByGroup(allAudioTracks) {
          return allAudioTracks.reduce(function(audioTracksByGroup, track) {
            var trackGroup = audioTracksByGroup.groups[track.groupId];
            if (!trackGroup) {
              trackGroup = audioTracksByGroup.groups[track.groupId] = {
                tracks: [],
                channels: {
                  2: 0
                },
                hasDefault: false,
                hasAutoSelect: false
              };
            }
            trackGroup.tracks.push(track);
            var channelsKey = track.channels || "2";
            trackGroup.channels[channelsKey] = (trackGroup.channels[channelsKey] || 0) + 1;
            trackGroup.hasDefault = trackGroup.hasDefault || track.default;
            trackGroup.hasAutoSelect = trackGroup.hasAutoSelect || track.autoselect;
            if (trackGroup.hasDefault) {
              audioTracksByGroup.hasDefaultAudio = true;
            }
            if (trackGroup.hasAutoSelect) {
              audioTracksByGroup.hasAutoSelectAudio = true;
            }
            return audioTracksByGroup;
          }, {
            hasDefaultAudio: false,
            hasAutoSelectAudio: false,
            groups: {}
          });
        }
        function getCodecTiers(levels, audioTracksByGroup, minAutoLevel, maxAutoLevel) {
          return levels.slice(minAutoLevel, maxAutoLevel + 1).reduce(function(tiers, level, index) {
            if (!level.codecSet) {
              return tiers;
            }
            var audioGroups = level.audioGroups;
            var tier = tiers[level.codecSet];
            if (!tier) {
              tiers[level.codecSet] = tier = {
                minBitrate: Infinity,
                minHeight: Infinity,
                minFramerate: Infinity,
                minIndex: index,
                maxScore: 0,
                videoRanges: {
                  SDR: 0
                },
                channels: {
                  "2": 0
                },
                hasDefaultAudio: !audioGroups,
                fragmentError: 0
              };
            }
            tier.minBitrate = Math.min(tier.minBitrate, level.bitrate);
            var lesserWidthOrHeight = Math.min(level.height, level.width);
            tier.minHeight = Math.min(tier.minHeight, lesserWidthOrHeight);
            tier.minFramerate = Math.min(tier.minFramerate, level.frameRate);
            tier.minIndex = Math.min(tier.minIndex, index);
            tier.maxScore = Math.max(tier.maxScore, level.score);
            tier.fragmentError += level.fragmentError;
            tier.videoRanges[level.videoRange] = (tier.videoRanges[level.videoRange] || 0) + 1;
            return tiers;
          }, {});
        }
        function useAlternateAudio(audioTrackUrl, hls) {
          var _hls$loadLevelObj;
          return !!audioTrackUrl && audioTrackUrl !== ((_hls$loadLevelObj = hls.loadLevelObj) == null ? void 0 : _hls$loadLevelObj.uri);
        }
        var AbrController = /* @__PURE__ */ function(_Logger) {
          function AbrController2(_hls) {
            var _this;
            _this = _Logger.call(this, "abr", _hls.logger) || this;
            _this.hls = void 0;
            _this.lastLevelLoadSec = 0;
            _this.lastLoadedFragLevel = -1;
            _this.firstSelection = -1;
            _this._nextAutoLevel = -1;
            _this.nextAutoLevelKey = "";
            _this.audioTracksByGroup = null;
            _this.codecTiers = null;
            _this.timer = -1;
            _this.fragCurrent = null;
            _this.partCurrent = null;
            _this.bitrateTestDelay = 0;
            _this.rebufferNotice = -1;
            _this.bwEstimator = void 0;
            _this._abandonRulesCheck = function(levelLoaded) {
              var _ref;
              var _this2 = _this, frag = _this2.fragCurrent, part = _this2.partCurrent, hls = _this2.hls;
              var autoLevelEnabled = hls.autoLevelEnabled, media = hls.media;
              if (!frag || !media) {
                return;
              }
              var now2 = performance.now();
              var stats = part ? part.stats : frag.stats;
              var duration = part ? part.duration : frag.duration;
              var timeLoading = now2 - stats.loading.start;
              var minAutoLevel = hls.minAutoLevel;
              var loadingFragForLevel = frag.level;
              var currentAutoLevel = _this._nextAutoLevel;
              if (stats.aborted || stats.loaded && stats.loaded === stats.total || loadingFragForLevel <= minAutoLevel) {
                _this.clearTimer();
                _this._nextAutoLevel = -1;
                return;
              }
              if (!autoLevelEnabled) {
                return;
              }
              var fragBlockingSwitch = currentAutoLevel > -1 && currentAutoLevel !== loadingFragForLevel;
              var levelChange = !!levelLoaded || fragBlockingSwitch;
              if (!levelChange && (media.paused || !media.playbackRate || !media.readyState)) {
                return;
              }
              var bufferInfo = hls.mainForwardBufferInfo;
              if (!levelChange && bufferInfo === null) {
                return;
              }
              var ttfbEstimate = _this.bwEstimator.getEstimateTTFB();
              var playbackRate = Math.abs(media.playbackRate);
              if (timeLoading <= Math.max(ttfbEstimate, 1e3 * (duration / (playbackRate * 2)))) {
                return;
              }
              var bufferStarvationDelay = bufferInfo ? bufferInfo.len / playbackRate : 0;
              var ttfb = stats.loading.first ? stats.loading.first - stats.loading.start : -1;
              var loadedFirstByte = stats.loaded && ttfb > -1;
              var bwEstimate = _this.getBwEstimate();
              var levels = hls.levels;
              var level = levels[loadingFragForLevel];
              var expectedLen = Math.max(stats.loaded, Math.round(duration * (frag.bitrate || level.averageBitrate) / 8));
              var timeStreaming = loadedFirstByte ? timeLoading - ttfb : timeLoading;
              if (timeStreaming < 1 && loadedFirstByte) {
                timeStreaming = Math.min(timeLoading, stats.loaded * 8 / bwEstimate);
              }
              var loadRate = loadedFirstByte ? stats.loaded * 1e3 / timeStreaming : 0;
              var ttfbSeconds = ttfbEstimate / 1e3;
              var fragLoadedDelay = loadRate ? (expectedLen - stats.loaded) / loadRate : expectedLen * 8 / bwEstimate + ttfbSeconds;
              if (fragLoadedDelay <= bufferStarvationDelay) {
                return;
              }
              var bwe = loadRate ? loadRate * 8 : bwEstimate;
              var live = ((_ref = (levelLoaded == null ? void 0 : levelLoaded.details) || _this.hls.latestLevelDetails) == null ? void 0 : _ref.live) === true;
              var abrBandWidthUpFactor = _this.hls.config.abrBandWidthUpFactor;
              var fragLevelNextLoadedDelay = Number.POSITIVE_INFINITY;
              var nextLoadLevel;
              for (nextLoadLevel = loadingFragForLevel - 1; nextLoadLevel > minAutoLevel; nextLoadLevel--) {
                var levelNextBitrate = levels[nextLoadLevel].maxBitrate;
                var requiresLevelLoad = !levels[nextLoadLevel].details || live;
                fragLevelNextLoadedDelay = _this.getTimeToLoadFrag(ttfbSeconds, bwe, duration * levelNextBitrate, requiresLevelLoad);
                if (fragLevelNextLoadedDelay < Math.min(bufferStarvationDelay, duration + ttfbSeconds)) {
                  break;
                }
              }
              if (fragLevelNextLoadedDelay >= fragLoadedDelay) {
                return;
              }
              if (fragLevelNextLoadedDelay > duration * 10) {
                return;
              }
              if (loadedFirstByte) {
                _this.bwEstimator.sample(timeLoading - Math.min(ttfbEstimate, ttfb), stats.loaded);
              } else {
                _this.bwEstimator.sampleTTFB(timeLoading);
              }
              var nextLoadLevelBitrate = levels[nextLoadLevel].maxBitrate;
              if (_this.getBwEstimate() * abrBandWidthUpFactor > nextLoadLevelBitrate) {
                _this.resetEstimator(nextLoadLevelBitrate);
              }
              var bestSwitchLevel = _this.findBestLevel(nextLoadLevelBitrate, minAutoLevel, nextLoadLevel, 0, bufferStarvationDelay, 1, 1);
              if (bestSwitchLevel > -1) {
                nextLoadLevel = bestSwitchLevel;
              }
              _this.warn("Fragment " + frag.sn + (part ? " part " + part.index : "") + " of level " + loadingFragForLevel + " is loading too slowly;\n      Fragment duration: " + frag.duration.toFixed(3) + "\n      Time to underbuffer: " + bufferStarvationDelay.toFixed(3) + " s\n      Estimated load time for current fragment: " + fragLoadedDelay.toFixed(3) + " s\n      Estimated load time for down switch fragment: " + fragLevelNextLoadedDelay.toFixed(3) + " s\n      TTFB estimate: " + (ttfb | 0) + " ms\n      Current BW estimate: " + (isFiniteNumber(bwEstimate) ? bwEstimate | 0 : "Unknown") + " bps\n      New BW estimate: " + (_this.getBwEstimate() | 0) + " bps\n      Switching to level " + nextLoadLevel + " @ " + (nextLoadLevelBitrate | 0) + " bps");
              hls.nextLoadLevel = hls.nextAutoLevel = nextLoadLevel;
              _this.clearTimer();
              var abortAndSwitch = function abortAndSwitch2() {
                _this.clearTimer();
                if (_this.fragCurrent === frag && _this.hls.loadLevel === nextLoadLevel && nextLoadLevel > 0) {
                  var _bufferStarvationDelay = _this.getStarvationDelay();
                  _this.warn("Aborting inflight request " + (nextLoadLevel > 0 ? "and switching down" : "") + "\n      Fragment duration: " + frag.duration.toFixed(3) + " s\n      Time to underbuffer: " + _bufferStarvationDelay.toFixed(3) + " s");
                  frag.abortRequests();
                  _this.fragCurrent = _this.partCurrent = null;
                  if (nextLoadLevel > minAutoLevel) {
                    var lowestSwitchLevel = _this.findBestLevel(_this.hls.levels[minAutoLevel].bitrate, minAutoLevel, nextLoadLevel, 0, _bufferStarvationDelay, 1, 1);
                    if (lowestSwitchLevel === -1) {
                      lowestSwitchLevel = minAutoLevel;
                    }
                    _this.hls.nextLoadLevel = _this.hls.nextAutoLevel = lowestSwitchLevel;
                    _this.resetEstimator(_this.hls.levels[lowestSwitchLevel].bitrate);
                  }
                }
              };
              if (fragBlockingSwitch || fragLoadedDelay > fragLevelNextLoadedDelay * 2) {
                abortAndSwitch();
              } else {
                _this.timer = self.setInterval(abortAndSwitch, fragLevelNextLoadedDelay * 1e3);
              }
              hls.trigger(Events.FRAG_LOAD_EMERGENCY_ABORTED, {
                frag,
                part,
                stats
              });
            };
            _this.hls = _hls;
            _this.bwEstimator = _this.initEstimator();
            _this.registerListeners();
            return _this;
          }
          _inheritsLoose(AbrController2, _Logger);
          var _proto = AbrController2.prototype;
          _proto.resetEstimator = function resetEstimator(abrEwmaDefaultEstimate) {
            if (abrEwmaDefaultEstimate) {
              this.log("setting initial bwe to " + abrEwmaDefaultEstimate);
              this.hls.config.abrEwmaDefaultEstimate = abrEwmaDefaultEstimate;
            }
            this.firstSelection = -1;
            this.bwEstimator = this.initEstimator();
          };
          _proto.initEstimator = function initEstimator() {
            var config = this.hls.config;
            return new EwmaBandWidthEstimator(config.abrEwmaSlowVoD, config.abrEwmaFastVoD, config.abrEwmaDefaultEstimate);
          };
          _proto.registerListeners = function registerListeners() {
            var hls = this.hls;
            hls.on(Events.MANIFEST_LOADING, this.onManifestLoading, this);
            hls.on(Events.FRAG_LOADING, this.onFragLoading, this);
            hls.on(Events.FRAG_LOADED, this.onFragLoaded, this);
            hls.on(Events.FRAG_BUFFERED, this.onFragBuffered, this);
            hls.on(Events.LEVEL_SWITCHING, this.onLevelSwitching, this);
            hls.on(Events.LEVEL_LOADED, this.onLevelLoaded, this);
            hls.on(Events.LEVELS_UPDATED, this.onLevelsUpdated, this);
            hls.on(Events.MAX_AUTO_LEVEL_UPDATED, this.onMaxAutoLevelUpdated, this);
            hls.on(Events.ERROR, this.onError, this);
          };
          _proto.unregisterListeners = function unregisterListeners() {
            var hls = this.hls;
            if (!hls) {
              return;
            }
            hls.off(Events.MANIFEST_LOADING, this.onManifestLoading, this);
            hls.off(Events.FRAG_LOADING, this.onFragLoading, this);
            hls.off(Events.FRAG_LOADED, this.onFragLoaded, this);
            hls.off(Events.FRAG_BUFFERED, this.onFragBuffered, this);
            hls.off(Events.LEVEL_SWITCHING, this.onLevelSwitching, this);
            hls.off(Events.LEVEL_LOADED, this.onLevelLoaded, this);
            hls.off(Events.LEVELS_UPDATED, this.onLevelsUpdated, this);
            hls.off(Events.MAX_AUTO_LEVEL_UPDATED, this.onMaxAutoLevelUpdated, this);
            hls.off(Events.ERROR, this.onError, this);
          };
          _proto.destroy = function destroy() {
            this.unregisterListeners();
            this.clearTimer();
            this.hls = this._abandonRulesCheck = null;
            this.fragCurrent = this.partCurrent = null;
          };
          _proto.onManifestLoading = function onManifestLoading(event, data) {
            this.lastLoadedFragLevel = -1;
            this.firstSelection = -1;
            this.lastLevelLoadSec = 0;
            this.fragCurrent = this.partCurrent = null;
            this.onLevelsUpdated();
            this.clearTimer();
          };
          _proto.onLevelsUpdated = function onLevelsUpdated() {
            if (this.lastLoadedFragLevel > -1 && this.fragCurrent) {
              this.lastLoadedFragLevel = this.fragCurrent.level;
            }
            this._nextAutoLevel = -1;
            this.onMaxAutoLevelUpdated();
            this.codecTiers = null;
            this.audioTracksByGroup = null;
          };
          _proto.onMaxAutoLevelUpdated = function onMaxAutoLevelUpdated() {
            this.firstSelection = -1;
            this.nextAutoLevelKey = "";
          };
          _proto.onFragLoading = function onFragLoading(event, data) {
            var frag = data.frag;
            if (this.ignoreFragment(frag)) {
              return;
            }
            if (!frag.bitrateTest) {
              var _data$part;
              this.fragCurrent = frag;
              this.partCurrent = (_data$part = data.part) != null ? _data$part : null;
            }
            this.clearTimer();
            this.timer = self.setInterval(this._abandonRulesCheck, 100);
          };
          _proto.onLevelSwitching = function onLevelSwitching(event, data) {
            this.clearTimer();
          };
          _proto.onError = function onError(event, data) {
            if (data.fatal) {
              return;
            }
            switch (data.details) {
              case ErrorDetails.BUFFER_ADD_CODEC_ERROR:
              case ErrorDetails.BUFFER_APPEND_ERROR:
                this.lastLoadedFragLevel = -1;
                this.firstSelection = -1;
                break;
              case ErrorDetails.FRAG_LOAD_TIMEOUT: {
                var frag = data.frag;
                var fragCurrent = this.fragCurrent, part = this.partCurrent;
                if (frag && fragCurrent && frag.sn === fragCurrent.sn && frag.level === fragCurrent.level) {
                  var now2 = performance.now();
                  var stats = part ? part.stats : frag.stats;
                  var timeLoading = now2 - stats.loading.start;
                  var ttfb = stats.loading.first ? stats.loading.first - stats.loading.start : -1;
                  var loadedFirstByte = stats.loaded && ttfb > -1;
                  if (loadedFirstByte) {
                    var ttfbEstimate = this.bwEstimator.getEstimateTTFB();
                    this.bwEstimator.sample(timeLoading - Math.min(ttfbEstimate, ttfb), stats.loaded);
                  } else {
                    this.bwEstimator.sampleTTFB(timeLoading);
                  }
                }
                break;
              }
            }
          };
          _proto.getTimeToLoadFrag = function getTimeToLoadFrag(timeToFirstByteSec, bandwidth, fragSizeBits, isSwitch) {
            var fragLoadSec = timeToFirstByteSec + fragSizeBits / bandwidth;
            var playlistLoadSec = isSwitch ? timeToFirstByteSec + this.lastLevelLoadSec : 0;
            return fragLoadSec + playlistLoadSec;
          };
          _proto.onLevelLoaded = function onLevelLoaded(event, data) {
            var config = this.hls.config;
            var loading = data.stats.loading;
            var timeLoadingMs = loading.end - loading.first;
            if (isFiniteNumber(timeLoadingMs)) {
              this.lastLevelLoadSec = timeLoadingMs / 1e3;
            }
            if (data.details.live) {
              this.bwEstimator.update(config.abrEwmaSlowLive, config.abrEwmaFastLive);
            } else {
              this.bwEstimator.update(config.abrEwmaSlowVoD, config.abrEwmaFastVoD);
            }
            if (this.timer > -1) {
              this._abandonRulesCheck(data.levelInfo);
            }
          };
          _proto.onFragLoaded = function onFragLoaded(event, _ref2) {
            var frag = _ref2.frag, part = _ref2.part;
            var stats = part ? part.stats : frag.stats;
            if (frag.type === PlaylistLevelType.MAIN) {
              this.bwEstimator.sampleTTFB(stats.loading.first - stats.loading.start);
            }
            if (this.ignoreFragment(frag)) {
              return;
            }
            this.clearTimer();
            if (frag.level === this._nextAutoLevel) {
              this._nextAutoLevel = -1;
            }
            this.firstSelection = -1;
            if (this.hls.config.abrMaxWithRealBitrate) {
              var duration = part ? part.duration : frag.duration;
              var level = this.hls.levels[frag.level];
              var loadedBytes = (level.loaded ? level.loaded.bytes : 0) + stats.loaded;
              var loadedDuration = (level.loaded ? level.loaded.duration : 0) + duration;
              level.loaded = {
                bytes: loadedBytes,
                duration: loadedDuration
              };
              level.realBitrate = Math.round(8 * loadedBytes / loadedDuration);
            }
            if (frag.bitrateTest) {
              var fragBufferedData = {
                stats,
                frag,
                part,
                id: frag.type
              };
              this.onFragBuffered(Events.FRAG_BUFFERED, fragBufferedData);
              frag.bitrateTest = false;
            } else {
              this.lastLoadedFragLevel = frag.level;
            }
          };
          _proto.onFragBuffered = function onFragBuffered(event, data) {
            var frag = data.frag, part = data.part;
            var stats = part != null && part.stats.loaded ? part.stats : frag.stats;
            if (stats.aborted) {
              return;
            }
            if (this.ignoreFragment(frag)) {
              return;
            }
            var processingMs = stats.parsing.end - stats.loading.start - Math.min(stats.loading.first - stats.loading.start, this.bwEstimator.getEstimateTTFB());
            this.bwEstimator.sample(processingMs, stats.loaded);
            stats.bwEstimate = this.getBwEstimate();
            if (frag.bitrateTest) {
              this.bitrateTestDelay = processingMs / 1e3;
            } else {
              this.bitrateTestDelay = 0;
            }
          };
          _proto.ignoreFragment = function ignoreFragment(frag) {
            return frag.type !== PlaylistLevelType.MAIN || frag.sn === "initSegment";
          };
          _proto.clearTimer = function clearTimer() {
            if (this.timer > -1) {
              self.clearInterval(this.timer);
              this.timer = -1;
            }
          };
          _proto.getAutoLevelKey = function getAutoLevelKey() {
            return this.getBwEstimate() + "_" + this.getStarvationDelay().toFixed(2);
          };
          _proto.getNextABRAutoLevel = function getNextABRAutoLevel() {
            var fragCurrent = this.fragCurrent, partCurrent = this.partCurrent, hls = this.hls;
            if (hls.levels.length <= 1) {
              return hls.loadLevel;
            }
            var maxAutoLevel = hls.maxAutoLevel, config = hls.config, minAutoLevel = hls.minAutoLevel;
            var currentFragDuration = partCurrent ? partCurrent.duration : fragCurrent ? fragCurrent.duration : 0;
            var avgbw = this.getBwEstimate();
            var bufferStarvationDelay = this.getStarvationDelay();
            var bwFactor = config.abrBandWidthFactor;
            var bwUpFactor = config.abrBandWidthUpFactor;
            if (bufferStarvationDelay) {
              var _bestLevel = this.findBestLevel(avgbw, minAutoLevel, maxAutoLevel, bufferStarvationDelay, 0, bwFactor, bwUpFactor);
              if (_bestLevel >= 0) {
                this.rebufferNotice = -1;
                return _bestLevel;
              }
            }
            var maxStarvationDelay = currentFragDuration ? Math.min(currentFragDuration, config.maxStarvationDelay) : config.maxStarvationDelay;
            if (!bufferStarvationDelay) {
              var bitrateTestDelay = this.bitrateTestDelay;
              if (bitrateTestDelay) {
                var maxLoadingDelay = currentFragDuration ? Math.min(currentFragDuration, config.maxLoadingDelay) : config.maxLoadingDelay;
                maxStarvationDelay = maxLoadingDelay - bitrateTestDelay;
                this.info("bitrate test took " + Math.round(1e3 * bitrateTestDelay) + "ms, set first fragment max fetchDuration to " + Math.round(1e3 * maxStarvationDelay) + " ms");
                bwFactor = bwUpFactor = 1;
              }
            }
            var bestLevel = this.findBestLevel(avgbw, minAutoLevel, maxAutoLevel, bufferStarvationDelay, maxStarvationDelay, bwFactor, bwUpFactor);
            if (this.rebufferNotice !== bestLevel) {
              this.rebufferNotice = bestLevel;
              this.info((bufferStarvationDelay ? "rebuffering expected" : "buffer is empty") + ", optimal quality level " + bestLevel);
            }
            if (bestLevel > -1) {
              return bestLevel;
            }
            var minLevel = hls.levels[minAutoLevel];
            var autoLevel = hls.loadLevelObj;
            if (autoLevel && (minLevel == null ? void 0 : minLevel.bitrate) < autoLevel.bitrate) {
              return minAutoLevel;
            }
            return hls.loadLevel;
          };
          _proto.getStarvationDelay = function getStarvationDelay() {
            var hls = this.hls;
            var media = hls.media;
            if (!media) {
              return Infinity;
            }
            var playbackRate = media && media.playbackRate !== 0 ? Math.abs(media.playbackRate) : 1;
            var bufferInfo = hls.mainForwardBufferInfo;
            return (bufferInfo ? bufferInfo.len : 0) / playbackRate;
          };
          _proto.getBwEstimate = function getBwEstimate() {
            return this.bwEstimator.canEstimate() ? this.bwEstimator.getEstimate() : this.hls.config.abrEwmaDefaultEstimate;
          };
          _proto.findBestLevel = function findBestLevel(currentBw, minAutoLevel, maxAutoLevel, bufferStarvationDelay, maxStarvationDelay, bwFactor, bwUpFactor) {
            var _this$hls$latestLevel, _this3 = this;
            var maxFetchDuration = bufferStarvationDelay + maxStarvationDelay;
            var lastLoadedFragLevel = this.lastLoadedFragLevel;
            var selectionBaseLevel = lastLoadedFragLevel === -1 ? this.hls.firstLevel : lastLoadedFragLevel;
            var fragCurrent = this.fragCurrent, partCurrent = this.partCurrent;
            var _this$hls = this.hls, levels = _this$hls.levels, allAudioTracks = _this$hls.allAudioTracks, loadLevel = _this$hls.loadLevel, config = _this$hls.config;
            if (levels.length === 1) {
              return 0;
            }
            var level = levels[selectionBaseLevel];
            var live = !!((_this$hls$latestLevel = this.hls.latestLevelDetails) != null && _this$hls$latestLevel.live);
            var firstSelection = loadLevel === -1 || lastLoadedFragLevel === -1;
            var currentCodecSet;
            var currentVideoRange = "SDR";
            var currentFrameRate = (level == null ? void 0 : level.frameRate) || 0;
            var audioPreference = config.audioPreference, videoPreference = config.videoPreference;
            var audioTracksByGroup = this.audioTracksByGroup || (this.audioTracksByGroup = getAudioTracksByGroup(allAudioTracks));
            var minStartIndex = -1;
            if (firstSelection) {
              if (this.firstSelection !== -1) {
                return this.firstSelection;
              }
              var codecTiers = this.codecTiers || (this.codecTiers = getCodecTiers(levels, audioTracksByGroup, minAutoLevel, maxAutoLevel));
              var startTier = getStartCodecTier(codecTiers, currentVideoRange, currentBw, audioPreference, videoPreference);
              var codecSet = startTier.codecSet, videoRanges = startTier.videoRanges, minFramerate = startTier.minFramerate, minBitrate = startTier.minBitrate, minIndex = startTier.minIndex, preferHDR = startTier.preferHDR;
              minStartIndex = minIndex;
              currentCodecSet = codecSet;
              currentVideoRange = preferHDR ? videoRanges[videoRanges.length - 1] : videoRanges[0];
              currentFrameRate = minFramerate;
              currentBw = Math.max(currentBw, minBitrate);
              this.log("picked start tier " + stringify2(startTier));
            } else {
              currentCodecSet = level == null ? void 0 : level.codecSet;
              currentVideoRange = level == null ? void 0 : level.videoRange;
            }
            var currentFragDuration = partCurrent ? partCurrent.duration : fragCurrent ? fragCurrent.duration : 0;
            var ttfbEstimateSec = this.bwEstimator.getEstimateTTFB() / 1e3;
            var levelsSkipped = [];
            var _loop = function _loop2() {
              var _levelInfo$supportedR;
              var levelInfo = levels[i];
              var upSwitch = i > selectionBaseLevel;
              if (!levelInfo) {
                return 0;
              }
              if (currentCodecSet && levelInfo.codecSet !== currentCodecSet || currentVideoRange && levelInfo.videoRange !== currentVideoRange || upSwitch && currentFrameRate > levelInfo.frameRate || !upSwitch && currentFrameRate > 0 && currentFrameRate < levelInfo.frameRate || levelInfo.supportedResult && !((_levelInfo$supportedR = levelInfo.supportedResult.decodingInfoResults) != null && _levelInfo$supportedR[0].smooth)) {
                if (!firstSelection || i !== minStartIndex) {
                  levelsSkipped.push(i);
                  return 0;
                }
              }
              var levelDetails = levelInfo.details;
              var avgDuration = (partCurrent ? levelDetails == null ? void 0 : levelDetails.partTarget : levelDetails == null ? void 0 : levelDetails.averagetargetduration) || currentFragDuration;
              var adjustedbw;
              if (!upSwitch) {
                adjustedbw = bwFactor * currentBw;
              } else {
                adjustedbw = bwUpFactor * currentBw;
              }
              var bitrate = currentFragDuration && bufferStarvationDelay >= currentFragDuration * 2 && maxStarvationDelay === 0 ? levelInfo.averageBitrate : levelInfo.maxBitrate;
              var fetchDuration = _this3.getTimeToLoadFrag(ttfbEstimateSec, adjustedbw, bitrate * avgDuration, levelDetails === void 0);
              var canSwitchWithinTolerance = (
                // if adjusted bw is greater than level bitrate AND
                adjustedbw >= bitrate && // no level change, or new level has no error history
                (i === lastLoadedFragLevel || levelInfo.loadError === 0 && levelInfo.fragmentError === 0) && // fragment fetchDuration unknown OR live stream OR fragment fetchDuration less than max allowed fetch duration, then this level matches
                // we don't account for max Fetch Duration for live streams, this is to avoid switching down when near the edge of live sliding window ...
                // special case to support startLevel = -1 (bitrateTest) on live streams : in that case we should not exit loop so that findBestLevel will return -1
                (fetchDuration <= ttfbEstimateSec || !isFiniteNumber(fetchDuration) || live && !_this3.bitrateTestDelay || fetchDuration < maxFetchDuration)
              );
              if (canSwitchWithinTolerance) {
                var forcedAutoLevel = _this3.forcedAutoLevel;
                if (i !== loadLevel && (forcedAutoLevel === -1 || forcedAutoLevel !== loadLevel)) {
                  if (levelsSkipped.length) {
                    _this3.trace("Skipped level(s) " + levelsSkipped.join(",") + " of " + maxAutoLevel + ' max with CODECS and VIDEO-RANGE:"' + levels[levelsSkipped[0]].codecs + '" ' + levels[levelsSkipped[0]].videoRange + '; not compatible with "' + currentCodecSet + '" ' + currentVideoRange);
                  }
                  _this3.info("switch candidate:" + selectionBaseLevel + "->" + i + " adjustedbw(" + Math.round(adjustedbw) + ")-bitrate=" + Math.round(adjustedbw - bitrate) + " ttfb:" + ttfbEstimateSec.toFixed(1) + " avgDuration:" + avgDuration.toFixed(1) + " maxFetchDuration:" + maxFetchDuration.toFixed(1) + " fetchDuration:" + fetchDuration.toFixed(1) + " firstSelection:" + firstSelection + " codecSet:" + levelInfo.codecSet + " videoRange:" + levelInfo.videoRange + " hls.loadLevel:" + loadLevel);
                }
                if (firstSelection) {
                  _this3.firstSelection = i;
                }
                return {
                  v: i
                };
              }
            }, _ret;
            for (var i = maxAutoLevel; i >= minAutoLevel; i--) {
              _ret = _loop();
              if (_ret === 0) continue;
              if (_ret) return _ret.v;
            }
            return -1;
          };
          _proto.deriveNextAutoLevel = function deriveNextAutoLevel(nextLevel) {
            var _this$hls2 = this.hls, maxAutoLevel = _this$hls2.maxAutoLevel, minAutoLevel = _this$hls2.minAutoLevel;
            return Math.min(Math.max(nextLevel, minAutoLevel), maxAutoLevel);
          };
          return _createClass4(AbrController2, [{
            key: "firstAutoLevel",
            get: function get() {
              var _this$hls3 = this.hls, maxAutoLevel = _this$hls3.maxAutoLevel, minAutoLevel = _this$hls3.minAutoLevel;
              var bwEstimate = this.getBwEstimate();
              var maxStartDelay = this.hls.config.maxStarvationDelay;
              var abrAutoLevel = this.findBestLevel(bwEstimate, minAutoLevel, maxAutoLevel, 0, maxStartDelay, 1, 1);
              if (abrAutoLevel > -1) {
                return abrAutoLevel;
              }
              var firstLevel = this.hls.firstLevel;
              var clamped = Math.min(Math.max(firstLevel, minAutoLevel), maxAutoLevel);
              this.warn("Could not find best starting auto level. Defaulting to first in playlist " + firstLevel + " clamped to " + clamped);
              return clamped;
            }
          }, {
            key: "forcedAutoLevel",
            get: function get() {
              if (this.nextAutoLevelKey) {
                return -1;
              }
              return this._nextAutoLevel;
            }
            // return next auto level
          }, {
            key: "nextAutoLevel",
            get: function get() {
              var forcedAutoLevel = this.forcedAutoLevel;
              var bwEstimator = this.bwEstimator;
              var useEstimate = bwEstimator.canEstimate();
              var loadedFirstFrag = this.lastLoadedFragLevel > -1;
              if (forcedAutoLevel !== -1 && (!useEstimate || !loadedFirstFrag || this.nextAutoLevelKey === this.getAutoLevelKey())) {
                return forcedAutoLevel;
              }
              var nextABRAutoLevel = useEstimate && loadedFirstFrag ? this.getNextABRAutoLevel() : this.firstAutoLevel;
              if (forcedAutoLevel !== -1) {
                var levels = this.hls.levels;
                if (levels.length > Math.max(forcedAutoLevel, nextABRAutoLevel) && levels[forcedAutoLevel].loadError <= levels[nextABRAutoLevel].loadError) {
                  return forcedAutoLevel;
                }
              }
              this._nextAutoLevel = nextABRAutoLevel;
              this.nextAutoLevelKey = this.getAutoLevelKey();
              return nextABRAutoLevel;
            },
            set: function set(nextLevel) {
              var value = this.deriveNextAutoLevel(nextLevel);
              if (this._nextAutoLevel !== value) {
                this.nextAutoLevelKey = "";
                this._nextAutoLevel = value;
              }
            }
          }]);
        }(Logger4);
        var BufferOperationQueue = /* @__PURE__ */ function() {
          function BufferOperationQueue2(sourceBufferReference) {
            this.tracks = void 0;
            this.queues = {
              video: [],
              audio: [],
              audiovideo: []
            };
            this.tracks = sourceBufferReference;
          }
          var _proto = BufferOperationQueue2.prototype;
          _proto.destroy = function destroy() {
            this.tracks = this.queues = null;
          };
          _proto.append = function append(operation, type, pending) {
            if (this.queues === null || this.tracks === null) {
              return;
            }
            var queue = this.queues[type];
            queue.push(operation);
            if (queue.length === 1 && !pending) {
              this.executeNext(type);
            }
          };
          _proto.appendBlocker = function appendBlocker(type) {
            var _this = this;
            return new Promise(function(resolve) {
              var operation = {
                label: "async-blocker",
                execute: resolve,
                onStart: function onStart() {
                },
                onComplete: function onComplete() {
                },
                onError: function onError() {
                }
              };
              _this.append(operation, type);
            });
          };
          _proto.prependBlocker = function prependBlocker(type) {
            var _this2 = this;
            return new Promise(function(resolve) {
              if (_this2.queues) {
                var operation = {
                  label: "async-blocker-prepend",
                  execute: resolve,
                  onStart: function onStart() {
                  },
                  onComplete: function onComplete() {
                  },
                  onError: function onError() {
                  }
                };
                _this2.queues[type].unshift(operation);
              }
            });
          };
          _proto.removeBlockers = function removeBlockers() {
            if (this.queues === null) {
              return;
            }
            [this.queues.video, this.queues.audio, this.queues.audiovideo].forEach(function(queue) {
              var _queue$;
              var label = (_queue$ = queue[0]) == null ? void 0 : _queue$.label;
              if (label === "async-blocker" || label === "async-blocker-prepend") {
                queue[0].execute();
                queue.splice(0, 1);
              }
            });
          };
          _proto.unblockAudio = function unblockAudio(op) {
            if (this.queues === null) {
              return;
            }
            var queue = this.queues.audio;
            if (queue[0] === op) {
              this.shiftAndExecuteNext("audio");
            }
          };
          _proto.executeNext = function executeNext(type) {
            if (this.queues === null || this.tracks === null) {
              return;
            }
            var queue = this.queues[type];
            if (queue.length) {
              var operation = queue[0];
              try {
                operation.execute();
              } catch (error) {
                var _this$tracks$type;
                operation.onError(error);
                if (this.queues === null || this.tracks === null) {
                  return;
                }
                var sb = (_this$tracks$type = this.tracks[type]) == null ? void 0 : _this$tracks$type.buffer;
                if (!(sb != null && sb.updating)) {
                  this.shiftAndExecuteNext(type);
                }
              }
            }
          };
          _proto.shiftAndExecuteNext = function shiftAndExecuteNext(type) {
            if (this.queues === null) {
              return;
            }
            this.queues[type].shift();
            this.executeNext(type);
          };
          _proto.current = function current(type) {
            var _this$queues;
            return ((_this$queues = this.queues) == null ? void 0 : _this$queues[type][0]) || null;
          };
          _proto.toString = function toString2() {
            var queues = this.queues, tracks = this.tracks;
            if (queues === null || tracks === null) {
              return "<destroyed>";
            }
            return "\n" + this.list("video") + "\n" + this.list("audio") + "\n" + this.list("audiovideo") + "}";
          };
          _proto.list = function list(type) {
            var _this$queues2, _this$tracks;
            return (_this$queues2 = this.queues) != null && _this$queues2[type] || (_this$tracks = this.tracks) != null && _this$tracks[type] ? type + ": (" + this.listSbInfo(type) + ") " + this.listOps(type) : "";
          };
          _proto.listSbInfo = function listSbInfo(type) {
            var _this$tracks2;
            var track = (_this$tracks2 = this.tracks) == null ? void 0 : _this$tracks2[type];
            var sb = track == null ? void 0 : track.buffer;
            if (!sb) {
              return "none";
            }
            return "SourceBuffer" + (sb.updating ? " updating" : "") + (track.ended ? " ended" : "") + (track.ending ? " ending" : "");
          };
          _proto.listOps = function listOps(type) {
            var _this$queues3;
            return ((_this$queues3 = this.queues) == null ? void 0 : _this$queues3[type].map(function(op) {
              return op.label;
            }).join(", ")) || "";
          };
          return BufferOperationQueue2;
        }();
        var BinarySearch = {
          /**
           * Searches for an item in an array which matches a certain condition.
           * This requires the condition to only match one item in the array,
           * and for the array to be ordered.
           *
           * @param list The array to search.
           * @param comparisonFn
           *      Called and provided a candidate item as the first argument.
           *      Should return:
           *          > -1 if the item should be located at a lower index than the provided item.
           *          > 1 if the item should be located at a higher index than the provided item.
           *          > 0 if the item is the item you're looking for.
           *
           * @returns the object if found, otherwise returns null
           */
          search: function search(list, comparisonFn) {
            var minIndex = 0;
            var maxIndex = list.length - 1;
            var currentIndex = null;
            var currentElement = null;
            while (minIndex <= maxIndex) {
              currentIndex = (minIndex + maxIndex) / 2 | 0;
              currentElement = list[currentIndex];
              var comparisonResult = comparisonFn(currentElement);
              if (comparisonResult > 0) {
                minIndex = currentIndex + 1;
              } else if (comparisonResult < 0) {
                maxIndex = currentIndex - 1;
              } else {
                return currentElement;
              }
            }
            return null;
          }
        };
        function findFragmentByPDT(fragments, PDTValue, maxFragLookUpTolerance) {
          if (PDTValue === null || !Array.isArray(fragments) || !fragments.length || !isFiniteNumber(PDTValue)) {
            return null;
          }
          var startPDT = fragments[0].programDateTime;
          if (PDTValue < (startPDT || 0)) {
            return null;
          }
          var endPDT = fragments[fragments.length - 1].endProgramDateTime;
          if (PDTValue >= (endPDT || 0)) {
            return null;
          }
          maxFragLookUpTolerance = maxFragLookUpTolerance || 0;
          for (var seg = 0; seg < fragments.length; ++seg) {
            var frag = fragments[seg];
            if (pdtWithinToleranceTest(PDTValue, maxFragLookUpTolerance, frag)) {
              return frag;
            }
          }
          return null;
        }
        function findFragmentByPTS(fragPrevious, fragments, bufferEnd, maxFragLookUpTolerance, nextFragLookupTolerance) {
          if (bufferEnd === void 0) {
            bufferEnd = 0;
          }
          if (maxFragLookUpTolerance === void 0) {
            maxFragLookUpTolerance = 0;
          }
          if (nextFragLookupTolerance === void 0) {
            nextFragLookupTolerance = 5e-3;
          }
          var fragNext = null;
          if (fragPrevious) {
            fragNext = fragments[1 + fragPrevious.sn - fragments[0].sn] || null;
            var bufferEdgeError = fragPrevious.endDTS - bufferEnd;
            if (bufferEdgeError > 0 && bufferEdgeError < 15e-7) {
              bufferEnd += 15e-7;
            }
            if (fragNext && fragPrevious.level !== fragNext.level && fragNext.end <= fragPrevious.end) {
              fragNext = fragments[2 + fragPrevious.sn - fragments[0].sn] || null;
            }
          } else if (bufferEnd === 0 && fragments[0].start === 0) {
            fragNext = fragments[0];
          }
          if (fragNext && ((!fragPrevious || fragPrevious.level === fragNext.level) && fragmentWithinToleranceTest(bufferEnd, maxFragLookUpTolerance, fragNext) === 0 || fragmentWithinFastStartSwitch(fragNext, fragPrevious, Math.min(nextFragLookupTolerance, maxFragLookUpTolerance)))) {
            return fragNext;
          }
          var foundFragment = BinarySearch.search(fragments, fragmentWithinToleranceTest.bind(null, bufferEnd, maxFragLookUpTolerance));
          if (foundFragment && (foundFragment !== fragPrevious || !fragNext)) {
            return foundFragment;
          }
          return fragNext;
        }
        function fragmentWithinFastStartSwitch(fragNext, fragPrevious, nextFragLookupTolerance) {
          if (fragPrevious && fragPrevious.start === 0 && fragPrevious.level < fragNext.level && (fragPrevious.endPTS || 0) > 0) {
            var firstDuration = fragPrevious.tagList.reduce(function(duration, tag) {
              if (tag[0] === "INF") {
                duration += parseFloat(tag[1]);
              }
              return duration;
            }, nextFragLookupTolerance);
            return fragNext.start <= firstDuration;
          }
          return false;
        }
        function fragmentWithinToleranceTest(bufferEnd, maxFragLookUpTolerance, candidate) {
          if (bufferEnd === void 0) {
            bufferEnd = 0;
          }
          if (maxFragLookUpTolerance === void 0) {
            maxFragLookUpTolerance = 0;
          }
          if (candidate.start <= bufferEnd && candidate.start + candidate.duration > bufferEnd) {
            return 0;
          }
          var candidateLookupTolerance = Math.min(maxFragLookUpTolerance, candidate.duration + (candidate.deltaPTS ? candidate.deltaPTS : 0));
          if (candidate.start + candidate.duration - candidateLookupTolerance <= bufferEnd) {
            return 1;
          } else if (candidate.start - candidateLookupTolerance > bufferEnd && candidate.start) {
            return -1;
          }
          return 0;
        }
        function pdtWithinToleranceTest(pdtBufferEnd, maxFragLookUpTolerance, candidate) {
          var candidateLookupTolerance = Math.min(maxFragLookUpTolerance, candidate.duration + (candidate.deltaPTS ? candidate.deltaPTS : 0)) * 1e3;
          var endProgramDateTime = candidate.endProgramDateTime || 0;
          return endProgramDateTime - candidateLookupTolerance > pdtBufferEnd;
        }
        function findFragWithCC(fragments, cc) {
          return BinarySearch.search(fragments, function(candidate) {
            if (candidate.cc < cc) {
              return 1;
            } else if (candidate.cc > cc) {
              return -1;
            } else {
              return 0;
            }
          });
        }
        function isTimeoutError(error) {
          switch (error.details) {
            case ErrorDetails.FRAG_LOAD_TIMEOUT:
            case ErrorDetails.KEY_LOAD_TIMEOUT:
            case ErrorDetails.LEVEL_LOAD_TIMEOUT:
            case ErrorDetails.MANIFEST_LOAD_TIMEOUT:
              return true;
          }
          return false;
        }
        function getRetryConfig(loadPolicy, error) {
          var isTimeout = isTimeoutError(error);
          return loadPolicy.default[(isTimeout ? "timeout" : "error") + "Retry"];
        }
        function getRetryDelay(retryConfig, retryCount) {
          var backoffFactor = retryConfig.backoff === "linear" ? 1 : Math.pow(2, retryCount);
          return Math.min(backoffFactor * retryConfig.retryDelayMs, retryConfig.maxRetryDelayMs);
        }
        function getLoaderConfigWithoutReties(loderConfig) {
          return _objectSpread23(_objectSpread23({}, loderConfig), {
            errorRetry: null,
            timeoutRetry: null
          });
        }
        function shouldRetry(retryConfig, retryCount, isTimeout, loaderResponse) {
          if (!retryConfig) {
            return false;
          }
          var httpStatus = loaderResponse == null ? void 0 : loaderResponse.code;
          var retry = retryCount < retryConfig.maxNumRetry && (retryForHttpStatus(httpStatus) || !!isTimeout);
          return retryConfig.shouldRetry ? retryConfig.shouldRetry(retryConfig, retryCount, isTimeout, loaderResponse, retry) : retry;
        }
        function retryForHttpStatus(httpStatus) {
          return httpStatus === 0 && navigator.onLine === false || !!httpStatus && (httpStatus < 400 || httpStatus > 499);
        }
        var NetworkErrorAction = {
          DoNothing: 0,
          SendAlternateToPenaltyBox: 2,
          RemoveAlternatePermanently: 3,
          RetryRequest: 5
        };
        var ErrorActionFlags = {
          None: 0,
          MoveAllAlternatesMatchingHost: 1,
          MoveAllAlternatesMatchingHDCP: 2
        };
        var ErrorController = /* @__PURE__ */ function(_Logger) {
          function ErrorController2(hls) {
            var _this;
            _this = _Logger.call(this, "error-controller", hls.logger) || this;
            _this.hls = void 0;
            _this.playlistError = 0;
            _this.penalizedRenditions = {};
            _this.hls = hls;
            _this.registerListeners();
            return _this;
          }
          _inheritsLoose(ErrorController2, _Logger);
          var _proto = ErrorController2.prototype;
          _proto.registerListeners = function registerListeners() {
            var hls = this.hls;
            hls.on(Events.ERROR, this.onError, this);
            hls.on(Events.MANIFEST_LOADING, this.onManifestLoading, this);
            hls.on(Events.LEVEL_UPDATED, this.onLevelUpdated, this);
          };
          _proto.unregisterListeners = function unregisterListeners() {
            var hls = this.hls;
            if (!hls) {
              return;
            }
            hls.off(Events.ERROR, this.onError, this);
            hls.off(Events.ERROR, this.onErrorOut, this);
            hls.off(Events.MANIFEST_LOADING, this.onManifestLoading, this);
            hls.off(Events.LEVEL_UPDATED, this.onLevelUpdated, this);
          };
          _proto.destroy = function destroy() {
            this.unregisterListeners();
            this.hls = null;
            this.penalizedRenditions = {};
          };
          _proto.startLoad = function startLoad(startPosition) {
          };
          _proto.stopLoad = function stopLoad() {
            this.playlistError = 0;
          };
          _proto.getVariantLevelIndex = function getVariantLevelIndex(frag) {
            return (frag == null ? void 0 : frag.type) === PlaylistLevelType.MAIN ? frag.level : this.hls.loadLevel;
          };
          _proto.onManifestLoading = function onManifestLoading() {
            this.playlistError = 0;
            this.penalizedRenditions = {};
          };
          _proto.onLevelUpdated = function onLevelUpdated() {
            this.playlistError = 0;
          };
          _proto.onError = function onError(event, data) {
            var _data$frag;
            if (data.fatal) {
              return;
            }
            var hls = this.hls;
            var context = data.context;
            switch (data.details) {
              case ErrorDetails.FRAG_LOAD_ERROR:
              case ErrorDetails.FRAG_LOAD_TIMEOUT:
              case ErrorDetails.KEY_LOAD_ERROR:
              case ErrorDetails.KEY_LOAD_TIMEOUT:
                data.errorAction = this.getFragRetryOrSwitchAction(data);
                return;
              case ErrorDetails.FRAG_PARSING_ERROR:
                if ((_data$frag = data.frag) != null && _data$frag.gap) {
                  data.errorAction = createDoNothingErrorAction();
                  return;
                }
              // falls through
              case ErrorDetails.FRAG_GAP:
              case ErrorDetails.FRAG_DECRYPT_ERROR: {
                data.errorAction = this.getFragRetryOrSwitchAction(data);
                data.errorAction.action = NetworkErrorAction.SendAlternateToPenaltyBox;
                return;
              }
              case ErrorDetails.LEVEL_EMPTY_ERROR:
              case ErrorDetails.LEVEL_PARSING_ERROR:
                {
                  var _data$context, _data$context$levelDe;
                  var levelIndex = data.parent === PlaylistLevelType.MAIN ? data.level : hls.loadLevel;
                  if (data.details === ErrorDetails.LEVEL_EMPTY_ERROR && !!((_data$context = data.context) != null && (_data$context$levelDe = _data$context.levelDetails) != null && _data$context$levelDe.live)) {
                    data.errorAction = this.getPlaylistRetryOrSwitchAction(data, levelIndex);
                  } else {
                    data.levelRetry = false;
                    data.errorAction = this.getLevelSwitchAction(data, levelIndex);
                  }
                }
                return;
              case ErrorDetails.LEVEL_LOAD_ERROR:
              case ErrorDetails.LEVEL_LOAD_TIMEOUT:
                if (typeof (context == null ? void 0 : context.level) === "number") {
                  data.errorAction = this.getPlaylistRetryOrSwitchAction(data, context.level);
                }
                return;
              case ErrorDetails.AUDIO_TRACK_LOAD_ERROR:
              case ErrorDetails.AUDIO_TRACK_LOAD_TIMEOUT:
              case ErrorDetails.SUBTITLE_LOAD_ERROR:
              case ErrorDetails.SUBTITLE_TRACK_LOAD_TIMEOUT:
                if (context) {
                  var level = hls.loadLevelObj;
                  if (level && (context.type === PlaylistContextType.AUDIO_TRACK && level.hasAudioGroup(context.groupId) || context.type === PlaylistContextType.SUBTITLE_TRACK && level.hasSubtitleGroup(context.groupId))) {
                    data.errorAction = this.getPlaylistRetryOrSwitchAction(data, hls.loadLevel);
                    data.errorAction.action = NetworkErrorAction.SendAlternateToPenaltyBox;
                    data.errorAction.flags = ErrorActionFlags.MoveAllAlternatesMatchingHost;
                    return;
                  }
                }
                return;
              case ErrorDetails.KEY_SYSTEM_STATUS_OUTPUT_RESTRICTED:
                {
                  var _level = hls.loadLevelObj;
                  var restrictedHdcpLevel = _level == null ? void 0 : _level.attrs["HDCP-LEVEL"];
                  if (restrictedHdcpLevel) {
                    data.errorAction = {
                      action: NetworkErrorAction.SendAlternateToPenaltyBox,
                      flags: ErrorActionFlags.MoveAllAlternatesMatchingHDCP,
                      hdcpLevel: restrictedHdcpLevel
                    };
                  } else {
                    this.keySystemError(data);
                  }
                }
                return;
              case ErrorDetails.BUFFER_ADD_CODEC_ERROR:
              case ErrorDetails.REMUX_ALLOC_ERROR:
              case ErrorDetails.BUFFER_APPEND_ERROR:
                if (!data.errorAction) {
                  var _data$level;
                  data.errorAction = this.getLevelSwitchAction(data, (_data$level = data.level) != null ? _data$level : hls.loadLevel);
                }
                return;
              case ErrorDetails.INTERNAL_EXCEPTION:
              case ErrorDetails.BUFFER_APPENDING_ERROR:
              case ErrorDetails.BUFFER_FULL_ERROR:
              case ErrorDetails.LEVEL_SWITCH_ERROR:
              case ErrorDetails.BUFFER_STALLED_ERROR:
              case ErrorDetails.BUFFER_SEEK_OVER_HOLE:
              case ErrorDetails.BUFFER_NUDGE_ON_STALL:
                data.errorAction = createDoNothingErrorAction();
                return;
            }
            if (data.type === ErrorTypes.KEY_SYSTEM_ERROR) {
              this.keySystemError(data);
            }
          };
          _proto.keySystemError = function keySystemError(data) {
            var levelIndex = this.getVariantLevelIndex(data.frag);
            data.levelRetry = false;
            data.errorAction = this.getLevelSwitchAction(data, levelIndex);
          };
          _proto.getPlaylistRetryOrSwitchAction = function getPlaylistRetryOrSwitchAction(data, levelIndex) {
            var hls = this.hls;
            var retryConfig = getRetryConfig(hls.config.playlistLoadPolicy, data);
            var retryCount = this.playlistError++;
            var retry = shouldRetry(retryConfig, retryCount, isTimeoutError(data), data.response);
            if (retry) {
              return {
                action: NetworkErrorAction.RetryRequest,
                flags: ErrorActionFlags.None,
                retryConfig,
                retryCount
              };
            }
            var errorAction = this.getLevelSwitchAction(data, levelIndex);
            if (retryConfig) {
              errorAction.retryConfig = retryConfig;
              errorAction.retryCount = retryCount;
            }
            return errorAction;
          };
          _proto.getFragRetryOrSwitchAction = function getFragRetryOrSwitchAction(data) {
            var hls = this.hls;
            var variantLevelIndex = this.getVariantLevelIndex(data.frag);
            var level = hls.levels[variantLevelIndex];
            var _hls$config = hls.config, fragLoadPolicy = _hls$config.fragLoadPolicy, keyLoadPolicy = _hls$config.keyLoadPolicy;
            var retryConfig = getRetryConfig(data.details.startsWith("key") ? keyLoadPolicy : fragLoadPolicy, data);
            var fragmentErrors = hls.levels.reduce(function(acc, level2) {
              return acc + level2.fragmentError;
            }, 0);
            if (level) {
              if (data.details !== ErrorDetails.FRAG_GAP) {
                level.fragmentError++;
              }
              var retry = shouldRetry(retryConfig, fragmentErrors, isTimeoutError(data), data.response);
              if (retry) {
                return {
                  action: NetworkErrorAction.RetryRequest,
                  flags: ErrorActionFlags.None,
                  retryConfig,
                  retryCount: fragmentErrors
                };
              }
            }
            var errorAction = this.getLevelSwitchAction(data, variantLevelIndex);
            if (retryConfig) {
              errorAction.retryConfig = retryConfig;
              errorAction.retryCount = fragmentErrors;
            }
            return errorAction;
          };
          _proto.getLevelSwitchAction = function getLevelSwitchAction(data, levelIndex) {
            var hls = this.hls;
            if (levelIndex === null || levelIndex === void 0) {
              levelIndex = hls.loadLevel;
            }
            var level = this.hls.levels[levelIndex];
            if (level) {
              var _data$frag2, _data$context2;
              var errorDetails = data.details;
              level.loadError++;
              if (errorDetails === ErrorDetails.BUFFER_APPEND_ERROR) {
                level.fragmentError++;
              }
              var nextLevel = -1;
              var levels = hls.levels, loadLevel = hls.loadLevel, minAutoLevel = hls.minAutoLevel, maxAutoLevel = hls.maxAutoLevel;
              if (!hls.autoLevelEnabled) {
                hls.loadLevel = -1;
              }
              var fragErrorType = (_data$frag2 = data.frag) == null ? void 0 : _data$frag2.type;
              var isAudioCodecError = fragErrorType === PlaylistLevelType.AUDIO && errorDetails === ErrorDetails.FRAG_PARSING_ERROR || data.sourceBufferName === "audio" && (errorDetails === ErrorDetails.BUFFER_ADD_CODEC_ERROR || errorDetails === ErrorDetails.BUFFER_APPEND_ERROR);
              var findAudioCodecAlternate = isAudioCodecError && levels.some(function(_ref) {
                var audioCodec = _ref.audioCodec;
                return level.audioCodec !== audioCodec;
              });
              var isVideoCodecError = data.sourceBufferName === "video" && (errorDetails === ErrorDetails.BUFFER_ADD_CODEC_ERROR || errorDetails === ErrorDetails.BUFFER_APPEND_ERROR);
              var findVideoCodecAlternate = isVideoCodecError && levels.some(function(_ref2) {
                var codecSet = _ref2.codecSet, audioCodec = _ref2.audioCodec;
                return level.codecSet !== codecSet && level.audioCodec === audioCodec;
              });
              var _ref3 = (_data$context2 = data.context) != null ? _data$context2 : {}, playlistErrorType = _ref3.type, playlistErrorGroupId = _ref3.groupId;
              var _loop = function _loop2() {
                var candidate = (i + loadLevel) % levels.length;
                if (candidate !== loadLevel && candidate >= minAutoLevel && candidate <= maxAutoLevel && levels[candidate].loadError === 0) {
                  var _level$audioGroups, _level$subtitleGroups;
                  var levelCandidate = levels[candidate];
                  if (errorDetails === ErrorDetails.FRAG_GAP && fragErrorType === PlaylistLevelType.MAIN && data.frag) {
                    var levelDetails = levels[candidate].details;
                    if (levelDetails) {
                      var fragCandidate = findFragmentByPTS(data.frag, levelDetails.fragments, data.frag.start);
                      if (fragCandidate != null && fragCandidate.gap) {
                        return 0;
                      }
                    }
                  } else if (playlistErrorType === PlaylistContextType.AUDIO_TRACK && levelCandidate.hasAudioGroup(playlistErrorGroupId) || playlistErrorType === PlaylistContextType.SUBTITLE_TRACK && levelCandidate.hasSubtitleGroup(playlistErrorGroupId)) {
                    return 0;
                  } else if (fragErrorType === PlaylistLevelType.AUDIO && (_level$audioGroups = level.audioGroups) != null && _level$audioGroups.some(function(groupId) {
                    return levelCandidate.hasAudioGroup(groupId);
                  }) || fragErrorType === PlaylistLevelType.SUBTITLE && (_level$subtitleGroups = level.subtitleGroups) != null && _level$subtitleGroups.some(function(groupId) {
                    return levelCandidate.hasSubtitleGroup(groupId);
                  }) || findAudioCodecAlternate && level.audioCodec === levelCandidate.audioCodec || !findAudioCodecAlternate && level.audioCodec !== levelCandidate.audioCodec || findVideoCodecAlternate && level.codecSet === levelCandidate.codecSet) {
                    return 0;
                  }
                  nextLevel = candidate;
                  return 1;
                }
              }, _ret;
              for (var i = levels.length; i--; ) {
                _ret = _loop();
                if (_ret === 0) continue;
                if (_ret === 1) break;
              }
              if (nextLevel > -1 && hls.loadLevel !== nextLevel) {
                data.levelRetry = true;
                this.playlistError = 0;
                return {
                  action: NetworkErrorAction.SendAlternateToPenaltyBox,
                  flags: ErrorActionFlags.None,
                  nextAutoLevel: nextLevel
                };
              }
            }
            return {
              action: NetworkErrorAction.SendAlternateToPenaltyBox,
              flags: ErrorActionFlags.MoveAllAlternatesMatchingHost
            };
          };
          _proto.onErrorOut = function onErrorOut(event, data) {
            var _data$errorAction;
            switch ((_data$errorAction = data.errorAction) == null ? void 0 : _data$errorAction.action) {
              case NetworkErrorAction.DoNothing:
                break;
              case NetworkErrorAction.SendAlternateToPenaltyBox:
                this.sendAlternateToPenaltyBox(data);
                if (!data.errorAction.resolved && data.details !== ErrorDetails.FRAG_GAP) {
                  data.fatal = true;
                } else if (/MediaSource readyState: ended/.test(data.error.message)) {
                  this.warn('MediaSource ended after "' + data.sourceBufferName + '" sourceBuffer append error. Attempting to recover from media error.');
                  this.hls.recoverMediaError();
                }
                break;
            }
            if (data.fatal) {
              this.hls.stopLoad();
              return;
            }
          };
          _proto.sendAlternateToPenaltyBox = function sendAlternateToPenaltyBox(data) {
            var hls = this.hls;
            var errorAction = data.errorAction;
            if (!errorAction) {
              return;
            }
            var flags = errorAction.flags, hdcpLevel = errorAction.hdcpLevel, nextAutoLevel = errorAction.nextAutoLevel;
            switch (flags) {
              case ErrorActionFlags.None:
                this.switchLevel(data, nextAutoLevel);
                break;
              case ErrorActionFlags.MoveAllAlternatesMatchingHDCP:
                if (hdcpLevel) {
                  hls.maxHdcpLevel = HdcpLevels[HdcpLevels.indexOf(hdcpLevel) - 1];
                  errorAction.resolved = true;
                }
                this.warn('Restricting playback to HDCP-LEVEL of "' + hls.maxHdcpLevel + '" or lower');
                break;
            }
            if (!errorAction.resolved) {
              this.switchLevel(data, nextAutoLevel);
            }
          };
          _proto.switchLevel = function switchLevel(data, levelIndex) {
            if (levelIndex !== void 0 && data.errorAction) {
              this.warn("switching to level " + levelIndex + " after " + data.details);
              this.hls.nextAutoLevel = levelIndex;
              data.errorAction.resolved = true;
              this.hls.nextLoadLevel = this.hls.nextAutoLevel;
              if (data.details === ErrorDetails.BUFFER_ADD_CODEC_ERROR && data.mimeType && data.sourceBufferName !== "audiovideo") {
                var codec = getCodecsForMimeType(data.mimeType);
                var levels = this.hls.levels;
                for (var i = levels.length; i--; ) {
                  if (levels[i][data.sourceBufferName + "Codec"] === codec) {
                    this.hls.removeLevel(i);
                  }
                }
              }
            }
          };
          return ErrorController2;
        }(Logger4);
        function createDoNothingErrorAction(resolved) {
          var errorAction = {
            action: NetworkErrorAction.DoNothing,
            flags: ErrorActionFlags.None
          };
          if (resolved) {
            errorAction.resolved = true;
          }
          return errorAction;
        }
        var noopBuffered = {
          length: 0,
          start: function start() {
            return 0;
          },
          end: function end() {
            return 0;
          }
        };
        var BufferHelper = /* @__PURE__ */ function() {
          function BufferHelper2() {
          }
          BufferHelper2.isBuffered = function isBuffered(media, position) {
            if (media) {
              var buffered = BufferHelper2.getBuffered(media);
              for (var i = buffered.length; i--; ) {
                if (position >= buffered.start(i) && position <= buffered.end(i)) {
                  return true;
                }
              }
            }
            return false;
          };
          BufferHelper2.bufferedRanges = function bufferedRanges(media) {
            if (media) {
              var timeRanges = BufferHelper2.getBuffered(media);
              return BufferHelper2.timeRangesToArray(timeRanges);
            }
            return [];
          };
          BufferHelper2.timeRangesToArray = function timeRangesToArray(timeRanges) {
            var buffered = [];
            for (var i = 0; i < timeRanges.length; i++) {
              buffered.push({
                start: timeRanges.start(i),
                end: timeRanges.end(i)
              });
            }
            return buffered;
          };
          BufferHelper2.bufferInfo = function bufferInfo(media, pos, maxHoleDuration) {
            if (media) {
              var buffered = BufferHelper2.bufferedRanges(media);
              if (buffered.length) {
                return BufferHelper2.bufferedInfo(buffered, pos, maxHoleDuration);
              }
            }
            return {
              len: 0,
              start: pos,
              end: pos,
              bufferedIndex: -1
            };
          };
          BufferHelper2.bufferedInfo = function bufferedInfo(buffered, pos, maxHoleDuration) {
            pos = Math.max(0, pos);
            if (buffered.length > 1) {
              buffered.sort(function(a, b) {
                return a.start - b.start || b.end - a.end;
              });
            }
            var bufferedIndex = -1;
            var buffered2 = [];
            if (maxHoleDuration) {
              for (var i = 0; i < buffered.length; i++) {
                if (pos >= buffered[i].start && pos <= buffered[i].end) {
                  bufferedIndex = i;
                }
                var buf2len = buffered2.length;
                if (buf2len) {
                  var buf2end = buffered2[buf2len - 1].end;
                  if (buffered[i].start - buf2end < maxHoleDuration) {
                    if (buffered[i].end > buf2end) {
                      buffered2[buf2len - 1].end = buffered[i].end;
                    }
                  } else {
                    buffered2.push(buffered[i]);
                  }
                } else {
                  buffered2.push(buffered[i]);
                }
              }
            } else {
              buffered2 = buffered;
            }
            var bufferLen = 0;
            var nextStart;
            var bufferStart = pos;
            var bufferEnd = pos;
            for (var _i = 0; _i < buffered2.length; _i++) {
              var start = buffered2[_i].start;
              var end = buffered2[_i].end;
              if (bufferedIndex === -1 && pos >= start && pos <= end) {
                bufferedIndex = _i;
              }
              if (pos + maxHoleDuration >= start && pos < end) {
                bufferStart = start;
                bufferEnd = end;
                bufferLen = bufferEnd - pos;
              } else if (pos + maxHoleDuration < start) {
                nextStart = start;
                break;
              }
            }
            return {
              len: bufferLen,
              start: bufferStart || 0,
              end: bufferEnd || 0,
              nextStart,
              buffered,
              bufferedIndex
            };
          };
          BufferHelper2.getBuffered = function getBuffered(media) {
            try {
              return media.buffered || noopBuffered;
            } catch (e) {
              logger4.log("failed to get media.buffered", e);
              return noopBuffered;
            }
          };
          return BufferHelper2;
        }();
        var VIDEO_CODEC_PROFILE_REPLACE = /(avc[1234]|hvc1|hev1|dvh[1e]|vp09|av01)(?:\.[^.,]+)+/;
        var TRACK_REMOVED_ERROR_NAME = "HlsJsTrackRemovedError";
        var HlsJsTrackRemovedError = /* @__PURE__ */ function(_Error) {
          function HlsJsTrackRemovedError2(message) {
            var _this;
            _this = _Error.call(this, message) || this;
            _this.name = TRACK_REMOVED_ERROR_NAME;
            return _this;
          }
          _inheritsLoose(HlsJsTrackRemovedError2, _Error);
          return HlsJsTrackRemovedError2;
        }(/* @__PURE__ */ _wrapNativeSuper2(Error));
        var BufferController = /* @__PURE__ */ function(_Logger) {
          function BufferController2(hls, fragmentTracker) {
            var _this2;
            _this2 = _Logger.call(this, "buffer-controller", hls.logger) || this;
            _this2.hls = void 0;
            _this2.fragmentTracker = void 0;
            _this2.details = null;
            _this2._objectUrl = null;
            _this2.operationQueue = null;
            _this2.bufferCodecEventsTotal = 0;
            _this2.media = null;
            _this2.mediaSource = null;
            _this2.lastMpegAudioChunk = null;
            _this2.blockedAudioAppend = null;
            _this2.lastVideoAppendEnd = 0;
            _this2.appendSource = void 0;
            _this2.transferData = void 0;
            _this2.overrides = void 0;
            _this2.appendErrors = {
              audio: 0,
              video: 0,
              audiovideo: 0
            };
            _this2.tracks = {};
            _this2.sourceBuffers = [[null, null], [null, null]];
            _this2._onEndStreaming = function(event) {
              var _this2$mediaSource;
              if (!_this2.hls) {
                return;
              }
              if (((_this2$mediaSource = _this2.mediaSource) == null ? void 0 : _this2$mediaSource.readyState) !== "open") {
                return;
              }
              _this2.hls.pauseBuffering();
            };
            _this2._onStartStreaming = function(event) {
              if (!_this2.hls) {
                return;
              }
              _this2.hls.resumeBuffering();
            };
            _this2._onMediaSourceOpen = function(e) {
              var _this3 = _this2, media = _this3.media, mediaSource = _this3.mediaSource;
              if (e) {
                _this2.log("Media source opened");
              }
              if (!media || !mediaSource) {
                return;
              }
              mediaSource.removeEventListener("sourceopen", _this2._onMediaSourceOpen);
              media.removeEventListener("emptied", _this2._onMediaEmptied);
              _this2.updateDuration();
              _this2.hls.trigger(Events.MEDIA_ATTACHED, {
                media,
                mediaSource
              });
              if (_this2.mediaSource !== null) {
                _this2.checkPendingTracks();
              }
            };
            _this2._onMediaSourceClose = function() {
              _this2.log("Media source closed");
            };
            _this2._onMediaSourceEnded = function() {
              _this2.log("Media source ended");
            };
            _this2._onMediaEmptied = function() {
              var _this4 = _this2, mediaSrc = _this4.mediaSrc, _objectUrl = _this4._objectUrl;
              if (mediaSrc !== _objectUrl) {
                _this2.error("Media element src was set while attaching MediaSource (" + _objectUrl + " > " + mediaSrc + ")");
              }
            };
            _this2.hls = hls;
            _this2.fragmentTracker = fragmentTracker;
            _this2.appendSource = isManagedMediaSource(getMediaSource2(hls.config.preferManagedMediaSource));
            _this2.initTracks();
            _this2.registerListeners();
            return _this2;
          }
          _inheritsLoose(BufferController2, _Logger);
          var _proto = BufferController2.prototype;
          _proto.hasSourceTypes = function hasSourceTypes() {
            return Object.keys(this.tracks).length > 0;
          };
          _proto.destroy = function destroy() {
            this.unregisterListeners();
            this.details = null;
            this.lastMpegAudioChunk = this.blockedAudioAppend = null;
            this.transferData = this.overrides = void 0;
            if (this.operationQueue) {
              this.operationQueue.destroy();
              this.operationQueue = null;
            }
            this.hls = this.fragmentTracker = null;
            this._onMediaSourceOpen = this._onMediaSourceClose = null;
            this._onMediaSourceEnded = null;
            this._onStartStreaming = this._onEndStreaming = null;
          };
          _proto.registerListeners = function registerListeners() {
            var hls = this.hls;
            hls.on(Events.MEDIA_ATTACHING, this.onMediaAttaching, this);
            hls.on(Events.MEDIA_DETACHING, this.onMediaDetaching, this);
            hls.on(Events.MANIFEST_LOADING, this.onManifestLoading, this);
            hls.on(Events.MANIFEST_PARSED, this.onManifestParsed, this);
            hls.on(Events.BUFFER_RESET, this.onBufferReset, this);
            hls.on(Events.BUFFER_APPENDING, this.onBufferAppending, this);
            hls.on(Events.BUFFER_CODECS, this.onBufferCodecs, this);
            hls.on(Events.BUFFER_EOS, this.onBufferEos, this);
            hls.on(Events.BUFFER_FLUSHING, this.onBufferFlushing, this);
            hls.on(Events.LEVEL_UPDATED, this.onLevelUpdated, this);
            hls.on(Events.FRAG_PARSED, this.onFragParsed, this);
            hls.on(Events.FRAG_CHANGED, this.onFragChanged, this);
            hls.on(Events.ERROR, this.onError, this);
          };
          _proto.unregisterListeners = function unregisterListeners() {
            var hls = this.hls;
            hls.off(Events.MEDIA_ATTACHING, this.onMediaAttaching, this);
            hls.off(Events.MEDIA_DETACHING, this.onMediaDetaching, this);
            hls.off(Events.MANIFEST_LOADING, this.onManifestLoading, this);
            hls.off(Events.MANIFEST_PARSED, this.onManifestParsed, this);
            hls.off(Events.BUFFER_RESET, this.onBufferReset, this);
            hls.off(Events.BUFFER_APPENDING, this.onBufferAppending, this);
            hls.off(Events.BUFFER_CODECS, this.onBufferCodecs, this);
            hls.off(Events.BUFFER_EOS, this.onBufferEos, this);
            hls.off(Events.BUFFER_FLUSHING, this.onBufferFlushing, this);
            hls.off(Events.LEVEL_UPDATED, this.onLevelUpdated, this);
            hls.off(Events.FRAG_PARSED, this.onFragParsed, this);
            hls.off(Events.FRAG_CHANGED, this.onFragChanged, this);
            hls.off(Events.ERROR, this.onError, this);
          };
          _proto.transferMedia = function transferMedia() {
            var _this5 = this;
            var media = this.media, mediaSource = this.mediaSource;
            if (!media) {
              return null;
            }
            var tracks = {};
            if (this.operationQueue) {
              var updating = this.isUpdating();
              if (!updating) {
                this.operationQueue.removeBlockers();
              }
              var queued = this.isQueued();
              if (updating || queued) {
                this.warn("Transfering MediaSource with" + (queued ? " operations in queue" : "") + (updating ? " updating SourceBuffer(s)" : "") + " " + this.operationQueue);
              }
              this.operationQueue.destroy();
            }
            var transferData = this.transferData;
            if (!this.sourceBufferCount && transferData && transferData.mediaSource === mediaSource) {
              _extends(tracks, transferData.tracks);
            } else {
              this.sourceBuffers.forEach(function(tuple) {
                var type = tuple[0];
                if (type) {
                  tracks[type] = _extends({}, _this5.tracks[type]);
                  _this5.removeBuffer(type);
                }
                tuple[0] = tuple[1] = null;
              });
            }
            return {
              media,
              mediaSource,
              tracks
            };
          };
          _proto.initTracks = function initTracks() {
            var tracks = {};
            this.sourceBuffers = [[null, null], [null, null]];
            this.tracks = tracks;
            this.resetQueue();
            this.resetAppendErrors();
            this.lastMpegAudioChunk = this.blockedAudioAppend = null;
            this.lastVideoAppendEnd = 0;
          };
          _proto.onManifestLoading = function onManifestLoading() {
            this.bufferCodecEventsTotal = 0;
            this.details = null;
          };
          _proto.onManifestParsed = function onManifestParsed(event, data) {
            var _this$transferData;
            var codecEvents = 2;
            if (data.audio && !data.video || !data.altAudio || true) {
              codecEvents = 1;
            }
            this.bufferCodecEventsTotal = codecEvents;
            this.log(codecEvents + " bufferCodec event(s) expected.");
            if ((_this$transferData = this.transferData) != null && _this$transferData.mediaSource && this.sourceBufferCount && codecEvents) {
              this.bufferCreated();
            }
          };
          _proto.onMediaAttaching = function onMediaAttaching(event, data) {
            var media = this.media = data.media;
            var MediaSource2 = getMediaSource2(this.appendSource);
            this.transferData = this.overrides = void 0;
            if (media && MediaSource2) {
              var transferringMedia = !!data.mediaSource;
              if (transferringMedia || data.overrides) {
                this.transferData = data;
                this.overrides = data.overrides;
              }
              var ms = this.mediaSource = data.mediaSource || new MediaSource2();
              this.assignMediaSource(ms);
              if (transferringMedia) {
                this._objectUrl = media.src;
                this.attachTransferred();
              } else {
                var objectUrl = this._objectUrl = self.URL.createObjectURL(ms);
                if (this.appendSource) {
                  try {
                    media.removeAttribute("src");
                    var MMS = self.ManagedMediaSource;
                    media.disableRemotePlayback = media.disableRemotePlayback || MMS && ms instanceof MMS;
                    removeSourceChildren(media);
                    addSource(media, objectUrl);
                    media.load();
                  } catch (error) {
                    media.src = objectUrl;
                  }
                } else {
                  media.src = objectUrl;
                }
              }
              media.addEventListener("emptied", this._onMediaEmptied);
            }
          };
          _proto.assignMediaSource = function assignMediaSource(ms) {
            var _this$transferData2, _ms$constructor;
            this.log((((_this$transferData2 = this.transferData) == null ? void 0 : _this$transferData2.mediaSource) === ms ? "transferred" : "created") + " media source: " + ((_ms$constructor = ms.constructor) == null ? void 0 : _ms$constructor.name));
            ms.addEventListener("sourceopen", this._onMediaSourceOpen);
            ms.addEventListener("sourceended", this._onMediaSourceEnded);
            ms.addEventListener("sourceclose", this._onMediaSourceClose);
            if (this.appendSource) {
              ms.addEventListener("startstreaming", this._onStartStreaming);
              ms.addEventListener("endstreaming", this._onEndStreaming);
            }
          };
          _proto.attachTransferred = function attachTransferred() {
            var _this6 = this;
            var media = this.media;
            var data = this.transferData;
            if (!data || !media) {
              return;
            }
            var requiredTracks = this.tracks;
            var transferredTracks = data.tracks;
            var trackNames = transferredTracks ? Object.keys(transferredTracks) : null;
            var trackCount = trackNames ? trackNames.length : 0;
            var mediaSourceOpenCallback = function mediaSourceOpenCallback2() {
              if (_this6.media && _this6.mediaSourceOpenOrEnded) {
                _this6._onMediaSourceOpen();
              }
            };
            if (transferredTracks && trackNames && trackCount) {
              if (!this.tracksReady) {
                this.hls.config.startFragPrefetch = true;
                this.log("attachTransferred: waiting for SourceBuffer track info");
                return;
              }
              this.log("attachTransferred: (bufferCodecEventsTotal " + this.bufferCodecEventsTotal + ")\nrequired tracks: " + stringify2(requiredTracks, function(key, value) {
                return key === "initSegment" ? void 0 : value;
              }) + ";\ntransfer tracks: " + stringify2(transferredTracks, function(key, value) {
                return key === "initSegment" ? void 0 : value;
              }) + "}");
              if (!isCompatibleTrackChange(transferredTracks, requiredTracks)) {
                data.mediaSource = null;
                data.tracks = void 0;
                var currentTime = media.currentTime;
                var details = this.details;
                var startTime = Math.max(currentTime, (details == null ? void 0 : details.fragments[0].start) || 0);
                if (startTime - currentTime > 1) {
                  this.log("attachTransferred: waiting for playback to reach new tracks start time " + currentTime + " -> " + startTime);
                  return;
                }
                this.warn('attachTransferred: resetting MediaSource for incompatible tracks ("' + Object.keys(transferredTracks) + '"->"' + Object.keys(requiredTracks) + '") start time: ' + startTime + " currentTime: " + currentTime);
                this.onMediaDetaching(Events.MEDIA_DETACHING, {});
                this.onMediaAttaching(Events.MEDIA_ATTACHING, data);
                media.currentTime = startTime;
                return;
              }
              this.transferData = void 0;
              trackNames.forEach(function(trackName) {
                var type = trackName;
                var track = transferredTracks[type];
                if (track) {
                  var sb = track.buffer;
                  if (sb) {
                    var fragmentTracker = _this6.fragmentTracker;
                    var playlistType = track.id;
                    if (fragmentTracker.hasFragments(playlistType) || fragmentTracker.hasParts(playlistType)) {
                      var bufferedTimeRanges = BufferHelper.getBuffered(sb);
                      fragmentTracker.detectEvictedFragments(type, bufferedTimeRanges, playlistType, null, true);
                    }
                    var sbIndex = sourceBufferNameToIndex(type);
                    var sbTuple = [type, sb];
                    _this6.sourceBuffers[sbIndex] = sbTuple;
                    if (sb.updating && _this6.operationQueue) {
                      _this6.operationQueue.prependBlocker(type);
                    }
                    _this6.trackSourceBuffer(type, track);
                  }
                }
              });
              mediaSourceOpenCallback();
              this.bufferCreated();
            } else {
              this.log("attachTransferred: MediaSource w/o SourceBuffers");
              mediaSourceOpenCallback();
            }
          };
          _proto.onMediaDetaching = function onMediaDetaching(event, data) {
            var _this7 = this;
            var transferringMedia = !!data.transferMedia;
            this.transferData = this.overrides = void 0;
            var media = this.media, mediaSource = this.mediaSource, _objectUrl = this._objectUrl;
            if (mediaSource) {
              this.log("media source " + (transferringMedia ? "transferring" : "detaching"));
              if (transferringMedia) {
                this.sourceBuffers.forEach(function(_ref) {
                  var type = _ref[0];
                  if (type) {
                    _this7.removeBuffer(type);
                  }
                });
                this.resetQueue();
              } else {
                if (this.mediaSourceOpenOrEnded) {
                  var open = mediaSource.readyState === "open";
                  try {
                    var sourceBuffers = mediaSource.sourceBuffers;
                    for (var i = sourceBuffers.length; i--; ) {
                      if (open) {
                        sourceBuffers[i].abort();
                      }
                      mediaSource.removeSourceBuffer(sourceBuffers[i]);
                    }
                    if (open) {
                      mediaSource.endOfStream();
                    }
                  } catch (err) {
                    this.warn("onMediaDetaching: " + err.message + " while calling endOfStream");
                  }
                }
                if (this.sourceBufferCount) {
                  this.onBufferReset();
                }
              }
              mediaSource.removeEventListener("sourceopen", this._onMediaSourceOpen);
              mediaSource.removeEventListener("sourceended", this._onMediaSourceEnded);
              mediaSource.removeEventListener("sourceclose", this._onMediaSourceClose);
              if (this.appendSource) {
                mediaSource.removeEventListener("startstreaming", this._onStartStreaming);
                mediaSource.removeEventListener("endstreaming", this._onEndStreaming);
              }
              this.mediaSource = null;
              this._objectUrl = null;
            }
            if (media) {
              media.removeEventListener("emptied", this._onMediaEmptied);
              if (!transferringMedia) {
                if (_objectUrl) {
                  self.URL.revokeObjectURL(_objectUrl);
                }
                if (this.mediaSrc === _objectUrl) {
                  media.removeAttribute("src");
                  if (this.appendSource) {
                    removeSourceChildren(media);
                  }
                  media.load();
                } else {
                  this.warn("media|source.src was changed by a third party - skip cleanup");
                }
              }
              this.media = null;
            }
            this.hls.trigger(Events.MEDIA_DETACHED, data);
          };
          _proto.onBufferReset = function onBufferReset() {
            var _this8 = this;
            this.sourceBuffers.forEach(function(_ref2) {
              var type = _ref2[0];
              if (type) {
                _this8.resetBuffer(type);
              }
            });
            this.initTracks();
          };
          _proto.resetBuffer = function resetBuffer(type) {
            var _this$tracks$type;
            var sb = (_this$tracks$type = this.tracks[type]) == null ? void 0 : _this$tracks$type.buffer;
            this.removeBuffer(type);
            if (sb) {
              try {
                var _this$mediaSource;
                if ((_this$mediaSource = this.mediaSource) != null && _this$mediaSource.sourceBuffers.length) {
                  this.mediaSource.removeSourceBuffer(sb);
                }
              } catch (err) {
                this.warn("onBufferReset " + type, err);
              }
            }
            delete this.tracks[type];
          };
          _proto.removeBuffer = function removeBuffer(type) {
            this.removeBufferListeners(type);
            this.sourceBuffers[sourceBufferNameToIndex(type)] = [null, null];
            var track = this.tracks[type];
            if (track) {
              track.buffer = void 0;
            }
          };
          _proto.resetQueue = function resetQueue() {
            if (this.operationQueue) {
              this.operationQueue.destroy();
            }
            this.operationQueue = new BufferOperationQueue(this.tracks);
          };
          _proto.onBufferCodecs = function onBufferCodecs(event, data) {
            var _this9 = this;
            var tracks = this.tracks;
            var trackNames = Object.keys(data);
            this.log('BUFFER_CODECS: "' + trackNames + '" (current SB count ' + this.sourceBufferCount + ")");
            var unmuxedToMuxed = "audiovideo" in data && (tracks.audio || tracks.video) || tracks.audiovideo && ("audio" in data || "video" in data);
            var muxedToUnmuxed = !unmuxedToMuxed && this.sourceBufferCount && this.media && trackNames.some(function(sbName) {
              return !tracks[sbName];
            });
            if (unmuxedToMuxed || muxedToUnmuxed) {
              this.warn('Unsupported transition between "' + Object.keys(tracks) + '" and "' + trackNames + '" SourceBuffers');
              return;
            }
            trackNames.forEach(function(trackName) {
              var _this9$transferData, _this9$transferData$t, _trackCodec;
              var parsedTrack = data[trackName];
              var id = parsedTrack.id, codec = parsedTrack.codec, levelCodec = parsedTrack.levelCodec, container = parsedTrack.container, metadata = parsedTrack.metadata, supplemental = parsedTrack.supplemental;
              var track = tracks[trackName];
              var transferredTrack = (_this9$transferData = _this9.transferData) == null ? void 0 : (_this9$transferData$t = _this9$transferData.tracks) == null ? void 0 : _this9$transferData$t[trackName];
              var sbTrack = transferredTrack != null && transferredTrack.buffer ? transferredTrack : track;
              var sbCodec = (sbTrack == null ? void 0 : sbTrack.pendingCodec) || (sbTrack == null ? void 0 : sbTrack.codec);
              var trackLevelCodec = sbTrack == null ? void 0 : sbTrack.levelCodec;
              if (!track) {
                track = tracks[trackName] = {
                  buffer: void 0,
                  listeners: [],
                  codec,
                  supplemental,
                  container,
                  levelCodec,
                  metadata,
                  id
                };
              }
              var currentCodecFull = pickMostCompleteCodecName(sbCodec, trackLevelCodec);
              var currentCodec = currentCodecFull == null ? void 0 : currentCodecFull.replace(VIDEO_CODEC_PROFILE_REPLACE, "$1");
              var trackCodec = pickMostCompleteCodecName(codec, levelCodec);
              var nextCodec = (_trackCodec = trackCodec) == null ? void 0 : _trackCodec.replace(VIDEO_CODEC_PROFILE_REPLACE, "$1");
              if (trackCodec && currentCodecFull && currentCodec !== nextCodec) {
                if (trackName.slice(0, 5) === "audio") {
                  trackCodec = getCodecCompatibleName(trackCodec, _this9.appendSource);
                }
                _this9.log("switching codec " + sbCodec + " to " + trackCodec);
                if (trackCodec !== (track.pendingCodec || track.codec)) {
                  track.pendingCodec = trackCodec;
                }
                track.container = container;
                _this9.appendChangeType(trackName, container, trackCodec);
              }
            });
            if (this.tracksReady || this.sourceBufferCount) {
              data.tracks = this.sourceBufferTracks;
            }
            if (this.sourceBufferCount) {
              return;
            }
            if (this.mediaSourceOpenOrEnded) {
              this.checkPendingTracks();
            }
          };
          _proto.appendChangeType = function appendChangeType(type, container, codec) {
            var _this10 = this;
            var mimeType = container + ";codecs=" + codec;
            var operation = {
              label: "change-type=" + mimeType,
              execute: function execute() {
                var track = _this10.tracks[type];
                if (track) {
                  var sb = track.buffer;
                  if (sb != null && sb.changeType) {
                    _this10.log("changing " + type + " sourceBuffer type to " + mimeType);
                    sb.changeType(mimeType);
                    track.codec = codec;
                    track.container = container;
                  }
                }
                _this10.shiftAndExecuteNext(type);
              },
              onStart: function onStart() {
              },
              onComplete: function onComplete() {
              },
              onError: function onError(error) {
                _this10.warn("Failed to change " + type + " SourceBuffer type", error);
              }
            };
            this.append(operation, type, this.isPending(this.tracks[type]));
          };
          _proto.blockAudio = function blockAudio(partOrFrag) {
            var _this$fragmentTracker, _this11 = this;
            var pStart = partOrFrag.start;
            var pTime = pStart + partOrFrag.duration * 0.05;
            var atGap = ((_this$fragmentTracker = this.fragmentTracker.getAppendedFrag(pStart, PlaylistLevelType.MAIN)) == null ? void 0 : _this$fragmentTracker.gap) === true;
            if (atGap) {
              return;
            }
            var op = {
              label: "block-audio",
              execute: function execute() {
                var _this11$fragmentTrack;
                var videoTrack = _this11.tracks.video;
                if (_this11.lastVideoAppendEnd > pTime || videoTrack != null && videoTrack.buffer && BufferHelper.isBuffered(videoTrack.buffer, pTime) || ((_this11$fragmentTrack = _this11.fragmentTracker.getAppendedFrag(pTime, PlaylistLevelType.MAIN)) == null ? void 0 : _this11$fragmentTrack.gap) === true) {
                  _this11.blockedAudioAppend = null;
                  _this11.shiftAndExecuteNext("audio");
                }
              },
              onStart: function onStart() {
              },
              onComplete: function onComplete() {
              },
              onError: function onError(error) {
                _this11.warn("Error executing block-audio operation", error);
              }
            };
            this.blockedAudioAppend = {
              op,
              frag: partOrFrag
            };
            this.append(op, "audio", true);
          };
          _proto.unblockAudio = function unblockAudio() {
            var blockedAudioAppend = this.blockedAudioAppend, operationQueue = this.operationQueue;
            if (blockedAudioAppend && operationQueue) {
              this.blockedAudioAppend = null;
              operationQueue.unblockAudio(blockedAudioAppend.op);
            }
          };
          _proto.onBufferAppending = function onBufferAppending(event, eventData) {
            var _this12 = this;
            var tracks = this.tracks;
            var data = eventData.data, type = eventData.type, parent = eventData.parent, frag = eventData.frag, part = eventData.part, chunkMeta = eventData.chunkMeta;
            var chunkStats = chunkMeta.buffering[type];
            var sn = frag.sn;
            var bufferAppendingStart = self.performance.now();
            chunkStats.start = bufferAppendingStart;
            var fragBuffering = frag.stats.buffering;
            var partBuffering = part ? part.stats.buffering : null;
            if (fragBuffering.start === 0) {
              fragBuffering.start = bufferAppendingStart;
            }
            if (partBuffering && partBuffering.start === 0) {
              partBuffering.start = bufferAppendingStart;
            }
            var audioTrack = tracks.audio;
            var checkTimestampOffset = false;
            if (type === "audio" && (audioTrack == null ? void 0 : audioTrack.container) === "audio/mpeg") {
              checkTimestampOffset = !this.lastMpegAudioChunk || chunkMeta.id === 1 || this.lastMpegAudioChunk.sn !== chunkMeta.sn;
              this.lastMpegAudioChunk = chunkMeta;
            }
            var videoTrack = this.tracks.video;
            var videoSb = videoTrack == null ? void 0 : videoTrack.buffer;
            if (videoSb && sn !== "initSegment") {
              var partOrFrag = part || frag;
              var blockedAudioAppend = this.blockedAudioAppend;
              if (type === "audio" && parent !== "main" && !this.blockedAudioAppend) {
                var pStart = partOrFrag.start;
                var pTime = pStart + partOrFrag.duration * 0.05;
                var vbuffered = videoSb.buffered;
                var vappending = this.currentOp("video");
                if (!vbuffered.length && !vappending) {
                  this.blockAudio(partOrFrag);
                } else if (!vappending && !BufferHelper.isBuffered(videoSb, pTime) && this.lastVideoAppendEnd < pTime) {
                  this.blockAudio(partOrFrag);
                }
              } else if (type === "video") {
                var videoAppendEnd = partOrFrag.end;
                if (blockedAudioAppend) {
                  var audioStart = blockedAudioAppend.frag.start;
                  if (videoAppendEnd > audioStart || videoAppendEnd < this.lastVideoAppendEnd || BufferHelper.isBuffered(videoSb, audioStart)) {
                    this.unblockAudio();
                  }
                }
                this.lastVideoAppendEnd = videoAppendEnd;
              }
            }
            var fragStart = (part || frag).start;
            var operation = {
              label: "append-" + type,
              execute: function execute() {
                chunkStats.executeStart = self.performance.now();
                if (checkTimestampOffset) {
                  var track = _this12.tracks[type];
                  if (track) {
                    var sb = track.buffer;
                    if (sb) {
                      var delta = fragStart - sb.timestampOffset;
                      if (Math.abs(delta) >= 0.1) {
                        _this12.log("Updating audio SourceBuffer timestampOffset to " + fragStart + " (delta: " + delta + ") sn: " + sn + ")");
                        sb.timestampOffset = fragStart;
                      }
                    }
                  }
                }
                _this12.appendExecutor(data, type);
              },
              onStart: function onStart() {
              },
              onComplete: function onComplete() {
                var end = self.performance.now();
                chunkStats.executeEnd = chunkStats.end = end;
                if (fragBuffering.first === 0) {
                  fragBuffering.first = end;
                }
                if (partBuffering && partBuffering.first === 0) {
                  partBuffering.first = end;
                }
                var timeRanges = {};
                _this12.sourceBuffers.forEach(function(_ref3) {
                  var type2 = _ref3[0], sb = _ref3[1];
                  if (type2) {
                    timeRanges[type2] = BufferHelper.getBuffered(sb);
                  }
                });
                _this12.appendErrors[type] = 0;
                if (type === "audio" || type === "video") {
                  _this12.appendErrors.audiovideo = 0;
                } else {
                  _this12.appendErrors.audio = 0;
                  _this12.appendErrors.video = 0;
                }
                _this12.hls.trigger(Events.BUFFER_APPENDED, {
                  type,
                  frag,
                  part,
                  chunkMeta,
                  parent: frag.type,
                  timeRanges
                });
              },
              onError: function onError(error) {
                var _this12$media;
                var event2 = {
                  type: ErrorTypes.MEDIA_ERROR,
                  parent: frag.type,
                  details: ErrorDetails.BUFFER_APPEND_ERROR,
                  sourceBufferName: type,
                  frag,
                  part,
                  chunkMeta,
                  error,
                  err: error,
                  fatal: false
                };
                if (error.code === DOMException.QUOTA_EXCEEDED_ERR) {
                  event2.details = ErrorDetails.BUFFER_FULL_ERROR;
                } else if (error.code === DOMException.INVALID_STATE_ERR && _this12.mediaSourceOpenOrEnded && !((_this12$media = _this12.media) != null && _this12$media.error)) {
                  event2.errorAction = createDoNothingErrorAction(true);
                } else if (error.name === TRACK_REMOVED_ERROR_NAME) {
                  if (_this12.sourceBufferCount === 0) {
                    event2.errorAction = createDoNothingErrorAction(true);
                  } else {
                    ++_this12.appendErrors[type];
                  }
                } else {
                  var appendErrorCount = ++_this12.appendErrors[type];
                  _this12.warn("Failed " + appendErrorCount + "/" + _this12.hls.config.appendErrorMaxRetry + ' times to append segment in "' + type + '" sourceBuffer');
                  if (appendErrorCount >= _this12.hls.config.appendErrorMaxRetry) {
                    event2.fatal = true;
                  }
                }
                _this12.hls.trigger(Events.ERROR, event2);
              }
            };
            this.append(operation, type, this.isPending(this.tracks[type]));
          };
          _proto.getFlushOp = function getFlushOp(type, start, end) {
            var _this13 = this;
            this.log('queuing "' + type + '" remove ' + start + "-" + end);
            return {
              label: "remove",
              execute: function execute() {
                _this13.removeExecutor(type, start, end);
              },
              onStart: function onStart() {
              },
              onComplete: function onComplete() {
                _this13.hls.trigger(Events.BUFFER_FLUSHED, {
                  type
                });
              },
              onError: function onError(error) {
                _this13.warn("Failed to remove " + start + "-" + end + ' from "' + type + '" SourceBuffer', error);
              }
            };
          };
          _proto.onBufferFlushing = function onBufferFlushing(event, data) {
            var _this14 = this;
            var type = data.type, startOffset = data.startOffset, endOffset = data.endOffset;
            if (type) {
              this.append(this.getFlushOp(type, startOffset, endOffset), type);
            } else {
              this.sourceBuffers.forEach(function(_ref4) {
                var type2 = _ref4[0];
                if (type2) {
                  _this14.append(_this14.getFlushOp(type2, startOffset, endOffset), type2);
                }
              });
            }
          };
          _proto.onFragParsed = function onFragParsed(event, data) {
            var _this15 = this;
            var frag = data.frag, part = data.part;
            var buffersAppendedTo = [];
            var elementaryStreams = part ? part.elementaryStreams : frag.elementaryStreams;
            if (elementaryStreams[ElementaryStreamTypes.AUDIOVIDEO]) {
              buffersAppendedTo.push("audiovideo");
            } else {
              if (elementaryStreams[ElementaryStreamTypes.AUDIO]) {
                buffersAppendedTo.push("audio");
              }
              if (elementaryStreams[ElementaryStreamTypes.VIDEO]) {
                buffersAppendedTo.push("video");
              }
            }
            var onUnblocked = function onUnblocked2() {
              var now2 = self.performance.now();
              frag.stats.buffering.end = now2;
              if (part) {
                part.stats.buffering.end = now2;
              }
              var stats = part ? part.stats : frag.stats;
              _this15.hls.trigger(Events.FRAG_BUFFERED, {
                frag,
                part,
                stats,
                id: frag.type
              });
            };
            if (buffersAppendedTo.length === 0) {
              this.warn("Fragments must have at least one ElementaryStreamType set. type: " + frag.type + " level: " + frag.level + " sn: " + frag.sn);
            }
            this.blockBuffers(onUnblocked, buffersAppendedTo);
          };
          _proto.onFragChanged = function onFragChanged(event, data) {
            this.trimBuffers();
          };
          _proto.onBufferEos = function onBufferEos(event, data) {
            var _this16 = this, _this$overrides;
            this.sourceBuffers.forEach(function(_ref5) {
              var type = _ref5[0];
              if (type) {
                var track = _this16.tracks[type];
                if (!data.type || data.type === type) {
                  track.ending = true;
                  if (!track.ended) {
                    track.ended = true;
                    _this16.log(type + " buffer reached EOS");
                  }
                }
              }
            });
            var allowEndOfStream = ((_this$overrides = this.overrides) == null ? void 0 : _this$overrides.endOfStream) !== false;
            var allTracksEnding = this.sourceBufferCount > 0 && !this.sourceBuffers.some(function(_ref6) {
              var _this16$tracks$type;
              var type = _ref6[0];
              return type && !((_this16$tracks$type = _this16.tracks[type]) != null && _this16$tracks$type.ended);
            });
            if (allTracksEnding) {
              if (allowEndOfStream) {
                this.log("Queueing EOS");
                this.blockUntilOpen(function() {
                  _this16.tracksEnded();
                  var mediaSource = _this16.mediaSource;
                  if (!mediaSource || mediaSource.readyState !== "open") {
                    if (mediaSource) {
                      _this16.log("Could not call mediaSource.endOfStream(). mediaSource.readyState: " + mediaSource.readyState);
                    }
                    return;
                  }
                  _this16.log("Calling mediaSource.endOfStream()");
                  mediaSource.endOfStream();
                  _this16.hls.trigger(Events.BUFFERED_TO_END, void 0);
                });
              } else {
                this.tracksEnded();
                this.hls.trigger(Events.BUFFERED_TO_END, void 0);
              }
            }
          };
          _proto.tracksEnded = function tracksEnded() {
            var _this17 = this;
            this.sourceBuffers.forEach(function(_ref7) {
              var type = _ref7[0];
              if (type !== null) {
                var track = _this17.tracks[type];
                if (track) {
                  track.ending = false;
                }
              }
            });
          };
          _proto.onLevelUpdated = function onLevelUpdated(event, _ref8) {
            var details = _ref8.details;
            if (!details.fragments.length) {
              return;
            }
            this.details = details;
            this.updateDuration();
          };
          _proto.updateDuration = function updateDuration() {
            var _this18 = this;
            var durationAndRange = this.getDurationAndRange();
            if (!durationAndRange) {
              return;
            }
            this.blockUntilOpen(function() {
              return _this18.updateMediaSource(durationAndRange);
            });
          };
          _proto.onError = function onError(event, data) {
            if (data.details === ErrorDetails.BUFFER_APPEND_ERROR && data.frag) {
              var _data$errorAction;
              var nextAutoLevel = (_data$errorAction = data.errorAction) == null ? void 0 : _data$errorAction.nextAutoLevel;
              if (isFiniteNumber(nextAutoLevel) && nextAutoLevel !== data.frag.level) {
                this.resetAppendErrors();
              }
            }
          };
          _proto.resetAppendErrors = function resetAppendErrors() {
            this.appendErrors = {
              audio: 0,
              video: 0,
              audiovideo: 0
            };
          };
          _proto.trimBuffers = function trimBuffers() {
            var hls = this.hls, details = this.details, media = this.media;
            if (!media || details === null) {
              return;
            }
            if (!this.sourceBufferCount) {
              return;
            }
            var config = hls.config;
            var currentTime = media.currentTime;
            var targetDuration = details.levelTargetDuration;
            var backBufferLength = details.live && config.liveBackBufferLength !== null ? config.liveBackBufferLength : config.backBufferLength;
            if (isFiniteNumber(backBufferLength) && backBufferLength >= 0) {
              var maxBackBufferLength = Math.max(backBufferLength, targetDuration);
              var targetBackBufferPosition = Math.floor(currentTime / targetDuration) * targetDuration - maxBackBufferLength;
              this.flushBackBuffer(currentTime, targetDuration, targetBackBufferPosition);
            }
            if (isFiniteNumber(config.frontBufferFlushThreshold) && config.frontBufferFlushThreshold > 0) {
              var frontBufferLength = Math.max(config.maxBufferLength, config.frontBufferFlushThreshold);
              var maxFrontBufferLength = Math.max(frontBufferLength, targetDuration);
              var targetFrontBufferPosition = Math.floor(currentTime / targetDuration) * targetDuration + maxFrontBufferLength;
              this.flushFrontBuffer(currentTime, targetDuration, targetFrontBufferPosition);
            }
          };
          _proto.flushBackBuffer = function flushBackBuffer(currentTime, targetDuration, targetBackBufferPosition) {
            var _this19 = this;
            this.sourceBuffers.forEach(function(_ref9) {
              var type = _ref9[0], sb = _ref9[1];
              if (sb) {
                var buffered = BufferHelper.getBuffered(sb);
                if (buffered.length > 0 && targetBackBufferPosition > buffered.start(0)) {
                  var _this19$details;
                  _this19.hls.trigger(Events.BACK_BUFFER_REACHED, {
                    bufferEnd: targetBackBufferPosition
                  });
                  var track = _this19.tracks[type];
                  if ((_this19$details = _this19.details) != null && _this19$details.live) {
                    _this19.hls.trigger(Events.LIVE_BACK_BUFFER_REACHED, {
                      bufferEnd: targetBackBufferPosition
                    });
                  } else if (track != null && track.ended) {
                    _this19.log("Cannot flush " + type + " back buffer while SourceBuffer is in ended state");
                    return;
                  }
                  _this19.hls.trigger(Events.BUFFER_FLUSHING, {
                    startOffset: 0,
                    endOffset: targetBackBufferPosition,
                    type
                  });
                }
              }
            });
          };
          _proto.flushFrontBuffer = function flushFrontBuffer(currentTime, targetDuration, targetFrontBufferPosition) {
            var _this20 = this;
            this.sourceBuffers.forEach(function(_ref10) {
              var type = _ref10[0], sb = _ref10[1];
              if (sb) {
                var buffered = BufferHelper.getBuffered(sb);
                var numBufferedRanges = buffered.length;
                if (numBufferedRanges < 2) {
                  return;
                }
                var bufferStart = buffered.start(numBufferedRanges - 1);
                var bufferEnd = buffered.end(numBufferedRanges - 1);
                if (targetFrontBufferPosition > bufferStart || currentTime >= bufferStart && currentTime <= bufferEnd) {
                  return;
                }
                _this20.hls.trigger(Events.BUFFER_FLUSHING, {
                  startOffset: bufferStart,
                  endOffset: Infinity,
                  type
                });
              }
            });
          };
          _proto.getDurationAndRange = function getDurationAndRange() {
            var _this$overrides2;
            var details = this.details, mediaSource = this.mediaSource;
            if (!details || !this.media || (mediaSource == null ? void 0 : mediaSource.readyState) !== "open") {
              return null;
            }
            var playlistEnd = details.edge;
            if (details.live && this.hls.config.liveDurationInfinity) {
              var len = details.fragments.length;
              if (len && details.live && !!mediaSource.setLiveSeekableRange) {
                var start = Math.max(0, details.fragmentStart);
                var end = Math.max(start, playlistEnd);
                return {
                  duration: Infinity,
                  start,
                  end
                };
              }
              return {
                duration: Infinity
              };
            }
            var overrideDuration = (_this$overrides2 = this.overrides) == null ? void 0 : _this$overrides2.duration;
            if (overrideDuration) {
              if (!isFiniteNumber(overrideDuration)) {
                return null;
              }
              return {
                duration: overrideDuration
              };
            }
            var mediaDuration = this.media.duration;
            var msDuration = isFiniteNumber(mediaSource.duration) ? mediaSource.duration : 0;
            if (playlistEnd > msDuration && playlistEnd > mediaDuration || !isFiniteNumber(mediaDuration)) {
              return {
                duration: playlistEnd
              };
            }
            return null;
          };
          _proto.updateMediaSource = function updateMediaSource(_ref11) {
            var duration = _ref11.duration, start = _ref11.start, end = _ref11.end;
            var mediaSource = this.mediaSource;
            if (!this.media || !mediaSource || mediaSource.readyState !== "open") {
              return;
            }
            if (mediaSource.duration !== duration) {
              if (isFiniteNumber(duration)) {
                this.log("Updating MediaSource duration to " + duration.toFixed(3));
              }
              mediaSource.duration = duration;
            }
            if (start !== void 0 && end !== void 0) {
              this.log("MediaSource duration is set to " + mediaSource.duration + ". Setting seekable range to " + start + "-" + end + ".");
              mediaSource.setLiveSeekableRange(start, end);
            }
          };
          _proto.checkPendingTracks = function checkPendingTracks() {
            var bufferCodecEventsTotal = this.bufferCodecEventsTotal, pendingTrackCount = this.pendingTrackCount, tracks = this.tracks;
            this.log("checkPendingTracks (pending: " + pendingTrackCount + " codec events expected: " + bufferCodecEventsTotal + ") " + stringify2(tracks));
            if (this.tracksReady) {
              var _this$transferData3;
              var transferredTracks = (_this$transferData3 = this.transferData) == null ? void 0 : _this$transferData3.tracks;
              if (transferredTracks && Object.keys(transferredTracks).length) {
                this.attachTransferred();
              } else {
                this.createSourceBuffers();
              }
            }
          };
          _proto.bufferCreated = function bufferCreated() {
            var _this21 = this;
            if (this.sourceBufferCount) {
              var tracks = {};
              this.sourceBuffers.forEach(function(_ref12) {
                var type = _ref12[0], buffer = _ref12[1];
                if (type) {
                  var track = _this21.tracks[type];
                  tracks[type] = {
                    buffer,
                    container: track.container,
                    codec: track.codec,
                    supplemental: track.supplemental,
                    levelCodec: track.levelCodec,
                    id: track.id,
                    metadata: track.metadata
                  };
                }
              });
              this.hls.trigger(Events.BUFFER_CREATED, {
                tracks
              });
              this.log("SourceBuffers created. Running queue: " + this.operationQueue);
              this.sourceBuffers.forEach(function(_ref13) {
                var type = _ref13[0];
                _this21.executeNext(type);
              });
            } else {
              var error = new Error("could not create source buffer for media codec(s)");
              this.hls.trigger(Events.ERROR, {
                type: ErrorTypes.MEDIA_ERROR,
                details: ErrorDetails.BUFFER_INCOMPATIBLE_CODECS_ERROR,
                fatal: true,
                error,
                reason: error.message
              });
            }
          };
          _proto.createSourceBuffers = function createSourceBuffers() {
            var tracks = this.tracks, sourceBuffers = this.sourceBuffers, mediaSource = this.mediaSource;
            if (!mediaSource) {
              throw new Error("createSourceBuffers called when mediaSource was null");
            }
            for (var trackName in tracks) {
              var type = trackName;
              var track = tracks[type];
              if (this.isPending(track)) {
                var codec = this.getTrackCodec(track, type);
                var mimeType = track.container + ";codecs=" + codec;
                track.codec = codec;
                this.log("creating sourceBuffer(" + mimeType + ")" + (this.currentOp(type) ? " Queued" : "") + " " + stringify2(track));
                try {
                  var sb = mediaSource.addSourceBuffer(mimeType);
                  var sbIndex = sourceBufferNameToIndex(type);
                  var sbTuple = [type, sb];
                  sourceBuffers[sbIndex] = sbTuple;
                  track.buffer = sb;
                } catch (error) {
                  var _this$operationQueue;
                  this.error("error while trying to add sourceBuffer: " + error.message);
                  this.shiftAndExecuteNext(type);
                  (_this$operationQueue = this.operationQueue) == null ? void 0 : _this$operationQueue.removeBlockers();
                  delete this.tracks[type];
                  this.hls.trigger(Events.ERROR, {
                    type: ErrorTypes.MEDIA_ERROR,
                    details: ErrorDetails.BUFFER_ADD_CODEC_ERROR,
                    fatal: false,
                    error,
                    sourceBufferName: type,
                    mimeType,
                    parent: track.id
                  });
                  return;
                }
                this.trackSourceBuffer(type, track);
              }
            }
            this.bufferCreated();
          };
          _proto.getTrackCodec = function getTrackCodec(track, trackName) {
            var supplementalCodec = track.supplemental;
            var trackCodec = track.codec;
            if (supplementalCodec && (trackName === "video" || trackName === "audiovideo") && areCodecsMediaSourceSupported(supplementalCodec, "video")) {
              trackCodec = replaceVideoCodec(trackCodec, supplementalCodec);
            }
            var codec = pickMostCompleteCodecName(trackCodec, track.levelCodec);
            if (codec) {
              if (trackName.slice(0, 5) === "audio") {
                return getCodecCompatibleName(codec, this.appendSource);
              }
              return codec;
            }
            return "";
          };
          _proto.trackSourceBuffer = function trackSourceBuffer(type, track) {
            var _this22 = this;
            var buffer = track.buffer;
            if (!buffer) {
              return;
            }
            var codec = this.getTrackCodec(track, type);
            this.tracks[type] = {
              buffer,
              codec,
              container: track.container,
              levelCodec: track.levelCodec,
              supplemental: track.supplemental,
              metadata: track.metadata,
              id: track.id,
              listeners: []
            };
            this.removeBufferListeners(type);
            this.addBufferListener(type, "updatestart", this.onSBUpdateStart);
            this.addBufferListener(type, "updateend", this.onSBUpdateEnd);
            this.addBufferListener(type, "error", this.onSBUpdateError);
            if (this.appendSource) {
              this.addBufferListener(type, "bufferedchange", function(type2, event) {
                var removedRanges = event.removedRanges;
                if (removedRanges != null && removedRanges.length) {
                  _this22.hls.trigger(Events.BUFFER_FLUSHED, {
                    type: type2
                  });
                }
              });
            }
          };
          _proto.onSBUpdateStart = function onSBUpdateStart(type) {
            var operation = this.currentOp(type);
            if (!operation) {
              return;
            }
            operation.onStart();
          };
          _proto.onSBUpdateEnd = function onSBUpdateEnd(type) {
            var _this$mediaSource2;
            if (((_this$mediaSource2 = this.mediaSource) == null ? void 0 : _this$mediaSource2.readyState) === "closed") {
              this.resetBuffer(type);
              return;
            }
            var operation = this.currentOp(type);
            if (!operation) {
              return;
            }
            operation.onComplete();
            this.shiftAndExecuteNext(type);
          };
          _proto.onSBUpdateError = function onSBUpdateError(type, event) {
            var _this$mediaSource3;
            var error = new Error(type + " SourceBuffer error. MediaSource readyState: " + ((_this$mediaSource3 = this.mediaSource) == null ? void 0 : _this$mediaSource3.readyState));
            this.error("" + error, event);
            this.hls.trigger(Events.ERROR, {
              type: ErrorTypes.MEDIA_ERROR,
              details: ErrorDetails.BUFFER_APPENDING_ERROR,
              sourceBufferName: type,
              error,
              fatal: false
            });
            var operation = this.currentOp(type);
            if (operation) {
              operation.onError(error);
            }
          };
          _proto.removeExecutor = function removeExecutor(type, startOffset, endOffset) {
            var media = this.media, mediaSource = this.mediaSource;
            var track = this.tracks[type];
            var sb = track == null ? void 0 : track.buffer;
            if (!media || !mediaSource || !sb) {
              this.warn("Attempting to remove from the " + type + " SourceBuffer, but it does not exist");
              this.shiftAndExecuteNext(type);
              return;
            }
            var mediaDuration = isFiniteNumber(media.duration) ? media.duration : Infinity;
            var msDuration = isFiniteNumber(mediaSource.duration) ? mediaSource.duration : Infinity;
            var removeStart = Math.max(0, startOffset);
            var removeEnd = Math.min(endOffset, mediaDuration, msDuration);
            if (removeEnd > removeStart && (!track.ending || track.ended)) {
              track.ended = false;
              this.log("Removing [" + removeStart + "," + removeEnd + "] from the " + type + " SourceBuffer");
              sb.remove(removeStart, removeEnd);
            } else {
              this.shiftAndExecuteNext(type);
            }
          };
          _proto.appendExecutor = function appendExecutor(data, type) {
            var track = this.tracks[type];
            var sb = track == null ? void 0 : track.buffer;
            if (!sb) {
              throw new HlsJsTrackRemovedError("Attempting to append to the " + type + " SourceBuffer, but it does not exist");
            }
            track.ending = false;
            track.ended = false;
            sb.appendBuffer(data);
          };
          _proto.blockUntilOpen = function blockUntilOpen(callback) {
            if (this.isUpdating() || this.isQueued()) {
              this.blockBuffers(callback);
            } else {
              callback();
            }
          };
          _proto.isUpdating = function isUpdating() {
            return this.sourceBuffers.some(function(_ref14) {
              var type = _ref14[0], sb = _ref14[1];
              return type && sb.updating;
            });
          };
          _proto.isQueued = function isQueued() {
            var _this23 = this;
            return this.sourceBuffers.some(function(_ref15) {
              var type = _ref15[0];
              return type && !!_this23.currentOp(type);
            });
          };
          _proto.isPending = function isPending(track) {
            return !!track && !track.buffer;
          };
          _proto.blockBuffers = function blockBuffers(onUnblocked, bufferNames) {
            var _this24 = this;
            if (bufferNames === void 0) {
              bufferNames = this.sourceBufferTypes;
            }
            if (!bufferNames.length) {
              this.log("Blocking operation requested, but no SourceBuffers exist");
              Promise.resolve().then(onUnblocked);
              return;
            }
            var operationQueue = this.operationQueue;
            var blockingOperations = bufferNames.map(function(type) {
              return _this24.appendBlocker(type);
            });
            var audioBlocked = bufferNames.length > 1 && !!this.blockedAudioAppend;
            if (audioBlocked) {
              this.unblockAudio();
            }
            Promise.all(blockingOperations).then(function(result) {
              if (operationQueue !== _this24.operationQueue) {
                return;
              }
              onUnblocked();
              _this24.stepOperationQueue(bufferNames);
            });
          };
          _proto.stepOperationQueue = function stepOperationQueue(bufferNames) {
            var _this25 = this;
            bufferNames.forEach(function(type) {
              var _this25$tracks$type;
              var sb = (_this25$tracks$type = _this25.tracks[type]) == null ? void 0 : _this25$tracks$type.buffer;
              if (!sb || sb.updating) {
                return;
              }
              _this25.shiftAndExecuteNext(type);
            });
          };
          _proto.append = function append(operation, type, pending) {
            if (this.operationQueue) {
              this.operationQueue.append(operation, type, pending);
            }
          };
          _proto.appendBlocker = function appendBlocker(type) {
            if (this.operationQueue) {
              return this.operationQueue.appendBlocker(type);
            }
          };
          _proto.currentOp = function currentOp(type) {
            if (this.operationQueue) {
              return this.operationQueue.current(type);
            }
            return null;
          };
          _proto.executeNext = function executeNext(type) {
            if (type && this.operationQueue) {
              this.operationQueue.executeNext(type);
            }
          };
          _proto.shiftAndExecuteNext = function shiftAndExecuteNext(type) {
            if (this.operationQueue) {
              this.operationQueue.shiftAndExecuteNext(type);
            }
          };
          _proto.addBufferListener = function addBufferListener(type, event, fn) {
            var track = this.tracks[type];
            if (!track) {
              return;
            }
            var buffer = track.buffer;
            if (!buffer) {
              return;
            }
            var listener = fn.bind(this, type);
            track.listeners.push({
              event,
              listener
            });
            buffer.addEventListener(event, listener);
          };
          _proto.removeBufferListeners = function removeBufferListeners(type) {
            var track = this.tracks[type];
            if (!track) {
              return;
            }
            var buffer = track.buffer;
            if (!buffer) {
              return;
            }
            track.listeners.forEach(function(l) {
              buffer.removeEventListener(l.event, l.listener);
            });
            track.listeners.length = 0;
          };
          return _createClass4(BufferController2, [{
            key: "mediaSourceOpenOrEnded",
            get: function get() {
              var _this$mediaSource4;
              var readyState = (_this$mediaSource4 = this.mediaSource) == null ? void 0 : _this$mediaSource4.readyState;
              return readyState === "open" || readyState === "ended";
            }
          }, {
            key: "sourceBufferTracks",
            get: function get() {
              var _this26 = this;
              return Object.keys(this.tracks).reduce(function(baseTracks, type) {
                var track = _this26.tracks[type];
                baseTracks[type] = {
                  id: track.id,
                  container: track.container,
                  codec: track.codec,
                  levelCodec: track.levelCodec
                };
                return baseTracks;
              }, {});
            }
          }, {
            key: "bufferedToEnd",
            get: function get() {
              var _this27 = this;
              return this.sourceBufferCount > 0 && !this.sourceBuffers.some(function(_ref16) {
                var _this27$tracks$type, _this27$tracks$type2;
                var type = _ref16[0];
                return type && (!((_this27$tracks$type = _this27.tracks[type]) != null && _this27$tracks$type.ended) || ((_this27$tracks$type2 = _this27.tracks[type]) == null ? void 0 : _this27$tracks$type2.ending));
              });
            }
          }, {
            key: "tracksReady",
            get: function get() {
              var pendingTrackCount = this.pendingTrackCount;
              return pendingTrackCount > 0 && (pendingTrackCount >= this.bufferCodecEventsTotal || this.isPending(this.tracks.audiovideo));
            }
          }, {
            key: "mediaSrc",
            get: function get() {
              var _this$media, _this$media$querySele;
              var media = ((_this$media = this.media) == null ? void 0 : (_this$media$querySele = _this$media.querySelector) == null ? void 0 : _this$media$querySele.call(_this$media, "source")) || this.media;
              return media == null ? void 0 : media.src;
            }
          }, {
            key: "pendingTrackCount",
            get: function get() {
              var _this28 = this;
              return Object.keys(this.tracks).reduce(function(acc, type) {
                return acc + (_this28.isPending(_this28.tracks[type]) ? 1 : 0);
              }, 0);
            }
          }, {
            key: "sourceBufferCount",
            get: function get() {
              return this.sourceBuffers.reduce(function(acc, _ref17) {
                var type = _ref17[0];
                return acc + (type ? 1 : 0);
              }, 0);
            }
          }, {
            key: "sourceBufferTypes",
            get: function get() {
              return this.sourceBuffers.map(function(_ref18) {
                var type = _ref18[0];
                return type;
              }).filter(function(type) {
                return !!type;
              });
            }
          }]);
        }(Logger4);
        function removeSourceChildren(node) {
          var sourceChildren = node.querySelectorAll("source");
          [].slice.call(sourceChildren).forEach(function(source) {
            node.removeChild(source);
          });
        }
        function addSource(media, url) {
          var source = self.document.createElement("source");
          source.type = "video/mp4";
          source.src = url;
          media.appendChild(source);
        }
        function sourceBufferNameToIndex(type) {
          return type === "audio" ? 1 : 0;
        }
        var CapLevelController = /* @__PURE__ */ function() {
          function CapLevelController2(hls) {
            this.hls = void 0;
            this.autoLevelCapping = void 0;
            this.firstLevel = void 0;
            this.media = void 0;
            this.restrictedLevels = void 0;
            this.timer = void 0;
            this.clientRect = void 0;
            this.streamController = void 0;
            this.hls = hls;
            this.autoLevelCapping = Number.POSITIVE_INFINITY;
            this.firstLevel = -1;
            this.media = null;
            this.restrictedLevels = [];
            this.timer = void 0;
            this.clientRect = null;
            this.registerListeners();
          }
          var _proto = CapLevelController2.prototype;
          _proto.setStreamController = function setStreamController(streamController) {
            this.streamController = streamController;
          };
          _proto.destroy = function destroy() {
            if (this.hls) {
              this.unregisterListener();
            }
            if (this.timer) {
              this.stopCapping();
            }
            this.media = null;
            this.clientRect = null;
            this.hls = this.streamController = null;
          };
          _proto.registerListeners = function registerListeners() {
            var hls = this.hls;
            hls.on(Events.FPS_DROP_LEVEL_CAPPING, this.onFpsDropLevelCapping, this);
            hls.on(Events.MEDIA_ATTACHING, this.onMediaAttaching, this);
            hls.on(Events.MANIFEST_PARSED, this.onManifestParsed, this);
            hls.on(Events.LEVELS_UPDATED, this.onLevelsUpdated, this);
            hls.on(Events.BUFFER_CODECS, this.onBufferCodecs, this);
            hls.on(Events.MEDIA_DETACHING, this.onMediaDetaching, this);
          };
          _proto.unregisterListener = function unregisterListener() {
            var hls = this.hls;
            hls.off(Events.FPS_DROP_LEVEL_CAPPING, this.onFpsDropLevelCapping, this);
            hls.off(Events.MEDIA_ATTACHING, this.onMediaAttaching, this);
            hls.off(Events.MANIFEST_PARSED, this.onManifestParsed, this);
            hls.off(Events.LEVELS_UPDATED, this.onLevelsUpdated, this);
            hls.off(Events.BUFFER_CODECS, this.onBufferCodecs, this);
            hls.off(Events.MEDIA_DETACHING, this.onMediaDetaching, this);
          };
          _proto.onFpsDropLevelCapping = function onFpsDropLevelCapping(event, data) {
            var level = this.hls.levels[data.droppedLevel];
            if (this.isLevelAllowed(level)) {
              this.restrictedLevels.push({
                bitrate: level.bitrate,
                height: level.height,
                width: level.width
              });
            }
          };
          _proto.onMediaAttaching = function onMediaAttaching(event, data) {
            this.media = data.media instanceof HTMLVideoElement ? data.media : null;
            this.clientRect = null;
            if (this.timer && this.hls.levels.length) {
              this.detectPlayerSize();
            }
          };
          _proto.onManifestParsed = function onManifestParsed(event, data) {
            var hls = this.hls;
            this.restrictedLevels = [];
            this.firstLevel = data.firstLevel;
            if (hls.config.capLevelToPlayerSize && data.video) {
              this.startCapping();
            }
          };
          _proto.onLevelsUpdated = function onLevelsUpdated(event, data) {
            if (this.timer && isFiniteNumber(this.autoLevelCapping)) {
              this.detectPlayerSize();
            }
          };
          _proto.onBufferCodecs = function onBufferCodecs(event, data) {
            var hls = this.hls;
            if (hls.config.capLevelToPlayerSize && data.video) {
              this.startCapping();
            }
          };
          _proto.onMediaDetaching = function onMediaDetaching() {
            this.stopCapping();
            this.media = null;
          };
          _proto.detectPlayerSize = function detectPlayerSize() {
            if (this.media) {
              if (this.mediaHeight <= 0 || this.mediaWidth <= 0) {
                this.clientRect = null;
                return;
              }
              var levels = this.hls.levels;
              if (levels.length) {
                var hls = this.hls;
                var maxLevel = this.getMaxLevel(levels.length - 1);
                if (maxLevel !== this.autoLevelCapping) {
                  hls.logger.log("Setting autoLevelCapping to " + maxLevel + ": " + levels[maxLevel].height + "p@" + levels[maxLevel].bitrate + " for media " + this.mediaWidth + "x" + this.mediaHeight);
                }
                hls.autoLevelCapping = maxLevel;
                if (hls.autoLevelEnabled && hls.autoLevelCapping > this.autoLevelCapping && this.streamController) {
                  this.streamController.nextLevelSwitch();
                }
                this.autoLevelCapping = hls.autoLevelCapping;
              }
            }
          };
          _proto.getMaxLevel = function getMaxLevel(capLevelIndex) {
            var _this = this;
            var levels = this.hls.levels;
            if (!levels.length) {
              return -1;
            }
            var validLevels = levels.filter(function(level, index) {
              return _this.isLevelAllowed(level) && index <= capLevelIndex;
            });
            this.clientRect = null;
            return CapLevelController2.getMaxLevelByMediaSize(validLevels, this.mediaWidth, this.mediaHeight);
          };
          _proto.startCapping = function startCapping() {
            if (this.timer) {
              return;
            }
            this.autoLevelCapping = Number.POSITIVE_INFINITY;
            self.clearInterval(this.timer);
            this.timer = self.setInterval(this.detectPlayerSize.bind(this), 1e3);
            this.detectPlayerSize();
          };
          _proto.stopCapping = function stopCapping() {
            this.restrictedLevels = [];
            this.firstLevel = -1;
            this.autoLevelCapping = Number.POSITIVE_INFINITY;
            if (this.timer) {
              self.clearInterval(this.timer);
              this.timer = void 0;
            }
          };
          _proto.getDimensions = function getDimensions() {
            if (this.clientRect) {
              return this.clientRect;
            }
            var media = this.media;
            var boundsRect = {
              width: 0,
              height: 0
            };
            if (media) {
              var clientRect = media.getBoundingClientRect();
              boundsRect.width = clientRect.width;
              boundsRect.height = clientRect.height;
              if (!boundsRect.width && !boundsRect.height) {
                boundsRect.width = clientRect.right - clientRect.left || media.width || 0;
                boundsRect.height = clientRect.bottom - clientRect.top || media.height || 0;
              }
            }
            this.clientRect = boundsRect;
            return boundsRect;
          };
          _proto.isLevelAllowed = function isLevelAllowed(level) {
            var restrictedLevels = this.restrictedLevels;
            return !restrictedLevels.some(function(restrictedLevel) {
              return level.bitrate === restrictedLevel.bitrate && level.width === restrictedLevel.width && level.height === restrictedLevel.height;
            });
          };
          CapLevelController2.getMaxLevelByMediaSize = function getMaxLevelByMediaSize(levels, width, height) {
            if (!(levels != null && levels.length)) {
              return -1;
            }
            var atGreatestBandwidth = function atGreatestBandwidth2(curLevel, nextLevel) {
              if (!nextLevel) {
                return true;
              }
              return curLevel.width !== nextLevel.width || curLevel.height !== nextLevel.height;
            };
            var maxLevelIndex = levels.length - 1;
            var squareSize = Math.max(width, height);
            for (var i = 0; i < levels.length; i += 1) {
              var level = levels[i];
              if ((level.width >= squareSize || level.height >= squareSize) && atGreatestBandwidth(level, levels[i + 1])) {
                maxLevelIndex = i;
                break;
              }
            }
            return maxLevelIndex;
          };
          return _createClass4(CapLevelController2, [{
            key: "mediaWidth",
            get: function get() {
              return this.getDimensions().width * this.contentScaleFactor;
            }
          }, {
            key: "mediaHeight",
            get: function get() {
              return this.getDimensions().height * this.contentScaleFactor;
            }
          }, {
            key: "contentScaleFactor",
            get: function get() {
              var pixelRatio = 1;
              if (!this.hls.config.ignoreDevicePixelRatio) {
                try {
                  pixelRatio = self.devicePixelRatio;
                } catch (e) {
                }
              }
              return Math.min(pixelRatio, this.hls.config.maxDevicePixelRatio);
            }
          }]);
        }();
        var DECIMAL_RESOLUTION_REGEX = /^(\d+)x(\d+)$/;
        var ATTR_LIST_REGEX = /(.+?)=(".*?"|.*?)(?:,|$)/g;
        var AttrList = /* @__PURE__ */ function() {
          function AttrList2(attrs, parsed) {
            if (typeof attrs === "string") {
              attrs = AttrList2.parseAttrList(attrs, parsed);
            }
            _extends(this, attrs);
          }
          var _proto = AttrList2.prototype;
          _proto.decimalInteger = function decimalInteger(attrName) {
            var intValue = parseInt(this[attrName], 10);
            if (intValue > Number.MAX_SAFE_INTEGER) {
              return Infinity;
            }
            return intValue;
          };
          _proto.hexadecimalInteger = function hexadecimalInteger(attrName) {
            if (this[attrName]) {
              var stringValue = (this[attrName] || "0x").slice(2);
              stringValue = (stringValue.length & 1 ? "0" : "") + stringValue;
              var value = new Uint8Array(stringValue.length / 2);
              for (var i = 0; i < stringValue.length / 2; i++) {
                value[i] = parseInt(stringValue.slice(i * 2, i * 2 + 2), 16);
              }
              return value;
            }
            return null;
          };
          _proto.hexadecimalIntegerAsNumber = function hexadecimalIntegerAsNumber(attrName) {
            var intValue = parseInt(this[attrName], 16);
            if (intValue > Number.MAX_SAFE_INTEGER) {
              return Infinity;
            }
            return intValue;
          };
          _proto.decimalFloatingPoint = function decimalFloatingPoint(attrName) {
            return parseFloat(this[attrName]);
          };
          _proto.optionalFloat = function optionalFloat(attrName, defaultValue) {
            var value = this[attrName];
            return value ? parseFloat(value) : defaultValue;
          };
          _proto.enumeratedString = function enumeratedString(attrName) {
            return this[attrName];
          };
          _proto.enumeratedStringList = function enumeratedStringList(attrName, dict) {
            var attrValue = this[attrName];
            return (attrValue ? attrValue.split(/[ ,]+/) : []).reduce(function(result, identifier) {
              result[identifier.toLowerCase()] = true;
              return result;
            }, dict);
          };
          _proto.bool = function bool(attrName) {
            return this[attrName] === "YES";
          };
          _proto.decimalResolution = function decimalResolution(attrName) {
            var res = DECIMAL_RESOLUTION_REGEX.exec(this[attrName]);
            if (res === null) {
              return void 0;
            }
            return {
              width: parseInt(res[1], 10),
              height: parseInt(res[2], 10)
            };
          };
          AttrList2.parseAttrList = function parseAttrList(input, parsed) {
            var match;
            var attrs = {};
            var quote = '"';
            ATTR_LIST_REGEX.lastIndex = 0;
            while ((match = ATTR_LIST_REGEX.exec(input)) !== null) {
              var name = match[1].trim();
              var value = match[2];
              var quotedString = value.indexOf(quote) === 0 && value.lastIndexOf(quote) === value.length - 1;
              var hexadecimalSequence = false;
              if (quotedString) {
                value = value.slice(1, -1);
              } else {
                switch (name) {
                  case "IV":
                  case "SCTE35-CMD":
                  case "SCTE35-IN":
                  case "SCTE35-OUT":
                    hexadecimalSequence = true;
                }
              }
              if (parsed && (quotedString || hexadecimalSequence)) ;
              else if (!hexadecimalSequence && !quotedString) {
                switch (name) {
                  case "CLOSED-CAPTIONS":
                    if (value === "NONE") {
                      break;
                    }
                  // falls through
                  case "ALLOWED-CPC":
                  case "CLASS":
                  case "ASSOC-LANGUAGE":
                  case "AUDIO":
                  case "BYTERANGE":
                  case "CHANNELS":
                  case "CHARACTERISTICS":
                  case "CODECS":
                  case "DATA-ID":
                  case "END-DATE":
                  case "GROUP-ID":
                  case "ID":
                  case "IMPORT":
                  case "INSTREAM-ID":
                  case "KEYFORMAT":
                  case "KEYFORMATVERSIONS":
                  case "LANGUAGE":
                  case "NAME":
                  case "PATHWAY-ID":
                  case "QUERYPARAM":
                  case "RECENTLY-REMOVED-DATERANGES":
                  case "SERVER-URI":
                  case "STABLE-RENDITION-ID":
                  case "STABLE-VARIANT-ID":
                  case "START-DATE":
                  case "SUBTITLES":
                  case "SUPPLEMENTAL-CODECS":
                  case "URI":
                  case "VALUE":
                  case "VIDEO":
                  case "X-ASSET-LIST":
                  case "X-ASSET-URI":
                    logger4.warn(input + ": attribute " + name + " is missing quotes");
                }
              }
              attrs[name] = value;
            }
            return attrs;
          };
          return _createClass4(AttrList2, [{
            key: "clientAttrs",
            get: function get() {
              return Object.keys(this).filter(function(attr) {
                return attr.substring(0, 2) === "X-";
              });
            }
          }]);
        }();
        var CLASS_INTERSTITIAL = "com.apple.hls.interstitial";
        function isDateRangeCueAttribute(attrName) {
          return attrName !== "ID" && attrName !== "CLASS" && attrName !== "CUE" && attrName !== "START-DATE" && attrName !== "DURATION" && attrName !== "END-DATE" && attrName !== "END-ON-NEXT";
        }
        function isSCTE35Attribute(attrName) {
          return attrName === "SCTE35-OUT" || attrName === "SCTE35-IN" || attrName === "SCTE35-CMD";
        }
        var DateRange = /* @__PURE__ */ function() {
          function DateRange2(dateRangeAttr, dateRangeWithSameId, tagCount) {
            var _dateRangeWithSameId$;
            if (tagCount === void 0) {
              tagCount = 0;
            }
            this.attr = void 0;
            this.tagAnchor = void 0;
            this.tagOrder = void 0;
            this._startDate = void 0;
            this._endDate = void 0;
            this._dateAtEnd = void 0;
            this._cue = void 0;
            this._badValueForSameId = void 0;
            this.tagAnchor = (dateRangeWithSameId == null ? void 0 : dateRangeWithSameId.tagAnchor) || null;
            this.tagOrder = (_dateRangeWithSameId$ = dateRangeWithSameId == null ? void 0 : dateRangeWithSameId.tagOrder) != null ? _dateRangeWithSameId$ : tagCount;
            if (dateRangeWithSameId) {
              var previousAttr = dateRangeWithSameId.attr;
              for (var key in previousAttr) {
                if (Object.prototype.hasOwnProperty.call(dateRangeAttr, key) && dateRangeAttr[key] !== previousAttr[key]) {
                  logger4.warn('DATERANGE tag attribute: "' + key + '" does not match for tags with ID: "' + dateRangeAttr.ID + '"');
                  this._badValueForSameId = key;
                  break;
                }
              }
              dateRangeAttr = _extends(new AttrList({}), previousAttr, dateRangeAttr);
            }
            this.attr = dateRangeAttr;
            if (dateRangeWithSameId) {
              this._startDate = dateRangeWithSameId._startDate;
              this._cue = dateRangeWithSameId._cue;
              this._endDate = dateRangeWithSameId._endDate;
              this._dateAtEnd = dateRangeWithSameId._dateAtEnd;
            } else {
              this._startDate = new Date(dateRangeAttr["START-DATE"]);
            }
            if ("END-DATE" in this.attr) {
              var endDate = (dateRangeWithSameId == null ? void 0 : dateRangeWithSameId.endDate) || new Date(this.attr["END-DATE"]);
              if (isFiniteNumber(endDate.getTime())) {
                this._endDate = endDate;
              }
            }
          }
          return _createClass4(DateRange2, [{
            key: "id",
            get: function get() {
              return this.attr.ID;
            }
          }, {
            key: "class",
            get: function get() {
              return this.attr.CLASS;
            }
          }, {
            key: "cue",
            get: function get() {
              var _cue = this._cue;
              if (_cue === void 0) {
                return this._cue = this.attr.enumeratedStringList(this.attr.CUE ? "CUE" : "X-CUE", {
                  pre: false,
                  post: false,
                  once: false
                });
              }
              return _cue;
            }
          }, {
            key: "startTime",
            get: function get() {
              var tagAnchor = this.tagAnchor;
              if (tagAnchor === null || tagAnchor.programDateTime === null) {
                logger4.warn('Expected tagAnchor Fragment with PDT set for DateRange "' + this.id + '": ' + tagAnchor);
                return NaN;
              }
              return tagAnchor.start + (this.startDate.getTime() - tagAnchor.programDateTime) / 1e3;
            }
          }, {
            key: "startDate",
            get: function get() {
              return this._startDate;
            }
          }, {
            key: "endDate",
            get: function get() {
              var dateAtEnd = this._endDate || this._dateAtEnd;
              if (dateAtEnd) {
                return dateAtEnd;
              }
              var duration = this.duration;
              if (duration !== null) {
                return this._dateAtEnd = new Date(this._startDate.getTime() + duration * 1e3);
              }
              return null;
            }
          }, {
            key: "duration",
            get: function get() {
              if ("DURATION" in this.attr) {
                var duration = this.attr.decimalFloatingPoint("DURATION");
                if (isFiniteNumber(duration)) {
                  return duration;
                }
              } else if (this._endDate) {
                return (this._endDate.getTime() - this._startDate.getTime()) / 1e3;
              }
              return null;
            }
          }, {
            key: "plannedDuration",
            get: function get() {
              if ("PLANNED-DURATION" in this.attr) {
                return this.attr.decimalFloatingPoint("PLANNED-DURATION");
              }
              return null;
            }
          }, {
            key: "endOnNext",
            get: function get() {
              return this.attr.bool("END-ON-NEXT");
            }
          }, {
            key: "isInterstitial",
            get: function get() {
              return this.class === CLASS_INTERSTITIAL;
            }
          }, {
            key: "isValid",
            get: function get() {
              return !!this.id && !this._badValueForSameId && isFiniteNumber(this.startDate.getTime()) && (this.duration === null || this.duration >= 0) && (!this.endOnNext || !!this.class) && (!this.attr.CUE || !this.cue.pre && !this.cue.post || this.cue.pre !== this.cue.post) && (!this.isInterstitial || "X-ASSET-URI" in this.attr || "X-ASSET-LIST" in this.attr);
            }
          }]);
        }();
        var DEFAULT_TARGET_DURATION = 10;
        var LevelDetails = /* @__PURE__ */ function() {
          function LevelDetails2(baseUrl) {
            this.PTSKnown = false;
            this.alignedSliding = false;
            this.averagetargetduration = void 0;
            this.endCC = 0;
            this.endSN = 0;
            this.fragments = void 0;
            this.fragmentHint = void 0;
            this.partList = null;
            this.dateRanges = void 0;
            this.dateRangeTagCount = 0;
            this.live = true;
            this.requestScheduled = -1;
            this.ageHeader = 0;
            this.advancedDateTime = void 0;
            this.updated = true;
            this.advanced = true;
            this.misses = 0;
            this.startCC = 0;
            this.startSN = 0;
            this.startTimeOffset = null;
            this.targetduration = 0;
            this.totalduration = 0;
            this.type = null;
            this.url = void 0;
            this.m3u8 = "";
            this.version = null;
            this.canBlockReload = false;
            this.canSkipUntil = 0;
            this.canSkipDateRanges = false;
            this.skippedSegments = 0;
            this.recentlyRemovedDateranges = void 0;
            this.partHoldBack = 0;
            this.holdBack = 0;
            this.partTarget = 0;
            this.preloadHint = void 0;
            this.renditionReports = void 0;
            this.tuneInGoal = 0;
            this.deltaUpdateFailed = void 0;
            this.driftStartTime = 0;
            this.driftEndTime = 0;
            this.driftStart = 0;
            this.driftEnd = 0;
            this.encryptedFragments = void 0;
            this.playlistParsingError = null;
            this.variableList = null;
            this.hasVariableRefs = false;
            this.appliedTimelineOffset = void 0;
            this.fragments = [];
            this.encryptedFragments = [];
            this.dateRanges = {};
            this.url = baseUrl;
          }
          var _proto = LevelDetails2.prototype;
          _proto.reloaded = function reloaded(previous) {
            if (!previous) {
              this.advanced = true;
              this.updated = true;
              return;
            }
            var partSnDiff = this.lastPartSn - previous.lastPartSn;
            var partIndexDiff = this.lastPartIndex - previous.lastPartIndex;
            this.updated = this.endSN !== previous.endSN || !!partIndexDiff || !!partSnDiff || !this.live;
            this.advanced = this.endSN > previous.endSN || partSnDiff > 0 || partSnDiff === 0 && partIndexDiff > 0;
            if (this.updated || this.advanced) {
              this.misses = Math.floor(previous.misses * 0.6);
            } else {
              this.misses = previous.misses + 1;
            }
          };
          return _createClass4(LevelDetails2, [{
            key: "hasProgramDateTime",
            get: function get() {
              if (this.fragments.length) {
                return isFiniteNumber(this.fragments[this.fragments.length - 1].programDateTime);
              }
              return false;
            }
          }, {
            key: "levelTargetDuration",
            get: function get() {
              return this.averagetargetduration || this.targetduration || DEFAULT_TARGET_DURATION;
            }
          }, {
            key: "drift",
            get: function get() {
              var runTime = this.driftEndTime - this.driftStartTime;
              if (runTime > 0) {
                var runDuration = this.driftEnd - this.driftStart;
                return runDuration * 1e3 / runTime;
              }
              return 1;
            }
          }, {
            key: "edge",
            get: function get() {
              return this.partEnd || this.fragmentEnd;
            }
          }, {
            key: "partEnd",
            get: function get() {
              var _this$partList;
              if ((_this$partList = this.partList) != null && _this$partList.length) {
                return this.partList[this.partList.length - 1].end;
              }
              return this.fragmentEnd;
            }
          }, {
            key: "fragmentEnd",
            get: function get() {
              var _this$fragments;
              if ((_this$fragments = this.fragments) != null && _this$fragments.length) {
                return this.fragments[this.fragments.length - 1].end;
              }
              return 0;
            }
          }, {
            key: "fragmentStart",
            get: function get() {
              var _this$fragments2;
              if ((_this$fragments2 = this.fragments) != null && _this$fragments2.length) {
                return this.fragments[0].start;
              }
              return 0;
            }
          }, {
            key: "age",
            get: function get() {
              if (this.advancedDateTime) {
                return Math.max(Date.now() - this.advancedDateTime, 0) / 1e3;
              }
              return 0;
            }
          }, {
            key: "lastPartIndex",
            get: function get() {
              var _this$partList2;
              if ((_this$partList2 = this.partList) != null && _this$partList2.length) {
                return this.partList[this.partList.length - 1].index;
              }
              return -1;
            }
          }, {
            key: "maxPartIndex",
            get: function get() {
              var partList = this.partList;
              if (partList) {
                var lastIndex = this.lastPartIndex;
                if (lastIndex !== -1) {
                  for (var i = partList.length; i--; ) {
                    if (partList[i].index > lastIndex) {
                      return partList[i].index;
                    }
                  }
                  return lastIndex;
                }
              }
              return 0;
            }
          }, {
            key: "lastPartSn",
            get: function get() {
              var _this$partList3;
              if ((_this$partList3 = this.partList) != null && _this$partList3.length) {
                return this.partList[this.partList.length - 1].fragment.sn;
              }
              return this.endSN;
            }
          }, {
            key: "expired",
            get: function get() {
              if (this.live && this.age && this.misses < 3) {
                var playlistWindowDuration = this.partEnd - this.fragmentStart;
                return this.age > Math.max(playlistWindowDuration, this.totalduration) + this.levelTargetDuration;
              }
              return false;
            }
          }]);
        }();
        var DecrypterAesMode = {
          cbc: 0,
          ctr: 1
        };
        function isFullSegmentEncryption(method) {
          return method === "AES-128" || method === "AES-256" || method === "AES-256-CTR";
        }
        function getAesModeFromFullSegmentMethod(method) {
          switch (method) {
            case "AES-128":
            case "AES-256":
              return DecrypterAesMode.cbc;
            case "AES-256-CTR":
              return DecrypterAesMode.ctr;
            default:
              throw new Error("invalid full segment method " + method);
          }
        }
        var LevelKey = /* @__PURE__ */ function() {
          function LevelKey2(method, uri, format, formatversions, iv) {
            if (formatversions === void 0) {
              formatversions = [1];
            }
            if (iv === void 0) {
              iv = null;
            }
            this.uri = void 0;
            this.method = void 0;
            this.keyFormat = void 0;
            this.keyFormatVersions = void 0;
            this.encrypted = void 0;
            this.isCommonEncryption = void 0;
            this.iv = null;
            this.key = null;
            this.keyId = null;
            this.pssh = null;
            this.method = method;
            this.uri = uri;
            this.keyFormat = format;
            this.keyFormatVersions = formatversions;
            this.iv = iv;
            this.encrypted = method ? method !== "NONE" : false;
            this.isCommonEncryption = this.encrypted && !isFullSegmentEncryption(method);
          }
          LevelKey2.clearKeyUriToKeyIdMap = function clearKeyUriToKeyIdMap() {
          };
          var _proto = LevelKey2.prototype;
          _proto.isSupported = function isSupported2() {
            if (this.method) {
              if (isFullSegmentEncryption(this.method) || this.method === "NONE") {
                return true;
              }
              if (this.keyFormat === "identity") {
                return this.method === "SAMPLE-AES";
              }
            }
            return false;
          };
          _proto.getDecryptData = function getDecryptData(sn) {
            if (!this.encrypted || !this.uri) {
              return null;
            }
            if (isFullSegmentEncryption(this.method) && this.uri && !this.iv) {
              if (typeof sn !== "number") {
                logger4.warn('missing IV for initialization segment with method="' + this.method + '" - compliance issue');
                sn = 0;
              }
              var iv = createInitializationVector(sn);
              var decryptdata = new LevelKey2(this.method, this.uri, "identity", this.keyFormatVersions, iv);
              return decryptdata;
            }
            {
              return this;
            }
          };
          return LevelKey2;
        }();
        function createInitializationVector(segmentNumber) {
          var uint8View = new Uint8Array(16);
          for (var i = 12; i < 16; i++) {
            uint8View[i] = segmentNumber >> 8 * (15 - i) & 255;
          }
          return uint8View;
        }
        var MASTER_PLAYLIST_REGEX = /#EXT-X-STREAM-INF:([^\r\n]*)(?:[\r\n](?:#[^\r\n]*)?)*([^\r\n]+)|#EXT-X-(SESSION-DATA|SESSION-KEY|DEFINE|CONTENT-STEERING|START):([^\r\n]*)[\r\n]+/g;
        var MASTER_PLAYLIST_MEDIA_REGEX = /#EXT-X-MEDIA:(.*)/g;
        var IS_MEDIA_PLAYLIST = /^#EXT(?:INF|-X-TARGETDURATION):/m;
        var LEVEL_PLAYLIST_REGEX_FAST = new RegExp([
          /#EXTINF:\s*(\d*(?:\.\d+)?)(?:,(.*)\s+)?/.source,
          // duration (#EXTINF:<duration>,<title>), group 1 => duration, group 2 => title
          /(?!#) *(\S[^\r\n]*)/.source,
          // segment URI, group 3 => the URI (note newline is not eaten)
          /#.*/.source
          // All other non-segment oriented tags will match with all groups empty
        ].join("|"), "g");
        var LEVEL_PLAYLIST_REGEX_SLOW = new RegExp([/#EXT-X-(PROGRAM-DATE-TIME|BYTERANGE|DATERANGE|DEFINE|KEY|MAP|PART|PART-INF|PLAYLIST-TYPE|PRELOAD-HINT|RENDITION-REPORT|SERVER-CONTROL|SKIP|START):(.+)/.source, /#EXT-X-(BITRATE|DISCONTINUITY-SEQUENCE|MEDIA-SEQUENCE|TARGETDURATION|VERSION): *(\d+)/.source, /#EXT-X-(DISCONTINUITY|ENDLIST|GAP|INDEPENDENT-SEGMENTS)/.source, /(#)([^:]*):(.*)/.source, /(#)(.*)(?:.*)\r?\n?/.source].join("|"));
        var M3U8Parser = /* @__PURE__ */ function() {
          function M3U8Parser2() {
          }
          M3U8Parser2.findGroup = function findGroup(groups, mediaGroupId) {
            for (var i = 0; i < groups.length; i++) {
              var group = groups[i];
              if (group.id === mediaGroupId) {
                return group;
              }
            }
          };
          M3U8Parser2.resolve = function resolve(url, baseUrl) {
            return urlToolkitExports.buildAbsoluteURL(baseUrl, url, {
              alwaysNormalize: true
            });
          };
          M3U8Parser2.isMediaPlaylist = function isMediaPlaylist(str) {
            return IS_MEDIA_PLAYLIST.test(str);
          };
          M3U8Parser2.parseMasterPlaylist = function parseMasterPlaylist(string, baseurl) {
            var hasVariableRefs = false;
            var parsed = {
              contentSteering: null,
              levels: [],
              playlistParsingError: null,
              sessionData: null,
              sessionKeys: null,
              startTimeOffset: null,
              variableList: null,
              hasVariableRefs
            };
            var levelsWithKnownCodecs = [];
            MASTER_PLAYLIST_REGEX.lastIndex = 0;
            var result;
            while ((result = MASTER_PLAYLIST_REGEX.exec(string)) != null) {
              if (result[1]) {
                var _level$unknownCodecs;
                var attrs = new AttrList(result[1], parsed);
                var uri = result[2];
                var level = {
                  attrs,
                  bitrate: attrs.decimalInteger("BANDWIDTH") || attrs.decimalInteger("AVERAGE-BANDWIDTH"),
                  name: attrs.NAME,
                  url: M3U8Parser2.resolve(uri, baseurl)
                };
                var resolution = attrs.decimalResolution("RESOLUTION");
                if (resolution) {
                  level.width = resolution.width;
                  level.height = resolution.height;
                }
                setCodecs(attrs.CODECS, level);
                var supplementalCodecs = attrs["SUPPLEMENTAL-CODECS"];
                if (supplementalCodecs) {
                  level.supplemental = {};
                  setCodecs(supplementalCodecs, level.supplemental);
                }
                if (!((_level$unknownCodecs = level.unknownCodecs) != null && _level$unknownCodecs.length)) {
                  levelsWithKnownCodecs.push(level);
                }
                parsed.levels.push(level);
              } else if (result[3]) {
                var tag = result[3];
                var attributes = result[4];
                switch (tag) {
                  case "SESSION-DATA": {
                    var sessionAttrs = new AttrList(attributes, parsed);
                    var dataId = sessionAttrs["DATA-ID"];
                    if (dataId) {
                      if (parsed.sessionData === null) {
                        parsed.sessionData = {};
                      }
                      parsed.sessionData[dataId] = sessionAttrs;
                    }
                    break;
                  }
                  case "SESSION-KEY": {
                    var sessionKey = parseKey(attributes, baseurl, parsed);
                    if (sessionKey.encrypted && sessionKey.isSupported()) {
                      if (parsed.sessionKeys === null) {
                        parsed.sessionKeys = [];
                      }
                      parsed.sessionKeys.push(sessionKey);
                    } else {
                      logger4.warn('[Keys] Ignoring invalid EXT-X-SESSION-KEY tag: "' + attributes + '"');
                    }
                    break;
                  }
                  case "DEFINE": {
                    break;
                  }
                  case "CONTENT-STEERING": {
                    var contentSteeringAttributes = new AttrList(attributes, parsed);
                    parsed.contentSteering = {
                      uri: M3U8Parser2.resolve(contentSteeringAttributes["SERVER-URI"], baseurl),
                      pathwayId: contentSteeringAttributes["PATHWAY-ID"] || "."
                    };
                    break;
                  }
                  case "START": {
                    parsed.startTimeOffset = parseStartTimeOffset(attributes);
                    break;
                  }
                }
              }
            }
            var stripUnknownCodecLevels = levelsWithKnownCodecs.length > 0 && levelsWithKnownCodecs.length < parsed.levels.length;
            parsed.levels = stripUnknownCodecLevels ? levelsWithKnownCodecs : parsed.levels;
            if (parsed.levels.length === 0) {
              parsed.playlistParsingError = new Error("no levels found in manifest");
            }
            return parsed;
          };
          M3U8Parser2.parseMasterPlaylistMedia = function parseMasterPlaylistMedia(string, baseurl, parsed) {
            var result;
            var results = {};
            var levels = parsed.levels;
            var groupsByType = {
              AUDIO: levels.map(function(level) {
                return {
                  id: level.attrs.AUDIO,
                  audioCodec: level.audioCodec
                };
              }),
              SUBTITLES: levels.map(function(level) {
                return {
                  id: level.attrs.SUBTITLES,
                  textCodec: level.textCodec
                };
              }),
              "CLOSED-CAPTIONS": []
            };
            var id = 0;
            MASTER_PLAYLIST_MEDIA_REGEX.lastIndex = 0;
            while ((result = MASTER_PLAYLIST_MEDIA_REGEX.exec(string)) !== null) {
              var attrs = new AttrList(result[1], parsed);
              var type = attrs.TYPE;
              if (type) {
                var groups = groupsByType[type];
                var medias = results[type] || [];
                results[type] = medias;
                var lang = attrs.LANGUAGE;
                var assocLang = attrs["ASSOC-LANGUAGE"];
                var channels = attrs.CHANNELS;
                var characteristics = attrs.CHARACTERISTICS;
                var instreamId = attrs["INSTREAM-ID"];
                var media = {
                  attrs,
                  bitrate: 0,
                  id: id++,
                  groupId: attrs["GROUP-ID"] || "",
                  name: attrs.NAME || lang || "",
                  type,
                  default: attrs.bool("DEFAULT"),
                  autoselect: attrs.bool("AUTOSELECT"),
                  forced: attrs.bool("FORCED"),
                  lang,
                  url: attrs.URI ? M3U8Parser2.resolve(attrs.URI, baseurl) : ""
                };
                if (assocLang) {
                  media.assocLang = assocLang;
                }
                if (channels) {
                  media.channels = channels;
                }
                if (characteristics) {
                  media.characteristics = characteristics;
                }
                if (instreamId) {
                  media.instreamId = instreamId;
                }
                if (groups != null && groups.length) {
                  var groupCodec = M3U8Parser2.findGroup(groups, media.groupId) || groups[0];
                  assignCodec(media, groupCodec, "audioCodec");
                  assignCodec(media, groupCodec, "textCodec");
                }
                medias.push(media);
              }
            }
            return results;
          };
          M3U8Parser2.parseLevelPlaylist = function parseLevelPlaylist(string, baseurl, id, type, levelUrlId, multivariantVariableList) {
            var _LEVEL_PLAYLIST_REGEX;
            var base = {
              url: baseurl
            };
            var level = new LevelDetails(baseurl);
            var fragments = level.fragments;
            var programDateTimes = [];
            var currentInitSegment = null;
            var currentSN = 0;
            var currentPart = 0;
            var totalduration = 0;
            var discontinuityCounter = 0;
            var currentBitrate = 0;
            var prevFrag = null;
            var frag = new Fragment(type, base);
            var result;
            var i;
            var levelkeys;
            var firstPdtIndex = -1;
            var createNextFrag = false;
            var nextByteRange = null;
            var serverControlAttrs;
            LEVEL_PLAYLIST_REGEX_FAST.lastIndex = 0;
            level.m3u8 = string;
            level.hasVariableRefs = false;
            if (((_LEVEL_PLAYLIST_REGEX = LEVEL_PLAYLIST_REGEX_FAST.exec(string)) == null ? void 0 : _LEVEL_PLAYLIST_REGEX[0]) !== "#EXTM3U") {
              level.playlistParsingError = new Error("Missing format identifier #EXTM3U");
              return level;
            }
            while ((result = LEVEL_PLAYLIST_REGEX_FAST.exec(string)) !== null) {
              if (createNextFrag) {
                createNextFrag = false;
                frag = new Fragment(type, base);
                frag.playlistOffset = totalduration;
                frag.start = totalduration;
                frag.sn = currentSN;
                frag.cc = discontinuityCounter;
                if (currentBitrate) {
                  frag.bitrate = currentBitrate;
                }
                frag.level = id;
                if (currentInitSegment) {
                  frag.initSegment = currentInitSegment;
                  if (currentInitSegment.rawProgramDateTime) {
                    frag.rawProgramDateTime = currentInitSegment.rawProgramDateTime;
                    currentInitSegment.rawProgramDateTime = null;
                  }
                  if (nextByteRange) {
                    frag.setByteRange(nextByteRange);
                    nextByteRange = null;
                  }
                }
              }
              var duration = result[1];
              if (duration) {
                frag.duration = parseFloat(duration);
                var title = (" " + result[2]).slice(1);
                frag.title = title || null;
                frag.tagList.push(title ? ["INF", duration, title] : ["INF", duration]);
              } else if (result[3]) {
                if (isFiniteNumber(frag.duration)) {
                  frag.playlistOffset = totalduration;
                  frag.start = totalduration;
                  if (levelkeys) {
                    setFragLevelKeys(frag, levelkeys, level);
                  }
                  frag.sn = currentSN;
                  frag.level = id;
                  frag.cc = discontinuityCounter;
                  fragments.push(frag);
                  var uri = (" " + result[3]).slice(1);
                  frag.relurl = uri;
                  assignProgramDateTime(frag, prevFrag, programDateTimes);
                  prevFrag = frag;
                  totalduration += frag.duration;
                  currentSN++;
                  currentPart = 0;
                  createNextFrag = true;
                }
              } else {
                result = result[0].match(LEVEL_PLAYLIST_REGEX_SLOW);
                if (!result) {
                  logger4.warn("No matches on slow regex match for level playlist!");
                  continue;
                }
                for (i = 1; i < result.length; i++) {
                  if (result[i] !== void 0) {
                    break;
                  }
                }
                var tag = (" " + result[i]).slice(1);
                var value1 = (" " + result[i + 1]).slice(1);
                var value2 = result[i + 2] ? (" " + result[i + 2]).slice(1) : null;
                switch (tag) {
                  case "BYTERANGE":
                    if (prevFrag) {
                      frag.setByteRange(value1, prevFrag);
                    } else {
                      frag.setByteRange(value1);
                    }
                    break;
                  case "PROGRAM-DATE-TIME":
                    frag.rawProgramDateTime = value1;
                    frag.tagList.push(["PROGRAM-DATE-TIME", value1]);
                    if (firstPdtIndex === -1) {
                      firstPdtIndex = fragments.length;
                    }
                    break;
                  case "PLAYLIST-TYPE":
                    if (level.type) {
                      assignMultipleMediaPlaylistTagOccuranceError(level, tag, result);
                    }
                    level.type = value1.toUpperCase();
                    break;
                  case "MEDIA-SEQUENCE":
                    if (level.startSN !== 0) {
                      assignMultipleMediaPlaylistTagOccuranceError(level, tag, result);
                    } else if (fragments.length > 0) {
                      assignMustAppearBeforeSegmentsError(level, tag, result);
                    }
                    currentSN = level.startSN = parseInt(value1);
                    break;
                  case "SKIP": {
                    if (level.skippedSegments) {
                      assignMultipleMediaPlaylistTagOccuranceError(level, tag, result);
                    }
                    var skipAttrs = new AttrList(value1, level);
                    var skippedSegments = skipAttrs.decimalInteger("SKIPPED-SEGMENTS");
                    if (isFiniteNumber(skippedSegments)) {
                      level.skippedSegments += skippedSegments;
                      for (var _i = skippedSegments; _i--; ) {
                        fragments.push(null);
                      }
                      currentSN += skippedSegments;
                    }
                    var recentlyRemovedDateranges = skipAttrs.enumeratedString("RECENTLY-REMOVED-DATERANGES");
                    if (recentlyRemovedDateranges) {
                      level.recentlyRemovedDateranges = (level.recentlyRemovedDateranges || []).concat(recentlyRemovedDateranges.split("	"));
                    }
                    break;
                  }
                  case "TARGETDURATION":
                    if (level.targetduration !== 0) {
                      assignMultipleMediaPlaylistTagOccuranceError(level, tag, result);
                    }
                    level.targetduration = Math.max(parseInt(value1), 1);
                    break;
                  case "VERSION":
                    if (level.version !== null) {
                      assignMultipleMediaPlaylistTagOccuranceError(level, tag, result);
                    }
                    level.version = parseInt(value1);
                    break;
                  case "INDEPENDENT-SEGMENTS":
                    break;
                  case "ENDLIST":
                    if (!level.live) {
                      assignMultipleMediaPlaylistTagOccuranceError(level, tag, result);
                    }
                    level.live = false;
                    break;
                  case "#":
                    if (value1 || value2) {
                      frag.tagList.push(value2 ? [value1, value2] : [value1]);
                    }
                    break;
                  case "DISCONTINUITY":
                    discontinuityCounter++;
                    frag.tagList.push(["DIS"]);
                    break;
                  case "GAP":
                    frag.gap = true;
                    frag.tagList.push([tag]);
                    break;
                  case "BITRATE":
                    frag.tagList.push([tag, value1]);
                    currentBitrate = parseInt(value1) * 1e3;
                    if (isFiniteNumber(currentBitrate)) {
                      frag.bitrate = currentBitrate;
                    } else {
                      currentBitrate = 0;
                    }
                    break;
                  case "DATERANGE": {
                    var dateRangeAttr = new AttrList(value1, level);
                    var dateRange = new DateRange(dateRangeAttr, level.dateRanges[dateRangeAttr.ID], level.dateRangeTagCount);
                    level.dateRangeTagCount++;
                    if (dateRange.isValid || level.skippedSegments) {
                      level.dateRanges[dateRange.id] = dateRange;
                    } else {
                      logger4.warn('Ignoring invalid DATERANGE tag: "' + value1 + '"');
                    }
                    frag.tagList.push(["EXT-X-DATERANGE", value1]);
                    break;
                  }
                  case "DEFINE": {
                    break;
                  }
                  case "DISCONTINUITY-SEQUENCE":
                    if (level.startCC !== 0) {
                      assignMultipleMediaPlaylistTagOccuranceError(level, tag, result);
                    } else if (fragments.length > 0) {
                      assignMustAppearBeforeSegmentsError(level, tag, result);
                    }
                    level.startCC = discontinuityCounter = parseInt(value1);
                    break;
                  case "KEY": {
                    var levelKey = parseKey(value1, baseurl, level);
                    if (levelKey.isSupported()) {
                      if (levelKey.method === "NONE") {
                        levelkeys = void 0;
                        break;
                      }
                      if (!levelkeys) {
                        levelkeys = {};
                      }
                      if (levelkeys[levelKey.keyFormat]) {
                        levelkeys = _extends({}, levelkeys);
                      }
                      levelkeys[levelKey.keyFormat] = levelKey;
                    } else {
                      logger4.warn('[Keys] Ignoring invalid EXT-X-KEY tag: "' + value1 + '"');
                    }
                    break;
                  }
                  case "START":
                    level.startTimeOffset = parseStartTimeOffset(value1);
                    break;
                  case "MAP": {
                    var mapAttrs = new AttrList(value1, level);
                    if (frag.duration) {
                      var init = new Fragment(type, base);
                      setInitSegment(init, mapAttrs, id, levelkeys);
                      currentInitSegment = init;
                      frag.initSegment = currentInitSegment;
                      if (currentInitSegment.rawProgramDateTime && !frag.rawProgramDateTime) {
                        frag.rawProgramDateTime = currentInitSegment.rawProgramDateTime;
                      }
                    } else {
                      var end = frag.byteRangeEndOffset;
                      if (end) {
                        var start = frag.byteRangeStartOffset;
                        nextByteRange = end - start + "@" + start;
                      } else {
                        nextByteRange = null;
                      }
                      setInitSegment(frag, mapAttrs, id, levelkeys);
                      currentInitSegment = frag;
                      createNextFrag = true;
                    }
                    currentInitSegment.cc = discontinuityCounter;
                    break;
                  }
                  case "SERVER-CONTROL": {
                    if (serverControlAttrs) {
                      assignMultipleMediaPlaylistTagOccuranceError(level, tag, result);
                    }
                    serverControlAttrs = new AttrList(value1);
                    level.canBlockReload = serverControlAttrs.bool("CAN-BLOCK-RELOAD");
                    level.canSkipUntil = serverControlAttrs.optionalFloat("CAN-SKIP-UNTIL", 0);
                    level.canSkipDateRanges = level.canSkipUntil > 0 && serverControlAttrs.bool("CAN-SKIP-DATERANGES");
                    level.partHoldBack = serverControlAttrs.optionalFloat("PART-HOLD-BACK", 0);
                    level.holdBack = serverControlAttrs.optionalFloat("HOLD-BACK", 0);
                    break;
                  }
                  case "PART-INF": {
                    if (level.partTarget) {
                      assignMultipleMediaPlaylistTagOccuranceError(level, tag, result);
                    }
                    var partInfAttrs = new AttrList(value1);
                    level.partTarget = partInfAttrs.decimalFloatingPoint("PART-TARGET");
                    break;
                  }
                  case "PART": {
                    var partList = level.partList;
                    if (!partList) {
                      partList = level.partList = [];
                    }
                    var previousFragmentPart = currentPart > 0 ? partList[partList.length - 1] : void 0;
                    var index = currentPart++;
                    var partAttrs = new AttrList(value1, level);
                    var part = new Part(partAttrs, frag, base, index, previousFragmentPart);
                    partList.push(part);
                    frag.duration += part.duration;
                    break;
                  }
                  case "PRELOAD-HINT": {
                    var preloadHintAttrs = new AttrList(value1, level);
                    level.preloadHint = preloadHintAttrs;
                    break;
                  }
                  case "RENDITION-REPORT": {
                    var renditionReportAttrs = new AttrList(value1, level);
                    level.renditionReports = level.renditionReports || [];
                    level.renditionReports.push(renditionReportAttrs);
                    break;
                  }
                  default:
                    logger4.warn("line parsed but not handled: " + result);
                    break;
                }
              }
            }
            if (prevFrag && !prevFrag.relurl) {
              fragments.pop();
              totalduration -= prevFrag.duration;
              if (level.partList) {
                level.fragmentHint = prevFrag;
              }
            } else if (level.partList) {
              assignProgramDateTime(frag, prevFrag, programDateTimes);
              frag.cc = discontinuityCounter;
              level.fragmentHint = frag;
              if (levelkeys) {
                setFragLevelKeys(frag, levelkeys, level);
              }
            }
            if (!level.targetduration) {
              level.playlistParsingError = new Error("#EXT-X-TARGETDURATION is required");
            }
            var fragmentLength = fragments.length;
            var firstFragment = fragments[0];
            var lastFragment = fragments[fragmentLength - 1];
            totalduration += level.skippedSegments * level.targetduration;
            if (totalduration > 0 && fragmentLength && lastFragment) {
              level.averagetargetduration = totalduration / fragmentLength;
              var lastSn = lastFragment.sn;
              level.endSN = lastSn !== "initSegment" ? lastSn : 0;
              if (!level.live) {
                lastFragment.endList = true;
              }
              if (firstFragment && level.startCC === void 0) {
                level.startCC = firstFragment.cc;
              }
              if (firstPdtIndex > 0) {
                backfillProgramDateTimes(fragments, firstPdtIndex);
                if (firstFragment) {
                  programDateTimes.unshift(firstFragment);
                }
              }
            } else {
              level.endSN = 0;
              level.startCC = 0;
            }
            if (level.fragmentHint) {
              totalduration += level.fragmentHint.duration;
            }
            level.totalduration = totalduration;
            if (programDateTimes.length && level.dateRangeTagCount && firstFragment) {
              mapDateRanges(programDateTimes, level);
            }
            level.endCC = discontinuityCounter;
            return level;
          };
          return M3U8Parser2;
        }();
        function mapDateRanges(programDateTimes, details) {
          var programDateTimeCount = programDateTimes.length;
          var lastProgramDateTime = programDateTimes[programDateTimeCount - 1];
          var playlistEnd = details.live ? Infinity : details.totalduration;
          var dateRangeIds = Object.keys(details.dateRanges);
          for (var i = dateRangeIds.length; i--; ) {
            var dateRange = details.dateRanges[dateRangeIds[i]];
            var startDateTime = dateRange.startDate.getTime();
            dateRange.tagAnchor = lastProgramDateTime.ref;
            for (var j = programDateTimeCount; j--; ) {
              var fragIndex = findFragmentWithStartDate(details, startDateTime, programDateTimes, j, playlistEnd);
              if (fragIndex !== -1) {
                dateRange.tagAnchor = details.fragments[fragIndex].ref;
                break;
              }
            }
          }
        }
        function findFragmentWithStartDate(details, startDateTime, programDateTimes, index, endTime) {
          var pdtFragment = programDateTimes[index];
          if (pdtFragment) {
            var pdtStart = pdtFragment.programDateTime;
            if (startDateTime >= pdtStart || index === 0) {
              var _programDateTimes;
              var durationBetweenPdt = (((_programDateTimes = programDateTimes[index + 1]) == null ? void 0 : _programDateTimes.start) || endTime) - pdtFragment.start;
              if (startDateTime <= pdtStart + durationBetweenPdt * 1e3) {
                var startIndex = programDateTimes[index].sn - details.startSN;
                var fragments = details.fragments;
                if (fragments.length > programDateTimes.length) {
                  var endSegment = programDateTimes[index + 1] || fragments[fragments.length - 1];
                  var endIndex = endSegment.sn - details.startSN;
                  for (var i = endIndex; i > startIndex; i--) {
                    var fragStartDateTime = fragments[i].programDateTime;
                    if (startDateTime >= fragStartDateTime && startDateTime < fragStartDateTime + fragments[i].duration * 1e3) {
                      return i;
                    }
                  }
                }
                return startIndex;
              }
            }
          }
          return -1;
        }
        function parseKey(keyTagAttributes, baseurl, parsed) {
          var _keyAttrs$METHOD, _keyAttrs$KEYFORMAT;
          var keyAttrs = new AttrList(keyTagAttributes, parsed);
          var decryptmethod = (_keyAttrs$METHOD = keyAttrs.METHOD) != null ? _keyAttrs$METHOD : "";
          var decrypturi = keyAttrs.URI;
          var decryptiv = keyAttrs.hexadecimalInteger("IV");
          var decryptkeyformatversions = keyAttrs.KEYFORMATVERSIONS;
          var decryptkeyformat = (_keyAttrs$KEYFORMAT = keyAttrs.KEYFORMAT) != null ? _keyAttrs$KEYFORMAT : "identity";
          if (decrypturi && keyAttrs.IV && !decryptiv) {
            logger4.error("Invalid IV: " + keyAttrs.IV);
          }
          var resolvedUri = decrypturi ? M3U8Parser.resolve(decrypturi, baseurl) : "";
          var keyFormatVersions = (decryptkeyformatversions ? decryptkeyformatversions : "1").split("/").map(Number).filter(Number.isFinite);
          return new LevelKey(decryptmethod, resolvedUri, decryptkeyformat, keyFormatVersions, decryptiv);
        }
        function parseStartTimeOffset(startAttributes) {
          var startAttrs = new AttrList(startAttributes);
          var startTimeOffset = startAttrs.decimalFloatingPoint("TIME-OFFSET");
          if (isFiniteNumber(startTimeOffset)) {
            return startTimeOffset;
          }
          return null;
        }
        function setCodecs(codecsAttributeValue, level) {
          var codecs = (codecsAttributeValue || "").split(/[ ,]+/).filter(function(c) {
            return c;
          });
          ["video", "audio", "text"].forEach(function(type) {
            var filtered = codecs.filter(function(codec) {
              return isCodecType(codec, type);
            });
            if (filtered.length) {
              level[type + "Codec"] = filtered.map(function(c) {
                return c.split("/")[0];
              }).join(",");
              codecs = codecs.filter(function(codec) {
                return filtered.indexOf(codec) === -1;
              });
            }
          });
          level.unknownCodecs = codecs;
        }
        function assignCodec(media, groupItem, codecProperty) {
          var codecValue = groupItem[codecProperty];
          if (codecValue) {
            media[codecProperty] = codecValue;
          }
        }
        function backfillProgramDateTimes(fragments, firstPdtIndex) {
          var fragPrev = fragments[firstPdtIndex];
          for (var i = firstPdtIndex; i--; ) {
            var frag = fragments[i];
            if (!frag) {
              return;
            }
            frag.programDateTime = fragPrev.programDateTime - frag.duration * 1e3;
            fragPrev = frag;
          }
        }
        function assignProgramDateTime(frag, prevFrag, programDateTimes) {
          if (frag.rawProgramDateTime) {
            programDateTimes.push(frag);
          } else if (prevFrag != null && prevFrag.programDateTime) {
            frag.programDateTime = prevFrag.endProgramDateTime;
          }
        }
        function setInitSegment(frag, mapAttrs, id, levelkeys) {
          frag.relurl = mapAttrs.URI;
          if (mapAttrs.BYTERANGE) {
            frag.setByteRange(mapAttrs.BYTERANGE);
          }
          frag.level = id;
          frag.sn = "initSegment";
          if (levelkeys) {
            frag.levelkeys = levelkeys;
          }
          frag.initSegment = null;
        }
        function setFragLevelKeys(frag, levelkeys, level) {
          frag.levelkeys = levelkeys;
          var encryptedFragments = level.encryptedFragments;
          if ((!encryptedFragments.length || encryptedFragments[encryptedFragments.length - 1].levelkeys !== levelkeys) && Object.keys(levelkeys).some(function(format) {
            return levelkeys[format].isCommonEncryption;
          })) {
            encryptedFragments.push(frag);
          }
        }
        function assignMultipleMediaPlaylistTagOccuranceError(level, tag, result) {
          level.playlistParsingError = new Error("#EXT-X-" + tag + " must not appear more than once (" + result[0] + ")");
        }
        function assignMustAppearBeforeSegmentsError(level, tag, result) {
          level.playlistParsingError = new Error("#EXT-X-" + tag + " must appear before the first Media Segment (" + result[0] + ")");
        }
        function updateFromToPTS(fragFrom, fragTo) {
          var fragToPTS = fragTo.startPTS;
          if (isFiniteNumber(fragToPTS)) {
            var duration = 0;
            var frag;
            if (fragTo.sn > fragFrom.sn) {
              duration = fragToPTS - fragFrom.start;
              frag = fragFrom;
            } else {
              duration = fragFrom.start - fragToPTS;
              frag = fragTo;
            }
            if (frag.duration !== duration) {
              frag.setDuration(duration);
            }
          } else if (fragTo.sn > fragFrom.sn) {
            var contiguous = fragFrom.cc === fragTo.cc;
            if (contiguous && fragFrom.minEndPTS) {
              fragTo.setStart(fragFrom.start + (fragFrom.minEndPTS - fragFrom.start));
            } else {
              fragTo.setStart(fragFrom.start + fragFrom.duration);
            }
          } else {
            fragTo.setStart(Math.max(fragFrom.start - fragTo.duration, 0));
          }
        }
        function updateFragPTSDTS(details, frag, startPTS, endPTS, startDTS, endDTS) {
          var parsedMediaDuration = endPTS - startPTS;
          if (parsedMediaDuration <= 0) {
            logger4.warn("Fragment should have a positive duration", frag);
            endPTS = startPTS + frag.duration;
            endDTS = startDTS + frag.duration;
          }
          var maxStartPTS = startPTS;
          var minEndPTS = endPTS;
          var fragStartPts = frag.startPTS;
          var fragEndPts = frag.endPTS;
          if (isFiniteNumber(fragStartPts)) {
            var deltaPTS = Math.abs(fragStartPts - startPTS);
            if (!isFiniteNumber(frag.deltaPTS)) {
              frag.deltaPTS = deltaPTS;
            } else {
              frag.deltaPTS = Math.max(deltaPTS, frag.deltaPTS);
            }
            maxStartPTS = Math.max(startPTS, fragStartPts);
            startPTS = Math.min(startPTS, fragStartPts);
            startDTS = Math.min(startDTS, frag.startDTS);
            minEndPTS = Math.min(endPTS, fragEndPts);
            endPTS = Math.max(endPTS, fragEndPts);
            endDTS = Math.max(endDTS, frag.endDTS);
          }
          var drift = startPTS - frag.start;
          if (frag.start !== 0) {
            frag.setStart(startPTS);
          }
          frag.setDuration(endPTS - frag.start);
          frag.startPTS = startPTS;
          frag.maxStartPTS = maxStartPTS;
          frag.startDTS = startDTS;
          frag.endPTS = endPTS;
          frag.minEndPTS = minEndPTS;
          frag.endDTS = endDTS;
          var sn = frag.sn;
          if (!details || sn < details.startSN || sn > details.endSN) {
            return 0;
          }
          var i;
          var fragIdx = sn - details.startSN;
          var fragments = details.fragments;
          fragments[fragIdx] = frag;
          for (i = fragIdx; i > 0; i--) {
            updateFromToPTS(fragments[i], fragments[i - 1]);
          }
          for (i = fragIdx; i < fragments.length - 1; i++) {
            updateFromToPTS(fragments[i], fragments[i + 1]);
          }
          if (details.fragmentHint) {
            updateFromToPTS(fragments[fragments.length - 1], details.fragmentHint);
          }
          details.PTSKnown = details.alignedSliding = true;
          return drift;
        }
        function mergeDetails(oldDetails, newDetails) {
          if (oldDetails === newDetails) {
            return;
          }
          var currentInitSegment = null;
          var oldFragments = oldDetails.fragments;
          for (var i = oldFragments.length - 1; i >= 0; i--) {
            var oldInit = oldFragments[i].initSegment;
            if (oldInit) {
              currentInitSegment = oldInit;
              break;
            }
          }
          if (oldDetails.fragmentHint) {
            delete oldDetails.fragmentHint.endPTS;
          }
          var PTSFrag;
          mapFragmentIntersection(oldDetails, newDetails, function(oldFrag, newFrag, newFragIndex, newFragments2) {
            if (newDetails.skippedSegments) {
              if (newFrag.cc !== oldFrag.cc) {
                var ccOffset = oldFrag.cc - newFrag.cc;
                for (var _i = newFragIndex; _i < newFragments2.length; _i++) {
                  newFragments2[_i].cc += ccOffset;
                }
              }
            }
            if (isFiniteNumber(oldFrag.startPTS) && isFiniteNumber(oldFrag.endPTS)) {
              newFrag.setStart(newFrag.startPTS = oldFrag.startPTS);
              newFrag.startDTS = oldFrag.startDTS;
              newFrag.maxStartPTS = oldFrag.maxStartPTS;
              newFrag.endPTS = oldFrag.endPTS;
              newFrag.endDTS = oldFrag.endDTS;
              newFrag.minEndPTS = oldFrag.minEndPTS;
              newFrag.setDuration(oldFrag.endPTS - oldFrag.startPTS);
              if (newFrag.duration) {
                PTSFrag = newFrag;
              }
              newDetails.PTSKnown = newDetails.alignedSliding = true;
            }
            if (oldFrag.hasStreams) {
              newFrag.elementaryStreams = oldFrag.elementaryStreams;
            }
            newFrag.loader = oldFrag.loader;
            if (oldFrag.hasStats) {
              newFrag.stats = oldFrag.stats;
            }
            if (oldFrag.initSegment) {
              newFrag.initSegment = oldFrag.initSegment;
              currentInitSegment = oldFrag.initSegment;
            }
          });
          var newFragments = newDetails.fragments;
          var fragmentsToCheck = newDetails.fragmentHint ? newFragments.concat(newDetails.fragmentHint) : newFragments;
          if (currentInitSegment) {
            fragmentsToCheck.forEach(function(frag) {
              var _currentInitSegment;
              if (frag && (!frag.initSegment || frag.initSegment.relurl === ((_currentInitSegment = currentInitSegment) == null ? void 0 : _currentInitSegment.relurl))) {
                frag.initSegment = currentInitSegment;
              }
            });
          }
          if (newDetails.skippedSegments) {
            newDetails.deltaUpdateFailed = newFragments.some(function(frag) {
              return !frag;
            });
            if (newDetails.deltaUpdateFailed) {
              logger4.warn("[level-helper] Previous playlist missing segments skipped in delta playlist");
              for (var _i2 = newDetails.skippedSegments; _i2--; ) {
                newFragments.shift();
              }
              newDetails.startSN = newFragments[0].sn;
            } else {
              newDetails.endCC = newFragments[newFragments.length - 1].cc;
              if (newDetails.canSkipDateRanges) {
                newDetails.dateRanges = mergeDateRanges(oldDetails.dateRanges, newDetails);
              }
              var programDateTimes = oldDetails.fragments.filter(function(frag) {
                return frag.rawProgramDateTime;
              });
              if (oldDetails.hasProgramDateTime && !newDetails.hasProgramDateTime) {
                for (var _i3 = 1; _i3 < fragmentsToCheck.length; _i3++) {
                  if (fragmentsToCheck[_i3].programDateTime === null) {
                    assignProgramDateTime(fragmentsToCheck[_i3], fragmentsToCheck[_i3 - 1], programDateTimes);
                  }
                }
              }
              mapDateRanges(programDateTimes, newDetails);
            }
          }
          mapPartIntersection(oldDetails.partList, newDetails.partList, function(oldPart, newPart) {
            newPart.elementaryStreams = oldPart.elementaryStreams;
            newPart.stats = oldPart.stats;
          });
          if (PTSFrag) {
            updateFragPTSDTS(newDetails, PTSFrag, PTSFrag.startPTS, PTSFrag.endPTS, PTSFrag.startDTS, PTSFrag.endDTS);
          } else {
            adjustSliding(oldDetails, newDetails);
          }
          if (newFragments.length) {
            newDetails.totalduration = newDetails.edge - newFragments[0].start;
          }
          newDetails.driftStartTime = oldDetails.driftStartTime;
          newDetails.driftStart = oldDetails.driftStart;
          var advancedDateTime = newDetails.advancedDateTime;
          if (newDetails.advanced && advancedDateTime) {
            var edge = newDetails.edge;
            if (!newDetails.driftStart) {
              newDetails.driftStartTime = advancedDateTime;
              newDetails.driftStart = edge;
            }
            newDetails.driftEndTime = advancedDateTime;
            newDetails.driftEnd = edge;
          } else {
            newDetails.driftEndTime = oldDetails.driftEndTime;
            newDetails.driftEnd = oldDetails.driftEnd;
            newDetails.advancedDateTime = oldDetails.advancedDateTime;
          }
          if (newDetails.requestScheduled === -1) {
            newDetails.requestScheduled = oldDetails.requestScheduled;
          }
        }
        function mergeDateRanges(oldDateRanges, newDetails) {
          var deltaDateRanges = newDetails.dateRanges, recentlyRemovedDateranges = newDetails.recentlyRemovedDateranges;
          var dateRanges = _extends({}, oldDateRanges);
          if (recentlyRemovedDateranges) {
            recentlyRemovedDateranges.forEach(function(id) {
              delete dateRanges[id];
            });
          }
          var mergeIds = Object.keys(dateRanges);
          var mergeCount = mergeIds.length;
          if (mergeCount) {
            Object.keys(deltaDateRanges).forEach(function(id) {
              var mergedDateRange = dateRanges[id];
              var dateRange = new DateRange(deltaDateRanges[id].attr, mergedDateRange);
              if (dateRange.isValid) {
                dateRanges[id] = dateRange;
                if (!mergedDateRange) {
                  dateRange.tagOrder += mergeCount;
                }
              } else {
                logger4.warn('Ignoring invalid Playlist Delta Update DATERANGE tag: "' + stringify2(deltaDateRanges[id].attr) + '"');
              }
            });
          }
          return dateRanges;
        }
        function mapPartIntersection(oldParts, newParts, intersectionFn) {
          if (oldParts && newParts) {
            var delta = 0;
            for (var i = 0, len = oldParts.length; i <= len; i++) {
              var _oldPart = oldParts[i];
              var _newPart = newParts[i + delta];
              if (_oldPart && _newPart && _oldPart.index === _newPart.index && _oldPart.fragment.sn === _newPart.fragment.sn) {
                intersectionFn(_oldPart, _newPart);
              } else {
                delta--;
              }
            }
          }
        }
        function mapFragmentIntersection(oldDetails, newDetails, intersectionFn) {
          var skippedSegments = newDetails.skippedSegments;
          var start = Math.max(oldDetails.startSN, newDetails.startSN) - newDetails.startSN;
          var end = (oldDetails.fragmentHint ? 1 : 0) + (skippedSegments ? newDetails.endSN : Math.min(oldDetails.endSN, newDetails.endSN)) - newDetails.startSN;
          var delta = newDetails.startSN - oldDetails.startSN;
          var newFrags = newDetails.fragmentHint ? newDetails.fragments.concat(newDetails.fragmentHint) : newDetails.fragments;
          var oldFrags = oldDetails.fragmentHint ? oldDetails.fragments.concat(oldDetails.fragmentHint) : oldDetails.fragments;
          for (var i = start; i <= end; i++) {
            var _oldFrag = oldFrags[delta + i];
            var _newFrag = newFrags[i];
            if (skippedSegments && !_newFrag && _oldFrag) {
              _newFrag = newDetails.fragments[i] = _oldFrag;
            }
            if (_oldFrag && _newFrag) {
              intersectionFn(_oldFrag, _newFrag, i, newFrags);
              if (_oldFrag.url && _oldFrag.url !== _newFrag.url) {
                newDetails.playlistParsingError = getSequenceError("media sequence mismatch " + _newFrag.sn + ":", oldDetails, newDetails, _oldFrag, _newFrag);
                return;
              } else if (_oldFrag.cc !== _newFrag.cc) {
                newDetails.playlistParsingError = getSequenceError("discontinuity sequence mismatch (" + _oldFrag.cc + "!=" + _newFrag.cc + ")", oldDetails, newDetails, _oldFrag, _newFrag);
                return;
              }
            }
          }
        }
        function getSequenceError(message, oldDetails, newDetails, oldFrag, newFrag) {
          return new Error(message + " " + newFrag.url + "\nPlaylist starting @" + oldDetails.startSN + "\n" + oldDetails.m3u8 + "\n\nPlaylist starting @" + newDetails.startSN + "\n" + newDetails.m3u8);
        }
        function adjustSliding(oldDetails, newDetails, matchingStableVariantOrRendition) {
          if (matchingStableVariantOrRendition === void 0) {
            matchingStableVariantOrRendition = true;
          }
          var delta = newDetails.startSN + newDetails.skippedSegments - oldDetails.startSN;
          var oldFragments = oldDetails.fragments;
          var advancedOrStable = delta >= 0;
          var sliding = 0;
          if (advancedOrStable && delta < oldFragments.length) {
            sliding = oldFragments[delta].start;
          } else if (advancedOrStable && newDetails.startSN === oldDetails.endSN + 1) {
            sliding = oldDetails.fragmentEnd;
          } else if (advancedOrStable && matchingStableVariantOrRendition) {
            sliding = oldDetails.fragmentStart + delta * newDetails.levelTargetDuration;
          } else if (!newDetails.skippedSegments && newDetails.fragmentStart === 0) {
            sliding = oldDetails.fragmentStart;
          } else {
            return;
          }
          addSliding(newDetails, sliding);
        }
        function addSliding(details, sliding) {
          if (sliding) {
            var fragments = details.fragments;
            for (var i = details.skippedSegments; i < fragments.length; i++) {
              fragments[i].addStart(sliding);
            }
            if (details.fragmentHint) {
              details.fragmentHint.addStart(sliding);
            }
          }
        }
        function computeReloadInterval(newDetails, distanceToLiveEdgeMs) {
          if (distanceToLiveEdgeMs === void 0) {
            distanceToLiveEdgeMs = Infinity;
          }
          var reloadInterval = 1e3 * newDetails.targetduration;
          if (newDetails.updated) {
            var fragments = newDetails.fragments;
            var liveEdgeMaxTargetDurations = 4;
            if (fragments.length && reloadInterval * liveEdgeMaxTargetDurations > distanceToLiveEdgeMs) {
              var lastSegmentDuration = fragments[fragments.length - 1].duration * 1e3;
              if (lastSegmentDuration < reloadInterval) {
                reloadInterval = lastSegmentDuration;
              }
            }
          } else {
            reloadInterval /= 2;
          }
          return Math.round(reloadInterval);
        }
        function getFragmentWithSN(details, sn, fragCurrent) {
          if (!details) {
            return null;
          }
          var fragment = details.fragments[sn - details.startSN];
          if (fragment) {
            return fragment;
          }
          fragment = details.fragmentHint;
          if (fragment && fragment.sn === sn) {
            return fragment;
          }
          if (sn < details.startSN && fragCurrent && fragCurrent.sn === sn) {
            return fragCurrent;
          }
          return null;
        }
        function getPartWith(details, sn, partIndex) {
          if (!details) {
            return null;
          }
          return findPart(details.partList, sn, partIndex);
        }
        function findPart(partList, sn, partIndex) {
          if (partList) {
            for (var i = partList.length; i--; ) {
              var part = partList[i];
              if (part.index === partIndex && part.fragment.sn === sn) {
                return part;
              }
            }
          }
          return null;
        }
        function reassignFragmentLevelIndexes(levels) {
          levels.forEach(function(level, index) {
            var _level$details;
            (_level$details = level.details) == null ? void 0 : _level$details.fragments.forEach(function(fragment) {
              fragment.level = index;
              if (fragment.initSegment) {
                fragment.initSegment.level = index;
              }
            });
          });
        }
        var PATHWAY_PENALTY_DURATION_MS = 3e5;
        var ContentSteeringController = /* @__PURE__ */ function(_Logger) {
          function ContentSteeringController2(hls) {
            var _this;
            _this = _Logger.call(this, "content-steering", hls.logger) || this;
            _this.hls = void 0;
            _this.loader = null;
            _this.uri = null;
            _this.pathwayId = ".";
            _this._pathwayPriority = null;
            _this.timeToLoad = 300;
            _this.reloadTimer = -1;
            _this.updated = 0;
            _this.started = false;
            _this.enabled = true;
            _this.levels = null;
            _this.audioTracks = null;
            _this.subtitleTracks = null;
            _this.penalizedPathways = {};
            _this.hls = hls;
            _this.registerListeners();
            return _this;
          }
          _inheritsLoose(ContentSteeringController2, _Logger);
          var _proto = ContentSteeringController2.prototype;
          _proto.registerListeners = function registerListeners() {
            var hls = this.hls;
            hls.on(Events.MANIFEST_LOADING, this.onManifestLoading, this);
            hls.on(Events.MANIFEST_LOADED, this.onManifestLoaded, this);
            hls.on(Events.MANIFEST_PARSED, this.onManifestParsed, this);
            hls.on(Events.ERROR, this.onError, this);
          };
          _proto.unregisterListeners = function unregisterListeners() {
            var hls = this.hls;
            if (!hls) {
              return;
            }
            hls.off(Events.MANIFEST_LOADING, this.onManifestLoading, this);
            hls.off(Events.MANIFEST_LOADED, this.onManifestLoaded, this);
            hls.off(Events.MANIFEST_PARSED, this.onManifestParsed, this);
            hls.off(Events.ERROR, this.onError, this);
          };
          _proto.pathways = function pathways() {
            return (this.levels || []).reduce(function(pathways2, level) {
              if (pathways2.indexOf(level.pathwayId) === -1) {
                pathways2.push(level.pathwayId);
              }
              return pathways2;
            }, []);
          };
          _proto.startLoad = function startLoad() {
            this.started = true;
            this.clearTimeout();
            if (this.enabled && this.uri) {
              if (this.updated) {
                var ttl = this.timeToLoad * 1e3 - (performance.now() - this.updated);
                if (ttl > 0) {
                  this.scheduleRefresh(this.uri, ttl);
                  return;
                }
              }
              this.loadSteeringManifest(this.uri);
            }
          };
          _proto.stopLoad = function stopLoad() {
            this.started = false;
            if (this.loader) {
              this.loader.destroy();
              this.loader = null;
            }
            this.clearTimeout();
          };
          _proto.clearTimeout = function clearTimeout2() {
            if (this.reloadTimer !== -1) {
              self.clearTimeout(this.reloadTimer);
              this.reloadTimer = -1;
            }
          };
          _proto.destroy = function destroy() {
            this.unregisterListeners();
            this.stopLoad();
            this.hls = null;
            this.levels = this.audioTracks = this.subtitleTracks = null;
          };
          _proto.removeLevel = function removeLevel(levelToRemove) {
            var levels = this.levels;
            if (levels) {
              this.levels = levels.filter(function(level) {
                return level !== levelToRemove;
              });
            }
          };
          _proto.onManifestLoading = function onManifestLoading() {
            this.stopLoad();
            this.enabled = true;
            this.timeToLoad = 300;
            this.updated = 0;
            this.uri = null;
            this.pathwayId = ".";
            this.levels = this.audioTracks = this.subtitleTracks = null;
          };
          _proto.onManifestLoaded = function onManifestLoaded(event, data) {
            var contentSteering = data.contentSteering;
            if (contentSteering === null) {
              return;
            }
            this.pathwayId = contentSteering.pathwayId;
            this.uri = contentSteering.uri;
            if (this.started) {
              this.startLoad();
            }
          };
          _proto.onManifestParsed = function onManifestParsed(event, data) {
            this.audioTracks = data.audioTracks;
            this.subtitleTracks = data.subtitleTracks;
          };
          _proto.onError = function onError(event, data) {
            var errorAction = data.errorAction;
            if ((errorAction == null ? void 0 : errorAction.action) === NetworkErrorAction.SendAlternateToPenaltyBox && errorAction.flags === ErrorActionFlags.MoveAllAlternatesMatchingHost) {
              var levels = this.levels;
              var pathwayPriority = this._pathwayPriority;
              var errorPathway = this.pathwayId;
              if (data.context) {
                var _data$context = data.context, groupId = _data$context.groupId, pathwayId = _data$context.pathwayId, type = _data$context.type;
                if (groupId && levels) {
                  errorPathway = this.getPathwayForGroupId(groupId, type, errorPathway);
                } else if (pathwayId) {
                  errorPathway = pathwayId;
                }
              }
              if (!(errorPathway in this.penalizedPathways)) {
                this.penalizedPathways[errorPathway] = performance.now();
              }
              if (!pathwayPriority && levels) {
                pathwayPriority = this.pathways();
              }
              if (pathwayPriority && pathwayPriority.length > 1) {
                this.updatePathwayPriority(pathwayPriority);
                errorAction.resolved = this.pathwayId !== errorPathway;
              }
              if (!errorAction.resolved) {
                this.warn("Could not resolve " + data.details + ' ("' + data.error.message + '") with content-steering for Pathway: ' + errorPathway + " levels: " + (levels ? levels.length : levels) + " priorities: " + stringify2(pathwayPriority) + " penalized: " + stringify2(this.penalizedPathways));
              }
            }
          };
          _proto.filterParsedLevels = function filterParsedLevels(levels) {
            this.levels = levels;
            var pathwayLevels = this.getLevelsForPathway(this.pathwayId);
            if (pathwayLevels.length === 0) {
              var pathwayId = levels[0].pathwayId;
              this.log("No levels found in Pathway " + this.pathwayId + '. Setting initial Pathway to "' + pathwayId + '"');
              pathwayLevels = this.getLevelsForPathway(pathwayId);
              this.pathwayId = pathwayId;
            }
            if (pathwayLevels.length !== levels.length) {
              this.log("Found " + pathwayLevels.length + "/" + levels.length + ' levels in Pathway "' + this.pathwayId + '"');
            }
            return pathwayLevels;
          };
          _proto.getLevelsForPathway = function getLevelsForPathway(pathwayId) {
            if (this.levels === null) {
              return [];
            }
            return this.levels.filter(function(level) {
              return pathwayId === level.pathwayId;
            });
          };
          _proto.updatePathwayPriority = function updatePathwayPriority(pathwayPriority) {
            this._pathwayPriority = pathwayPriority;
            var levels;
            var penalizedPathways = this.penalizedPathways;
            var now2 = performance.now();
            Object.keys(penalizedPathways).forEach(function(pathwayId2) {
              if (now2 - penalizedPathways[pathwayId2] > PATHWAY_PENALTY_DURATION_MS) {
                delete penalizedPathways[pathwayId2];
              }
            });
            for (var i = 0; i < pathwayPriority.length; i++) {
              var pathwayId = pathwayPriority[i];
              if (pathwayId in penalizedPathways) {
                continue;
              }
              if (pathwayId === this.pathwayId) {
                return;
              }
              var selectedIndex = this.hls.nextLoadLevel;
              var selectedLevel = this.hls.levels[selectedIndex];
              levels = this.getLevelsForPathway(pathwayId);
              if (levels.length > 0) {
                this.log('Setting Pathway to "' + pathwayId + '"');
                this.pathwayId = pathwayId;
                reassignFragmentLevelIndexes(levels);
                this.hls.trigger(Events.LEVELS_UPDATED, {
                  levels
                });
                var levelAfterChange = this.hls.levels[selectedIndex];
                if (selectedLevel && levelAfterChange && this.levels) {
                  if (levelAfterChange.attrs["STABLE-VARIANT-ID"] !== selectedLevel.attrs["STABLE-VARIANT-ID"] && levelAfterChange.bitrate !== selectedLevel.bitrate) {
                    this.log("Unstable Pathways change from bitrate " + selectedLevel.bitrate + " to " + levelAfterChange.bitrate);
                  }
                  this.hls.nextLoadLevel = selectedIndex;
                }
                break;
              }
            }
          };
          _proto.getPathwayForGroupId = function getPathwayForGroupId(groupId, type, defaultPathway) {
            var levels = this.getLevelsForPathway(defaultPathway).concat(this.levels || []);
            for (var i = 0; i < levels.length; i++) {
              if (type === PlaylistContextType.AUDIO_TRACK && levels[i].hasAudioGroup(groupId) || type === PlaylistContextType.SUBTITLE_TRACK && levels[i].hasSubtitleGroup(groupId)) {
                return levels[i].pathwayId;
              }
            }
            return defaultPathway;
          };
          _proto.clonePathways = function clonePathways(pathwayClones) {
            var _this2 = this;
            var levels = this.levels;
            if (!levels) {
              return;
            }
            var audioGroupCloneMap = {};
            var subtitleGroupCloneMap = {};
            pathwayClones.forEach(function(pathwayClone) {
              var cloneId = pathwayClone.ID, baseId = pathwayClone["BASE-ID"], uriReplacement = pathwayClone["URI-REPLACEMENT"];
              if (levels.some(function(level) {
                return level.pathwayId === cloneId;
              })) {
                return;
              }
              var clonedVariants = _this2.getLevelsForPathway(baseId).map(function(baseLevel) {
                var attributes = new AttrList(baseLevel.attrs);
                attributes["PATHWAY-ID"] = cloneId;
                var clonedAudioGroupId = attributes.AUDIO && attributes.AUDIO + "_clone_" + cloneId;
                var clonedSubtitleGroupId = attributes.SUBTITLES && attributes.SUBTITLES + "_clone_" + cloneId;
                if (clonedAudioGroupId) {
                  audioGroupCloneMap[attributes.AUDIO] = clonedAudioGroupId;
                  attributes.AUDIO = clonedAudioGroupId;
                }
                if (clonedSubtitleGroupId) {
                  subtitleGroupCloneMap[attributes.SUBTITLES] = clonedSubtitleGroupId;
                  attributes.SUBTITLES = clonedSubtitleGroupId;
                }
                var url = performUriReplacement(baseLevel.uri, attributes["STABLE-VARIANT-ID"], "PER-VARIANT-URIS", uriReplacement);
                var clonedLevel = new Level({
                  attrs: attributes,
                  audioCodec: baseLevel.audioCodec,
                  bitrate: baseLevel.bitrate,
                  height: baseLevel.height,
                  name: baseLevel.name,
                  url,
                  videoCodec: baseLevel.videoCodec,
                  width: baseLevel.width
                });
                if (baseLevel.audioGroups) {
                  for (var i = 1; i < baseLevel.audioGroups.length; i++) {
                    clonedLevel.addGroupId("audio", baseLevel.audioGroups[i] + "_clone_" + cloneId);
                  }
                }
                if (baseLevel.subtitleGroups) {
                  for (var _i = 1; _i < baseLevel.subtitleGroups.length; _i++) {
                    clonedLevel.addGroupId("text", baseLevel.subtitleGroups[_i] + "_clone_" + cloneId);
                  }
                }
                return clonedLevel;
              });
              levels.push.apply(levels, clonedVariants);
              cloneRenditionGroups(_this2.audioTracks, audioGroupCloneMap, uriReplacement, cloneId);
              cloneRenditionGroups(_this2.subtitleTracks, subtitleGroupCloneMap, uriReplacement, cloneId);
            });
          };
          _proto.loadSteeringManifest = function loadSteeringManifest(uri) {
            var _this3 = this;
            var config = this.hls.config;
            var Loader = config.loader;
            if (this.loader) {
              this.loader.destroy();
            }
            this.loader = new Loader(config);
            var url;
            try {
              url = new self.URL(uri);
            } catch (error) {
              this.enabled = false;
              this.log("Failed to parse Steering Manifest URI: " + uri);
              return;
            }
            if (url.protocol !== "data:") {
              var throughput = (this.hls.bandwidthEstimate || config.abrEwmaDefaultEstimate) | 0;
              url.searchParams.set("_HLS_pathway", this.pathwayId);
              url.searchParams.set("_HLS_throughput", "" + throughput);
            }
            var context = {
              responseType: "json",
              url: url.href
            };
            var loadPolicy = config.steeringManifestLoadPolicy.default;
            var legacyRetryCompatibility = loadPolicy.errorRetry || loadPolicy.timeoutRetry || {};
            var loaderConfig = {
              loadPolicy,
              timeout: loadPolicy.maxLoadTimeMs,
              maxRetry: legacyRetryCompatibility.maxNumRetry || 0,
              retryDelay: legacyRetryCompatibility.retryDelayMs || 0,
              maxRetryDelay: legacyRetryCompatibility.maxRetryDelayMs || 0
            };
            var callbacks = {
              onSuccess: function onSuccess(response, stats, context2, networkDetails) {
                _this3.log('Loaded steering manifest: "' + url + '"');
                var steeringData = response.data;
                if ((steeringData == null ? void 0 : steeringData.VERSION) !== 1) {
                  _this3.log("Steering VERSION " + steeringData.VERSION + " not supported!");
                  return;
                }
                _this3.updated = performance.now();
                _this3.timeToLoad = steeringData.TTL;
                var reloadUri = steeringData["RELOAD-URI"], pathwayClones = steeringData["PATHWAY-CLONES"], pathwayPriority = steeringData["PATHWAY-PRIORITY"];
                if (reloadUri) {
                  try {
                    _this3.uri = new self.URL(reloadUri, url).href;
                  } catch (error) {
                    _this3.enabled = false;
                    _this3.log("Failed to parse Steering Manifest RELOAD-URI: " + reloadUri);
                    return;
                  }
                }
                _this3.scheduleRefresh(_this3.uri || context2.url);
                if (pathwayClones) {
                  _this3.clonePathways(pathwayClones);
                }
                var loadedSteeringData = {
                  steeringManifest: steeringData,
                  url: url.toString()
                };
                _this3.hls.trigger(Events.STEERING_MANIFEST_LOADED, loadedSteeringData);
                if (pathwayPriority) {
                  _this3.updatePathwayPriority(pathwayPriority);
                }
              },
              onError: function onError(error, context2, networkDetails, stats) {
                _this3.log("Error loading steering manifest: " + error.code + " " + error.text + " (" + context2.url + ")");
                _this3.stopLoad();
                if (error.code === 410) {
                  _this3.enabled = false;
                  _this3.log("Steering manifest " + context2.url + " no longer available");
                  return;
                }
                var ttl = _this3.timeToLoad * 1e3;
                if (error.code === 429) {
                  var loader = _this3.loader;
                  if (typeof (loader == null ? void 0 : loader.getResponseHeader) === "function") {
                    var retryAfter = loader.getResponseHeader("Retry-After");
                    if (retryAfter) {
                      ttl = parseFloat(retryAfter) * 1e3;
                    }
                  }
                  _this3.log("Steering manifest " + context2.url + " rate limited");
                  return;
                }
                _this3.scheduleRefresh(_this3.uri || context2.url, ttl);
              },
              onTimeout: function onTimeout(stats, context2, networkDetails) {
                _this3.log("Timeout loading steering manifest (" + context2.url + ")");
                _this3.scheduleRefresh(_this3.uri || context2.url);
              }
            };
            this.log("Requesting steering manifest: " + url);
            this.loader.load(context, loaderConfig, callbacks);
          };
          _proto.scheduleRefresh = function scheduleRefresh(uri, ttlMs) {
            var _this4 = this;
            if (ttlMs === void 0) {
              ttlMs = this.timeToLoad * 1e3;
            }
            this.clearTimeout();
            this.reloadTimer = self.setTimeout(function() {
              var _this4$hls;
              var media = (_this4$hls = _this4.hls) == null ? void 0 : _this4$hls.media;
              if (media && !media.ended) {
                _this4.loadSteeringManifest(uri);
                return;
              }
              _this4.scheduleRefresh(uri, _this4.timeToLoad * 1e3);
            }, ttlMs);
          };
          return _createClass4(ContentSteeringController2, [{
            key: "pathwayPriority",
            get: function get() {
              return this._pathwayPriority;
            },
            set: function set(pathwayPriority) {
              this.updatePathwayPriority(pathwayPriority);
            }
          }]);
        }(Logger4);
        function cloneRenditionGroups(tracks, groupCloneMap, uriReplacement, cloneId) {
          if (!tracks) {
            return;
          }
          Object.keys(groupCloneMap).forEach(function(audioGroupId) {
            var clonedTracks = tracks.filter(function(track) {
              return track.groupId === audioGroupId;
            }).map(function(track) {
              var clonedTrack = _extends({}, track);
              clonedTrack.details = void 0;
              clonedTrack.attrs = new AttrList(clonedTrack.attrs);
              clonedTrack.url = clonedTrack.attrs.URI = performUriReplacement(track.url, track.attrs["STABLE-RENDITION-ID"], "PER-RENDITION-URIS", uriReplacement);
              clonedTrack.groupId = clonedTrack.attrs["GROUP-ID"] = groupCloneMap[audioGroupId];
              clonedTrack.attrs["PATHWAY-ID"] = cloneId;
              return clonedTrack;
            });
            tracks.push.apply(tracks, clonedTracks);
          });
        }
        function performUriReplacement(uri, stableId, perOptionKey, uriReplacement) {
          var host = uriReplacement.HOST, params = uriReplacement.PARAMS, perOptionUris = uriReplacement[perOptionKey];
          var perVariantUri;
          if (stableId) {
            perVariantUri = perOptionUris == null ? void 0 : perOptionUris[stableId];
            if (perVariantUri) {
              uri = perVariantUri;
            }
          }
          var url = new self.URL(uri);
          if (host && !perVariantUri) {
            url.host = host;
          }
          if (params) {
            Object.keys(params).sort().forEach(function(key) {
              if (key) {
                url.searchParams.set(key, params[key]);
              }
            });
          }
          return url.href;
        }
        var FPSController = /* @__PURE__ */ function() {
          function FPSController2(hls) {
            this.hls = void 0;
            this.isVideoPlaybackQualityAvailable = false;
            this.timer = void 0;
            this.media = null;
            this.lastTime = void 0;
            this.lastDroppedFrames = 0;
            this.lastDecodedFrames = 0;
            this.streamController = void 0;
            this.hls = hls;
            this.registerListeners();
          }
          var _proto = FPSController2.prototype;
          _proto.setStreamController = function setStreamController(streamController) {
            this.streamController = streamController;
          };
          _proto.registerListeners = function registerListeners() {
            this.hls.on(Events.MEDIA_ATTACHING, this.onMediaAttaching, this);
            this.hls.on(Events.MEDIA_DETACHING, this.onMediaDetaching, this);
          };
          _proto.unregisterListeners = function unregisterListeners() {
            this.hls.off(Events.MEDIA_ATTACHING, this.onMediaAttaching, this);
            this.hls.off(Events.MEDIA_DETACHING, this.onMediaDetaching, this);
          };
          _proto.destroy = function destroy() {
            if (this.timer) {
              clearInterval(this.timer);
            }
            this.unregisterListeners();
            this.isVideoPlaybackQualityAvailable = false;
            this.media = null;
          };
          _proto.onMediaAttaching = function onMediaAttaching(event, data) {
            var config = this.hls.config;
            if (config.capLevelOnFPSDrop) {
              var media = data.media instanceof self.HTMLVideoElement ? data.media : null;
              this.media = media;
              if (media && typeof media.getVideoPlaybackQuality === "function") {
                this.isVideoPlaybackQualityAvailable = true;
              }
              self.clearInterval(this.timer);
              this.timer = self.setInterval(this.checkFPSInterval.bind(this), config.fpsDroppedMonitoringPeriod);
            }
          };
          _proto.onMediaDetaching = function onMediaDetaching() {
            this.media = null;
          };
          _proto.checkFPS = function checkFPS(video, decodedFrames, droppedFrames) {
            var currentTime = performance.now();
            if (decodedFrames) {
              if (this.lastTime) {
                var currentPeriod = currentTime - this.lastTime;
                var currentDropped = droppedFrames - this.lastDroppedFrames;
                var currentDecoded = decodedFrames - this.lastDecodedFrames;
                var droppedFPS = 1e3 * currentDropped / currentPeriod;
                var hls = this.hls;
                hls.trigger(Events.FPS_DROP, {
                  currentDropped,
                  currentDecoded,
                  totalDroppedFrames: droppedFrames
                });
                if (droppedFPS > 0) {
                  if (currentDropped > hls.config.fpsDroppedMonitoringThreshold * currentDecoded) {
                    var currentLevel = hls.currentLevel;
                    hls.logger.warn("drop FPS ratio greater than max allowed value for currentLevel: " + currentLevel);
                    if (currentLevel > 0 && (hls.autoLevelCapping === -1 || hls.autoLevelCapping >= currentLevel)) {
                      currentLevel = currentLevel - 1;
                      hls.trigger(Events.FPS_DROP_LEVEL_CAPPING, {
                        level: currentLevel,
                        droppedLevel: hls.currentLevel
                      });
                      hls.autoLevelCapping = currentLevel;
                      this.streamController.nextLevelSwitch();
                    }
                  }
                }
              }
              this.lastTime = currentTime;
              this.lastDroppedFrames = droppedFrames;
              this.lastDecodedFrames = decodedFrames;
            }
          };
          _proto.checkFPSInterval = function checkFPSInterval() {
            var video = this.media;
            if (video) {
              if (this.isVideoPlaybackQualityAvailable) {
                var videoPlaybackQuality = video.getVideoPlaybackQuality();
                this.checkFPS(video, videoPlaybackQuality.totalVideoFrames, videoPlaybackQuality.droppedVideoFrames);
              } else {
                this.checkFPS(video, video.webkitDecodedFrameCount, video.webkitDroppedFrameCount);
              }
            }
          };
          return FPSController2;
        }();
        var ChunkCache = /* @__PURE__ */ function() {
          function ChunkCache2() {
            this.chunks = [];
            this.dataLength = 0;
          }
          var _proto = ChunkCache2.prototype;
          _proto.push = function push2(chunk) {
            this.chunks.push(chunk);
            this.dataLength += chunk.length;
          };
          _proto.flush = function flush() {
            var chunks = this.chunks, dataLength = this.dataLength;
            var result;
            if (!chunks.length) {
              return new Uint8Array(0);
            } else if (chunks.length === 1) {
              result = chunks[0];
            } else {
              result = concatUint8Arrays(chunks, dataLength);
            }
            this.reset();
            return result;
          };
          _proto.reset = function reset() {
            this.chunks.length = 0;
            this.dataLength = 0;
          };
          return ChunkCache2;
        }();
        function concatUint8Arrays(chunks, dataLength) {
          var result = new Uint8Array(dataLength);
          var offset = 0;
          for (var i = 0; i < chunks.length; i++) {
            var chunk = chunks[i];
            result.set(chunk, offset);
            offset += chunk.length;
          }
          return result;
        }
        function isId3Footer(data, offset) {
          if (offset + 10 <= data.length) {
            if (data[offset] === 51 && data[offset + 1] === 68 && data[offset + 2] === 73) {
              if (data[offset + 3] < 255 && data[offset + 4] < 255) {
                if (data[offset + 6] < 128 && data[offset + 7] < 128 && data[offset + 8] < 128 && data[offset + 9] < 128) {
                  return true;
                }
              }
            }
          }
          return false;
        }
        function isId3Header(data, offset) {
          if (offset + 10 <= data.length) {
            if (data[offset] === 73 && data[offset + 1] === 68 && data[offset + 2] === 51) {
              if (data[offset + 3] < 255 && data[offset + 4] < 255) {
                if (data[offset + 6] < 128 && data[offset + 7] < 128 && data[offset + 8] < 128 && data[offset + 9] < 128) {
                  return true;
                }
              }
            }
          }
          return false;
        }
        function readId3Size(data, offset) {
          var size = 0;
          size = (data[offset] & 127) << 21;
          size |= (data[offset + 1] & 127) << 14;
          size |= (data[offset + 2] & 127) << 7;
          size |= data[offset + 3] & 127;
          return size;
        }
        function getId3Data(data, offset) {
          var front = offset;
          var length = 0;
          while (isId3Header(data, offset)) {
            length += 10;
            var size = readId3Size(data, offset + 6);
            length += size;
            if (isId3Footer(data, offset + 10)) {
              length += 10;
            }
            offset += length;
          }
          if (length > 0) {
            return data.subarray(front, front + length);
          }
          return void 0;
        }
        function getAudioConfig(observer, data, offset, manifestCodec) {
          var adtsSamplingRates = [96e3, 88200, 64e3, 48e3, 44100, 32e3, 24e3, 22050, 16e3, 12e3, 11025, 8e3, 7350];
          var byte2 = data[offset + 2];
          var adtsSamplingIndex = byte2 >> 2 & 15;
          if (adtsSamplingIndex > 12) {
            var error = new Error("invalid ADTS sampling index:" + adtsSamplingIndex);
            observer.emit(Events.ERROR, Events.ERROR, {
              type: ErrorTypes.MEDIA_ERROR,
              details: ErrorDetails.FRAG_PARSING_ERROR,
              fatal: true,
              error,
              reason: error.message
            });
            return;
          }
          var adtsObjectType = (byte2 >> 6 & 3) + 1;
          var channelCount = data[offset + 3] >> 6 & 3 | (byte2 & 1) << 2;
          var codec = "mp4a.40." + adtsObjectType;
          var samplerate = adtsSamplingRates[adtsSamplingIndex];
          var aacSampleIndex = adtsSamplingIndex;
          if (adtsObjectType === 5 || adtsObjectType === 29) {
            aacSampleIndex -= 3;
          }
          var config = [adtsObjectType << 3 | (aacSampleIndex & 14) >> 1, (aacSampleIndex & 1) << 7 | channelCount << 3];
          logger4.log("manifest codec:" + manifestCodec + ", parsed codec:" + codec + ", channels:" + channelCount + ", rate:" + samplerate + " (ADTS object type:" + adtsObjectType + " sampling index:" + adtsSamplingIndex + ")");
          return {
            config,
            samplerate,
            channelCount,
            codec,
            parsedCodec: codec,
            manifestCodec
          };
        }
        function isHeaderPattern$1(data, offset) {
          return data[offset] === 255 && (data[offset + 1] & 246) === 240;
        }
        function getHeaderLength(data, offset) {
          return data[offset + 1] & 1 ? 7 : 9;
        }
        function getFullFrameLength(data, offset) {
          return (data[offset + 3] & 3) << 11 | data[offset + 4] << 3 | (data[offset + 5] & 224) >>> 5;
        }
        function canGetFrameLength(data, offset) {
          return offset + 5 < data.length;
        }
        function isHeader$1(data, offset) {
          return offset + 1 < data.length && isHeaderPattern$1(data, offset);
        }
        function canParse$1(data, offset) {
          return canGetFrameLength(data, offset) && isHeaderPattern$1(data, offset) && getFullFrameLength(data, offset) <= data.length - offset;
        }
        function probe$1(data, offset) {
          if (isHeader$1(data, offset)) {
            var headerLength = getHeaderLength(data, offset);
            if (offset + headerLength >= data.length) {
              return false;
            }
            var frameLength = getFullFrameLength(data, offset);
            if (frameLength <= headerLength) {
              return false;
            }
            var newOffset = offset + frameLength;
            return newOffset === data.length || isHeader$1(data, newOffset);
          }
          return false;
        }
        function initTrackConfig(track, observer, data, offset, audioCodec) {
          if (!track.samplerate) {
            var config = getAudioConfig(observer, data, offset, audioCodec);
            if (!config) {
              return;
            }
            _extends(track, config);
          }
        }
        function getFrameDuration(samplerate) {
          return 1024 * 9e4 / samplerate;
        }
        function parseFrameHeader(data, offset) {
          var headerLength = getHeaderLength(data, offset);
          if (offset + headerLength <= data.length) {
            var frameLength = getFullFrameLength(data, offset) - headerLength;
            if (frameLength > 0) {
              return {
                headerLength,
                frameLength
              };
            }
          }
        }
        function appendFrame$1(track, data, offset, pts, frameIndex) {
          var frameDuration = getFrameDuration(track.samplerate);
          var stamp = pts + frameIndex * frameDuration;
          var header = parseFrameHeader(data, offset);
          var unit;
          if (header) {
            var frameLength = header.frameLength, headerLength = header.headerLength;
            var _length = headerLength + frameLength;
            var missing = Math.max(0, offset + _length - data.length);
            if (missing) {
              unit = new Uint8Array(_length - headerLength);
              unit.set(data.subarray(offset + headerLength, data.length), 0);
            } else {
              unit = data.subarray(offset + headerLength, offset + _length);
            }
            var _sample = {
              unit,
              pts: stamp
            };
            if (!missing) {
              track.samples.push(_sample);
            }
            return {
              sample: _sample,
              length: _length,
              missing
            };
          }
          var length = data.length - offset;
          unit = new Uint8Array(length);
          unit.set(data.subarray(offset, data.length), 0);
          var sample = {
            unit,
            pts: stamp
          };
          return {
            sample,
            length,
            missing: -1
          };
        }
        function canParseId3(data, offset) {
          return isId3Header(data, offset) && readId3Size(data, offset + 6) + 10 <= data.length - offset;
        }
        function decodeId3PrivFrame(frame) {
          if (frame.size < 2) {
            return void 0;
          }
          var owner = utf8ArrayToStr(frame.data, true);
          var privateData = new Uint8Array(frame.data.subarray(owner.length + 1));
          return {
            key: frame.type,
            info: owner,
            data: privateData.buffer
          };
        }
        function decodeId3TextFrame(frame) {
          if (frame.size < 2) {
            return void 0;
          }
          if (frame.type === "TXXX") {
            var index = 1;
            var description = utf8ArrayToStr(frame.data.subarray(index), true);
            index += description.length + 1;
            var value = utf8ArrayToStr(frame.data.subarray(index));
            return {
              key: frame.type,
              info: description,
              data: value
            };
          }
          var text = utf8ArrayToStr(frame.data.subarray(1));
          return {
            key: frame.type,
            info: "",
            data: text
          };
        }
        function decodeId3UrlFrame(frame) {
          if (frame.type === "WXXX") {
            if (frame.size < 2) {
              return void 0;
            }
            var index = 1;
            var description = utf8ArrayToStr(frame.data.subarray(index), true);
            index += description.length + 1;
            var value = utf8ArrayToStr(frame.data.subarray(index));
            return {
              key: frame.type,
              info: description,
              data: value
            };
          }
          var url = utf8ArrayToStr(frame.data);
          return {
            key: frame.type,
            info: "",
            data: url
          };
        }
        function toArrayBuffer(view2) {
          if (view2 instanceof ArrayBuffer) {
            return view2;
          } else {
            if (view2.byteOffset == 0 && view2.byteLength == view2.buffer.byteLength) {
              return view2.buffer;
            }
            return new Uint8Array(view2).buffer;
          }
        }
        function toUint8(data, offset, length) {
          if (offset === void 0) {
            offset = 0;
          }
          if (length === void 0) {
            length = Infinity;
          }
          return view(data, offset, length, Uint8Array);
        }
        function view(data, offset, length, Type) {
          var buffer = unsafeGetArrayBuffer(data);
          var bytesPerElement = 1;
          if ("BYTES_PER_ELEMENT" in Type) {
            bytesPerElement = Type.BYTES_PER_ELEMENT;
          }
          var dataOffset = isArrayBufferView(data) ? data.byteOffset : 0;
          var dataEnd = (dataOffset + data.byteLength) / bytesPerElement;
          var rawStart = (dataOffset + offset) / bytesPerElement;
          var start = Math.floor(Math.max(0, Math.min(rawStart, dataEnd)));
          var end = Math.floor(Math.min(start + Math.max(length, 0), dataEnd));
          return new Type(buffer, start, end - start);
        }
        function unsafeGetArrayBuffer(view2) {
          if (view2 instanceof ArrayBuffer) {
            return view2;
          } else {
            return view2.buffer;
          }
        }
        function isArrayBufferView(obj) {
          return obj && obj.buffer instanceof ArrayBuffer && obj.byteLength !== void 0 && obj.byteOffset !== void 0;
        }
        function decodeId3ImageFrame(frame) {
          var metadataFrame = {
            key: frame.type,
            description: "",
            data: "",
            mimeType: null,
            pictureType: null
          };
          var utf8Encoding = 3;
          if (frame.size < 2) {
            return void 0;
          }
          if (frame.data[0] !== utf8Encoding) {
            console.log("Ignore frame with unrecognized character encoding");
            return void 0;
          }
          var mimeTypeEndIndex = frame.data.subarray(1).indexOf(0);
          if (mimeTypeEndIndex === -1) {
            return void 0;
          }
          var mimeType = utf8ArrayToStr(toUint8(frame.data, 1, mimeTypeEndIndex));
          var pictureType = frame.data[2 + mimeTypeEndIndex];
          var descriptionEndIndex = frame.data.subarray(3 + mimeTypeEndIndex).indexOf(0);
          if (descriptionEndIndex === -1) {
            return void 0;
          }
          var description = utf8ArrayToStr(toUint8(frame.data, 3 + mimeTypeEndIndex, descriptionEndIndex));
          var data;
          if (mimeType === "-->") {
            data = utf8ArrayToStr(toUint8(frame.data, 4 + mimeTypeEndIndex + descriptionEndIndex));
          } else {
            data = toArrayBuffer(frame.data.subarray(4 + mimeTypeEndIndex + descriptionEndIndex));
          }
          metadataFrame.mimeType = mimeType;
          metadataFrame.pictureType = pictureType;
          metadataFrame.description = description;
          metadataFrame.data = data;
          return metadataFrame;
        }
        function decodeId3Frame(frame) {
          if (frame.type === "PRIV") {
            return decodeId3PrivFrame(frame);
          } else if (frame.type[0] === "W") {
            return decodeId3UrlFrame(frame);
          } else if (frame.type === "APIC") {
            return decodeId3ImageFrame(frame);
          }
          return decodeId3TextFrame(frame);
        }
        function getId3FrameData(data) {
          var type = String.fromCharCode(data[0], data[1], data[2], data[3]);
          var size = readId3Size(data, 4);
          var offset = 10;
          return {
            type,
            size,
            data: data.subarray(offset, offset + size)
          };
        }
        var HEADER_FOOTER_SIZE = 10;
        var FRAME_SIZE = 10;
        function getId3Frames(id3Data) {
          var offset = 0;
          var frames = [];
          while (isId3Header(id3Data, offset)) {
            var size = readId3Size(id3Data, offset + 6);
            if (id3Data[offset + 5] >> 6 & 1) {
              offset += HEADER_FOOTER_SIZE;
            }
            offset += HEADER_FOOTER_SIZE;
            var end = offset + size;
            while (offset + FRAME_SIZE < end) {
              var frameData = getId3FrameData(id3Data.subarray(offset));
              var frame = decodeId3Frame(frameData);
              if (frame) {
                frames.push(frame);
              }
              offset += frameData.size + HEADER_FOOTER_SIZE;
            }
            if (isId3Footer(id3Data, offset)) {
              offset += HEADER_FOOTER_SIZE;
            }
          }
          return frames;
        }
        function isId3TimestampFrame(frame) {
          return frame && frame.key === "PRIV" && frame.info === "com.apple.streaming.transportStreamTimestamp";
        }
        function readId3Timestamp(timeStampFrame) {
          if (timeStampFrame.data.byteLength === 8) {
            var data = new Uint8Array(timeStampFrame.data);
            var pts33Bit = data[3] & 1;
            var timestamp = (data[4] << 23) + (data[5] << 15) + (data[6] << 7) + data[7];
            timestamp /= 45;
            if (pts33Bit) {
              timestamp += 4772185884e-2;
            }
            return Math.round(timestamp);
          }
          return void 0;
        }
        function getId3Timestamp(data) {
          var frames = getId3Frames(data);
          for (var i = 0; i < frames.length; i++) {
            var frame = frames[i];
            if (isId3TimestampFrame(frame)) {
              return readId3Timestamp(frame);
            }
          }
          return void 0;
        }
        var MetadataSchema = /* @__PURE__ */ function(MetadataSchema2) {
          MetadataSchema2["audioId3"] = "org.id3";
          MetadataSchema2["dateRange"] = "com.apple.quicktime.HLS";
          MetadataSchema2["emsg"] = "https://aomedia.org/emsg/ID3";
          MetadataSchema2["misbklv"] = "urn:misb:KLV:bin:1910.1";
          return MetadataSchema2;
        }({});
        function dummyTrack(type, inputTimeScale) {
          if (type === void 0) {
            type = "";
          }
          if (inputTimeScale === void 0) {
            inputTimeScale = 9e4;
          }
          return {
            type,
            id: -1,
            pid: -1,
            inputTimeScale,
            sequenceNumber: -1,
            samples: [],
            dropped: 0
          };
        }
        var BaseAudioDemuxer = /* @__PURE__ */ function() {
          function BaseAudioDemuxer2() {
            this._audioTrack = void 0;
            this._id3Track = void 0;
            this.frameIndex = 0;
            this.cachedData = null;
            this.basePTS = null;
            this.initPTS = null;
            this.lastPTS = null;
          }
          var _proto = BaseAudioDemuxer2.prototype;
          _proto.resetInitSegment = function resetInitSegment(initSegment, audioCodec, videoCodec, trackDuration) {
            this._id3Track = {
              type: "id3",
              id: 3,
              pid: -1,
              inputTimeScale: 9e4,
              sequenceNumber: 0,
              samples: [],
              dropped: 0
            };
          };
          _proto.resetTimeStamp = function resetTimeStamp(deaultTimestamp) {
            this.initPTS = deaultTimestamp;
            this.resetContiguity();
          };
          _proto.resetContiguity = function resetContiguity() {
            this.basePTS = null;
            this.lastPTS = null;
            this.frameIndex = 0;
          };
          _proto.canParse = function canParse2(data, offset) {
            return false;
          };
          _proto.appendFrame = function appendFrame2(track, data, offset) {
          };
          _proto.demux = function demux(data, timeOffset) {
            if (this.cachedData) {
              data = appendUint8Array(this.cachedData, data);
              this.cachedData = null;
            }
            var id3Data = getId3Data(data, 0);
            var offset = id3Data ? id3Data.length : 0;
            var lastDataIndex;
            var track = this._audioTrack;
            var id3Track = this._id3Track;
            var timestamp = id3Data ? getId3Timestamp(id3Data) : void 0;
            var length = data.length;
            if (this.basePTS === null || this.frameIndex === 0 && isFiniteNumber(timestamp)) {
              this.basePTS = initPTSFn(timestamp, timeOffset, this.initPTS);
              this.lastPTS = this.basePTS;
            }
            if (this.lastPTS === null) {
              this.lastPTS = this.basePTS;
            }
            if (id3Data && id3Data.length > 0) {
              id3Track.samples.push({
                pts: this.lastPTS,
                dts: this.lastPTS,
                data: id3Data,
                type: MetadataSchema.audioId3,
                duration: Number.POSITIVE_INFINITY
              });
            }
            while (offset < length) {
              if (this.canParse(data, offset)) {
                var frame = this.appendFrame(track, data, offset);
                if (frame) {
                  this.frameIndex++;
                  this.lastPTS = frame.sample.pts;
                  offset += frame.length;
                  lastDataIndex = offset;
                } else {
                  offset = length;
                }
              } else if (canParseId3(data, offset)) {
                id3Data = getId3Data(data, offset);
                id3Track.samples.push({
                  pts: this.lastPTS,
                  dts: this.lastPTS,
                  data: id3Data,
                  type: MetadataSchema.audioId3,
                  duration: Number.POSITIVE_INFINITY
                });
                offset += id3Data.length;
                lastDataIndex = offset;
              } else {
                offset++;
              }
              if (offset === length && lastDataIndex !== length) {
                var partialData = data.slice(lastDataIndex);
                if (this.cachedData) {
                  this.cachedData = appendUint8Array(this.cachedData, partialData);
                } else {
                  this.cachedData = partialData;
                }
              }
            }
            return {
              audioTrack: track,
              videoTrack: dummyTrack(),
              id3Track,
              textTrack: dummyTrack()
            };
          };
          _proto.demuxSampleAes = function demuxSampleAes(data, keyData, timeOffset) {
            return Promise.reject(new Error("[" + this + "] This demuxer does not support Sample-AES decryption"));
          };
          _proto.flush = function flush(timeOffset) {
            var cachedData = this.cachedData;
            if (cachedData) {
              this.cachedData = null;
              this.demux(cachedData, 0);
            }
            return {
              audioTrack: this._audioTrack,
              videoTrack: dummyTrack(),
              id3Track: this._id3Track,
              textTrack: dummyTrack()
            };
          };
          _proto.destroy = function destroy() {
            this.cachedData = null;
            this._audioTrack = this._id3Track = void 0;
          };
          return BaseAudioDemuxer2;
        }();
        var initPTSFn = function initPTSFn2(timestamp, timeOffset, initPTS) {
          if (isFiniteNumber(timestamp)) {
            return timestamp * 90;
          }
          var init90kHz = initPTS ? initPTS.baseTime * 9e4 / initPTS.timescale : 0;
          return timeOffset * 9e4 + init90kHz;
        };
        var chromeVersion$1 = null;
        var BitratesMap = [32, 64, 96, 128, 160, 192, 224, 256, 288, 320, 352, 384, 416, 448, 32, 48, 56, 64, 80, 96, 112, 128, 160, 192, 224, 256, 320, 384, 32, 40, 48, 56, 64, 80, 96, 112, 128, 160, 192, 224, 256, 320, 32, 48, 56, 64, 80, 96, 112, 128, 144, 160, 176, 192, 224, 256, 8, 16, 24, 32, 40, 48, 56, 64, 80, 96, 112, 128, 144, 160];
        var SamplingRateMap = [44100, 48e3, 32e3, 22050, 24e3, 16e3, 11025, 12e3, 8e3];
        var SamplesCoefficients = [
          // MPEG 2.5
          [
            0,
            // Reserved
            72,
            // Layer3
            144,
            // Layer2
            12
            // Layer1
          ],
          // Reserved
          [
            0,
            // Reserved
            0,
            // Layer3
            0,
            // Layer2
            0
            // Layer1
          ],
          // MPEG 2
          [
            0,
            // Reserved
            72,
            // Layer3
            144,
            // Layer2
            12
            // Layer1
          ],
          // MPEG 1
          [
            0,
            // Reserved
            144,
            // Layer3
            144,
            // Layer2
            12
            // Layer1
          ]
        ];
        var BytesInSlot = [
          0,
          // Reserved
          1,
          // Layer3
          1,
          // Layer2
          4
          // Layer1
        ];
        function appendFrame(track, data, offset, pts, frameIndex) {
          if (offset + 24 > data.length) {
            return;
          }
          var header = parseHeader(data, offset);
          if (header && offset + header.frameLength <= data.length) {
            var frameDuration = header.samplesPerFrame * 9e4 / header.sampleRate;
            var stamp = pts + frameIndex * frameDuration;
            var sample = {
              unit: data.subarray(offset, offset + header.frameLength),
              pts: stamp,
              dts: stamp
            };
            track.config = [];
            track.channelCount = header.channelCount;
            track.samplerate = header.sampleRate;
            track.samples.push(sample);
            return {
              sample,
              length: header.frameLength,
              missing: 0
            };
          }
        }
        function parseHeader(data, offset) {
          var mpegVersion = data[offset + 1] >> 3 & 3;
          var mpegLayer = data[offset + 1] >> 1 & 3;
          var bitRateIndex = data[offset + 2] >> 4 & 15;
          var sampleRateIndex = data[offset + 2] >> 2 & 3;
          if (mpegVersion !== 1 && bitRateIndex !== 0 && bitRateIndex !== 15 && sampleRateIndex !== 3) {
            var paddingBit = data[offset + 2] >> 1 & 1;
            var channelMode = data[offset + 3] >> 6;
            var columnInBitrates = mpegVersion === 3 ? 3 - mpegLayer : mpegLayer === 3 ? 3 : 4;
            var bitRate = BitratesMap[columnInBitrates * 14 + bitRateIndex - 1] * 1e3;
            var columnInSampleRates = mpegVersion === 3 ? 0 : mpegVersion === 2 ? 1 : 2;
            var sampleRate = SamplingRateMap[columnInSampleRates * 3 + sampleRateIndex];
            var channelCount = channelMode === 3 ? 1 : 2;
            var sampleCoefficient = SamplesCoefficients[mpegVersion][mpegLayer];
            var bytesInSlot = BytesInSlot[mpegLayer];
            var samplesPerFrame = sampleCoefficient * 8 * bytesInSlot;
            var frameLength = Math.floor(sampleCoefficient * bitRate / sampleRate + paddingBit) * bytesInSlot;
            if (chromeVersion$1 === null) {
              var userAgent = navigator.userAgent || "";
              var result = userAgent.match(/Chrome\/(\d+)/i);
              chromeVersion$1 = result ? parseInt(result[1]) : 0;
            }
            var needChromeFix = !!chromeVersion$1 && chromeVersion$1 <= 87;
            if (needChromeFix && mpegLayer === 2 && bitRate >= 224e3 && channelMode === 0) {
              data[offset + 3] = data[offset + 3] | 128;
            }
            return {
              sampleRate,
              channelCount,
              frameLength,
              samplesPerFrame
            };
          }
        }
        function isHeaderPattern(data, offset) {
          return data[offset] === 255 && (data[offset + 1] & 224) === 224 && (data[offset + 1] & 6) !== 0;
        }
        function isHeader(data, offset) {
          return offset + 1 < data.length && isHeaderPattern(data, offset);
        }
        function canParse(data, offset) {
          var headerSize = 4;
          return isHeaderPattern(data, offset) && headerSize <= data.length - offset;
        }
        function probe(data, offset) {
          if (offset + 1 < data.length && isHeaderPattern(data, offset)) {
            var headerLength = 4;
            var header = parseHeader(data, offset);
            var frameLength = headerLength;
            if (header != null && header.frameLength) {
              frameLength = header.frameLength;
            }
            var newOffset = offset + frameLength;
            return newOffset === data.length || isHeader(data, newOffset);
          }
          return false;
        }
        var AACDemuxer = /* @__PURE__ */ function(_BaseAudioDemuxer) {
          function AACDemuxer2(observer, config) {
            var _this;
            _this = _BaseAudioDemuxer.call(this) || this;
            _this.observer = void 0;
            _this.config = void 0;
            _this.observer = observer;
            _this.config = config;
            return _this;
          }
          _inheritsLoose(AACDemuxer2, _BaseAudioDemuxer);
          var _proto = AACDemuxer2.prototype;
          _proto.resetInitSegment = function resetInitSegment(initSegment, audioCodec, videoCodec, trackDuration) {
            _BaseAudioDemuxer.prototype.resetInitSegment.call(this, initSegment, audioCodec, videoCodec, trackDuration);
            this._audioTrack = {
              container: "audio/adts",
              type: "audio",
              id: 2,
              pid: -1,
              sequenceNumber: 0,
              segmentCodec: "aac",
              samples: [],
              manifestCodec: audioCodec,
              duration: trackDuration,
              inputTimeScale: 9e4,
              dropped: 0
            };
          };
          AACDemuxer2.probe = function probe$2(data, logger5) {
            if (!data) {
              return false;
            }
            var id3Data = getId3Data(data, 0);
            var offset = (id3Data == null ? void 0 : id3Data.length) || 0;
            if (probe(data, offset)) {
              return false;
            }
            for (var length = data.length; offset < length; offset++) {
              if (probe$1(data, offset)) {
                logger5.log("ADTS sync word found !");
                return true;
              }
            }
            return false;
          };
          _proto.canParse = function canParse2(data, offset) {
            return canParse$1(data, offset);
          };
          _proto.appendFrame = function appendFrame2(track, data, offset) {
            initTrackConfig(track, this.observer, data, offset, track.manifestCodec);
            var frame = appendFrame$1(track, data, offset, this.basePTS, this.frameIndex);
            if (frame && frame.missing === 0) {
              return frame;
            }
          };
          return AACDemuxer2;
        }(BaseAudioDemuxer);
        var getAudioBSID = function getAudioBSID2(data, offset) {
          var bsid = 0;
          var numBits = 5;
          offset += numBits;
          var temp = new Uint32Array(1);
          var mask = new Uint32Array(1);
          var _byte = new Uint8Array(1);
          while (numBits > 0) {
            _byte[0] = data[offset];
            var bits = Math.min(numBits, 8);
            var shift = 8 - bits;
            mask[0] = 4278190080 >>> 24 + shift << shift;
            temp[0] = (_byte[0] & mask[0]) >> shift;
            bsid = !bsid ? temp[0] : bsid << bits | temp[0];
            offset += 1;
            numBits -= bits;
          }
          return bsid;
        };
        var MP3Demuxer = /* @__PURE__ */ function(_BaseAudioDemuxer) {
          function MP3Demuxer2() {
            return _BaseAudioDemuxer.apply(this, arguments) || this;
          }
          _inheritsLoose(MP3Demuxer2, _BaseAudioDemuxer);
          var _proto = MP3Demuxer2.prototype;
          _proto.resetInitSegment = function resetInitSegment(initSegment, audioCodec, videoCodec, trackDuration) {
            _BaseAudioDemuxer.prototype.resetInitSegment.call(this, initSegment, audioCodec, videoCodec, trackDuration);
            this._audioTrack = {
              container: "audio/mpeg",
              type: "audio",
              id: 2,
              pid: -1,
              sequenceNumber: 0,
              segmentCodec: "mp3",
              samples: [],
              manifestCodec: audioCodec,
              duration: trackDuration,
              inputTimeScale: 9e4,
              dropped: 0
            };
          };
          MP3Demuxer2.probe = function probe$12(data) {
            if (!data) {
              return false;
            }
            var id3Data = getId3Data(data, 0);
            var offset = (id3Data == null ? void 0 : id3Data.length) || 0;
            if (id3Data && data[offset] === 11 && data[offset + 1] === 119 && getId3Timestamp(id3Data) !== void 0 && // check the bsid to confirm ac-3 or ec-3 (not mp3)
            getAudioBSID(data, offset) <= 16) {
              return false;
            }
            for (var length = data.length; offset < length; offset++) {
              if (probe(data, offset)) {
                logger4.log("MPEG Audio sync word found !");
                return true;
              }
            }
            return false;
          };
          _proto.canParse = function canParse$12(data, offset) {
            return canParse(data, offset);
          };
          _proto.appendFrame = function appendFrame$12(track, data, offset) {
            if (this.basePTS === null) {
              return;
            }
            return appendFrame(track, data, offset, this.basePTS, this.frameIndex);
          };
          return MP3Demuxer2;
        }(BaseAudioDemuxer);
        var AESCrypto = /* @__PURE__ */ function() {
          function AESCrypto2(subtle, iv, aesMode) {
            this.subtle = void 0;
            this.aesIV = void 0;
            this.aesMode = void 0;
            this.subtle = subtle;
            this.aesIV = iv;
            this.aesMode = aesMode;
          }
          var _proto = AESCrypto2.prototype;
          _proto.decrypt = function decrypt(data, key) {
            switch (this.aesMode) {
              case DecrypterAesMode.cbc:
                return this.subtle.decrypt({
                  name: "AES-CBC",
                  iv: this.aesIV
                }, key, data);
              case DecrypterAesMode.ctr:
                return this.subtle.decrypt(
                  {
                    name: "AES-CTR",
                    counter: this.aesIV,
                    length: 64
                  },
                  //64 : NIST SP800-38A standard suggests that the counter should occupy half of the counter block
                  key,
                  data
                );
              default:
                throw new Error("[AESCrypto] invalid aes mode " + this.aesMode);
            }
          };
          return AESCrypto2;
        }();
        function removePadding(array) {
          var outputBytes = array.byteLength;
          var paddingBytes = outputBytes && new DataView(array.buffer).getUint8(outputBytes - 1);
          if (paddingBytes) {
            return array.slice(0, outputBytes - paddingBytes);
          }
          return array;
        }
        var AESDecryptor = /* @__PURE__ */ function() {
          function AESDecryptor2() {
            this.rcon = [0, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54];
            this.subMix = [new Uint32Array(256), new Uint32Array(256), new Uint32Array(256), new Uint32Array(256)];
            this.invSubMix = [new Uint32Array(256), new Uint32Array(256), new Uint32Array(256), new Uint32Array(256)];
            this.sBox = new Uint32Array(256);
            this.invSBox = new Uint32Array(256);
            this.key = new Uint32Array(0);
            this.ksRows = 0;
            this.keySize = 0;
            this.keySchedule = void 0;
            this.invKeySchedule = void 0;
            this.initTable();
          }
          var _proto = AESDecryptor2.prototype;
          _proto.uint8ArrayToUint32Array_ = function uint8ArrayToUint32Array_(arrayBuffer) {
            var view2 = new DataView(arrayBuffer);
            var newArray = new Uint32Array(4);
            for (var i = 0; i < 4; i++) {
              newArray[i] = view2.getUint32(i * 4);
            }
            return newArray;
          };
          _proto.initTable = function initTable() {
            var sBox = this.sBox;
            var invSBox = this.invSBox;
            var subMix = this.subMix;
            var subMix0 = subMix[0];
            var subMix1 = subMix[1];
            var subMix2 = subMix[2];
            var subMix3 = subMix[3];
            var invSubMix = this.invSubMix;
            var invSubMix0 = invSubMix[0];
            var invSubMix1 = invSubMix[1];
            var invSubMix2 = invSubMix[2];
            var invSubMix3 = invSubMix[3];
            var d = new Uint32Array(256);
            var x = 0;
            var xi = 0;
            var i = 0;
            for (i = 0; i < 256; i++) {
              if (i < 128) {
                d[i] = i << 1;
              } else {
                d[i] = i << 1 ^ 283;
              }
            }
            for (i = 0; i < 256; i++) {
              var sx = xi ^ xi << 1 ^ xi << 2 ^ xi << 3 ^ xi << 4;
              sx = sx >>> 8 ^ sx & 255 ^ 99;
              sBox[x] = sx;
              invSBox[sx] = x;
              var x2 = d[x];
              var x4 = d[x2];
              var x8 = d[x4];
              var t = d[sx] * 257 ^ sx * 16843008;
              subMix0[x] = t << 24 | t >>> 8;
              subMix1[x] = t << 16 | t >>> 16;
              subMix2[x] = t << 8 | t >>> 24;
              subMix3[x] = t;
              t = x8 * 16843009 ^ x4 * 65537 ^ x2 * 257 ^ x * 16843008;
              invSubMix0[sx] = t << 24 | t >>> 8;
              invSubMix1[sx] = t << 16 | t >>> 16;
              invSubMix2[sx] = t << 8 | t >>> 24;
              invSubMix3[sx] = t;
              if (!x) {
                x = xi = 1;
              } else {
                x = x2 ^ d[d[d[x8 ^ x2]]];
                xi ^= d[d[xi]];
              }
            }
          };
          _proto.expandKey = function expandKey(keyBuffer) {
            var key = this.uint8ArrayToUint32Array_(keyBuffer);
            var sameKey = true;
            var offset = 0;
            while (offset < key.length && sameKey) {
              sameKey = key[offset] === this.key[offset];
              offset++;
            }
            if (sameKey) {
              return;
            }
            this.key = key;
            var keySize = this.keySize = key.length;
            if (keySize !== 4 && keySize !== 6 && keySize !== 8) {
              throw new Error("Invalid aes key size=" + keySize);
            }
            var ksRows = this.ksRows = (keySize + 6 + 1) * 4;
            var ksRow;
            var invKsRow;
            var keySchedule = this.keySchedule = new Uint32Array(ksRows);
            var invKeySchedule = this.invKeySchedule = new Uint32Array(ksRows);
            var sbox = this.sBox;
            var rcon = this.rcon;
            var invSubMix = this.invSubMix;
            var invSubMix0 = invSubMix[0];
            var invSubMix1 = invSubMix[1];
            var invSubMix2 = invSubMix[2];
            var invSubMix3 = invSubMix[3];
            var prev;
            var t;
            for (ksRow = 0; ksRow < ksRows; ksRow++) {
              if (ksRow < keySize) {
                prev = keySchedule[ksRow] = key[ksRow];
                continue;
              }
              t = prev;
              if (ksRow % keySize === 0) {
                t = t << 8 | t >>> 24;
                t = sbox[t >>> 24] << 24 | sbox[t >>> 16 & 255] << 16 | sbox[t >>> 8 & 255] << 8 | sbox[t & 255];
                t ^= rcon[ksRow / keySize | 0] << 24;
              } else if (keySize > 6 && ksRow % keySize === 4) {
                t = sbox[t >>> 24] << 24 | sbox[t >>> 16 & 255] << 16 | sbox[t >>> 8 & 255] << 8 | sbox[t & 255];
              }
              keySchedule[ksRow] = prev = (keySchedule[ksRow - keySize] ^ t) >>> 0;
            }
            for (invKsRow = 0; invKsRow < ksRows; invKsRow++) {
              ksRow = ksRows - invKsRow;
              if (invKsRow & 3) {
                t = keySchedule[ksRow];
              } else {
                t = keySchedule[ksRow - 4];
              }
              if (invKsRow < 4 || ksRow <= 4) {
                invKeySchedule[invKsRow] = t;
              } else {
                invKeySchedule[invKsRow] = invSubMix0[sbox[t >>> 24]] ^ invSubMix1[sbox[t >>> 16 & 255]] ^ invSubMix2[sbox[t >>> 8 & 255]] ^ invSubMix3[sbox[t & 255]];
              }
              invKeySchedule[invKsRow] = invKeySchedule[invKsRow] >>> 0;
            }
          };
          _proto.networkToHostOrderSwap = function networkToHostOrderSwap(word) {
            return word << 24 | (word & 65280) << 8 | (word & 16711680) >> 8 | word >>> 24;
          };
          _proto.decrypt = function decrypt(inputArrayBuffer, offset, aesIV) {
            var nRounds = this.keySize + 6;
            var invKeySchedule = this.invKeySchedule;
            var invSBOX = this.invSBox;
            var invSubMix = this.invSubMix;
            var invSubMix0 = invSubMix[0];
            var invSubMix1 = invSubMix[1];
            var invSubMix2 = invSubMix[2];
            var invSubMix3 = invSubMix[3];
            var initVector = this.uint8ArrayToUint32Array_(aesIV);
            var initVector0 = initVector[0];
            var initVector1 = initVector[1];
            var initVector2 = initVector[2];
            var initVector3 = initVector[3];
            var inputInt32 = new Int32Array(inputArrayBuffer);
            var outputInt32 = new Int32Array(inputInt32.length);
            var t0, t1, t2, t3;
            var s0, s1, s2, s3;
            var inputWords0, inputWords1, inputWords2, inputWords3;
            var ksRow, i;
            var swapWord = this.networkToHostOrderSwap;
            while (offset < inputInt32.length) {
              inputWords0 = swapWord(inputInt32[offset]);
              inputWords1 = swapWord(inputInt32[offset + 1]);
              inputWords2 = swapWord(inputInt32[offset + 2]);
              inputWords3 = swapWord(inputInt32[offset + 3]);
              s0 = inputWords0 ^ invKeySchedule[0];
              s1 = inputWords3 ^ invKeySchedule[1];
              s2 = inputWords2 ^ invKeySchedule[2];
              s3 = inputWords1 ^ invKeySchedule[3];
              ksRow = 4;
              for (i = 1; i < nRounds; i++) {
                t0 = invSubMix0[s0 >>> 24] ^ invSubMix1[s1 >> 16 & 255] ^ invSubMix2[s2 >> 8 & 255] ^ invSubMix3[s3 & 255] ^ invKeySchedule[ksRow];
                t1 = invSubMix0[s1 >>> 24] ^ invSubMix1[s2 >> 16 & 255] ^ invSubMix2[s3 >> 8 & 255] ^ invSubMix3[s0 & 255] ^ invKeySchedule[ksRow + 1];
                t2 = invSubMix0[s2 >>> 24] ^ invSubMix1[s3 >> 16 & 255] ^ invSubMix2[s0 >> 8 & 255] ^ invSubMix3[s1 & 255] ^ invKeySchedule[ksRow + 2];
                t3 = invSubMix0[s3 >>> 24] ^ invSubMix1[s0 >> 16 & 255] ^ invSubMix2[s1 >> 8 & 255] ^ invSubMix3[s2 & 255] ^ invKeySchedule[ksRow + 3];
                s0 = t0;
                s1 = t1;
                s2 = t2;
                s3 = t3;
                ksRow = ksRow + 4;
              }
              t0 = invSBOX[s0 >>> 24] << 24 ^ invSBOX[s1 >> 16 & 255] << 16 ^ invSBOX[s2 >> 8 & 255] << 8 ^ invSBOX[s3 & 255] ^ invKeySchedule[ksRow];
              t1 = invSBOX[s1 >>> 24] << 24 ^ invSBOX[s2 >> 16 & 255] << 16 ^ invSBOX[s3 >> 8 & 255] << 8 ^ invSBOX[s0 & 255] ^ invKeySchedule[ksRow + 1];
              t2 = invSBOX[s2 >>> 24] << 24 ^ invSBOX[s3 >> 16 & 255] << 16 ^ invSBOX[s0 >> 8 & 255] << 8 ^ invSBOX[s1 & 255] ^ invKeySchedule[ksRow + 2];
              t3 = invSBOX[s3 >>> 24] << 24 ^ invSBOX[s0 >> 16 & 255] << 16 ^ invSBOX[s1 >> 8 & 255] << 8 ^ invSBOX[s2 & 255] ^ invKeySchedule[ksRow + 3];
              outputInt32[offset] = swapWord(t0 ^ initVector0);
              outputInt32[offset + 1] = swapWord(t3 ^ initVector1);
              outputInt32[offset + 2] = swapWord(t2 ^ initVector2);
              outputInt32[offset + 3] = swapWord(t1 ^ initVector3);
              initVector0 = inputWords0;
              initVector1 = inputWords1;
              initVector2 = inputWords2;
              initVector3 = inputWords3;
              offset = offset + 4;
            }
            return outputInt32.buffer;
          };
          return AESDecryptor2;
        }();
        var FastAESKey = /* @__PURE__ */ function() {
          function FastAESKey2(subtle, key, aesMode) {
            this.subtle = void 0;
            this.key = void 0;
            this.aesMode = void 0;
            this.subtle = subtle;
            this.key = key;
            this.aesMode = aesMode;
          }
          var _proto = FastAESKey2.prototype;
          _proto.expandKey = function expandKey() {
            var subtleAlgoName = getSubtleAlgoName(this.aesMode);
            return this.subtle.importKey("raw", this.key, {
              name: subtleAlgoName
            }, false, ["encrypt", "decrypt"]);
          };
          return FastAESKey2;
        }();
        function getSubtleAlgoName(aesMode) {
          switch (aesMode) {
            case DecrypterAesMode.cbc:
              return "AES-CBC";
            case DecrypterAesMode.ctr:
              return "AES-CTR";
            default:
              throw new Error("[FastAESKey] invalid aes mode " + aesMode);
          }
        }
        var CHUNK_SIZE = 16;
        var Decrypter = /* @__PURE__ */ function() {
          function Decrypter2(config, _temp) {
            var _ref = _temp === void 0 ? {} : _temp, _ref$removePKCS7Paddi = _ref.removePKCS7Padding, removePKCS7Padding = _ref$removePKCS7Paddi === void 0 ? true : _ref$removePKCS7Paddi;
            this.logEnabled = true;
            this.removePKCS7Padding = void 0;
            this.subtle = null;
            this.softwareDecrypter = null;
            this.key = null;
            this.fastAesKey = null;
            this.remainderData = null;
            this.currentIV = null;
            this.currentResult = null;
            this.useSoftware = void 0;
            this.enableSoftwareAES = void 0;
            this.enableSoftwareAES = config.enableSoftwareAES;
            this.removePKCS7Padding = removePKCS7Padding;
            if (removePKCS7Padding) {
              try {
                var browserCrypto = self.crypto;
                if (browserCrypto) {
                  this.subtle = browserCrypto.subtle || browserCrypto.webkitSubtle;
                }
              } catch (e) {
              }
            }
            this.useSoftware = !this.subtle;
          }
          var _proto = Decrypter2.prototype;
          _proto.destroy = function destroy() {
            this.subtle = null;
            this.softwareDecrypter = null;
            this.key = null;
            this.fastAesKey = null;
            this.remainderData = null;
            this.currentIV = null;
            this.currentResult = null;
          };
          _proto.isSync = function isSync() {
            return this.useSoftware;
          };
          _proto.flush = function flush() {
            var currentResult = this.currentResult, remainderData = this.remainderData;
            if (!currentResult || remainderData) {
              this.reset();
              return null;
            }
            var data = new Uint8Array(currentResult);
            this.reset();
            if (this.removePKCS7Padding) {
              return removePadding(data);
            }
            return data;
          };
          _proto.reset = function reset() {
            this.currentResult = null;
            this.currentIV = null;
            this.remainderData = null;
            if (this.softwareDecrypter) {
              this.softwareDecrypter = null;
            }
          };
          _proto.decrypt = function decrypt(data, key, iv, aesMode) {
            var _this = this;
            if (this.useSoftware) {
              return new Promise(function(resolve, reject) {
                var dataView = ArrayBuffer.isView(data) ? data : new Uint8Array(data);
                _this.softwareDecrypt(dataView, key, iv, aesMode);
                var decryptResult = _this.flush();
                if (decryptResult) {
                  resolve(decryptResult.buffer);
                } else {
                  reject(new Error("[softwareDecrypt] Failed to decrypt data"));
                }
              });
            }
            return this.webCryptoDecrypt(new Uint8Array(data), key, iv, aesMode);
          };
          _proto.softwareDecrypt = function softwareDecrypt(data, key, iv, aesMode) {
            var currentIV = this.currentIV, currentResult = this.currentResult, remainderData = this.remainderData;
            if (aesMode !== DecrypterAesMode.cbc || key.byteLength !== 16) {
              logger4.warn("SoftwareDecrypt: can only handle AES-128-CBC");
              return null;
            }
            this.logOnce("JS AES decrypt");
            if (remainderData) {
              data = appendUint8Array(remainderData, data);
              this.remainderData = null;
            }
            var currentChunk = this.getValidChunk(data);
            if (!currentChunk.length) {
              return null;
            }
            if (currentIV) {
              iv = currentIV;
            }
            var softwareDecrypter = this.softwareDecrypter;
            if (!softwareDecrypter) {
              softwareDecrypter = this.softwareDecrypter = new AESDecryptor();
            }
            softwareDecrypter.expandKey(key);
            var result = currentResult;
            this.currentResult = softwareDecrypter.decrypt(currentChunk.buffer, 0, iv);
            this.currentIV = currentChunk.slice(-16).buffer;
            if (!result) {
              return null;
            }
            return result;
          };
          _proto.webCryptoDecrypt = function webCryptoDecrypt(data, key, iv, aesMode) {
            var _this2 = this;
            if (this.key !== key || !this.fastAesKey) {
              if (!this.subtle) {
                return Promise.resolve(this.onWebCryptoError(data, key, iv, aesMode));
              }
              this.key = key;
              this.fastAesKey = new FastAESKey(this.subtle, key, aesMode);
            }
            return this.fastAesKey.expandKey().then(function(aesKey) {
              if (!_this2.subtle) {
                return Promise.reject(new Error("web crypto not initialized"));
              }
              _this2.logOnce("WebCrypto AES decrypt");
              var crypto2 = new AESCrypto(_this2.subtle, new Uint8Array(iv), aesMode);
              return crypto2.decrypt(data.buffer, aesKey);
            }).catch(function(err) {
              logger4.warn("[decrypter]: WebCrypto Error, disable WebCrypto API, " + err.name + ": " + err.message);
              return _this2.onWebCryptoError(data, key, iv, aesMode);
            });
          };
          _proto.onWebCryptoError = function onWebCryptoError(data, key, iv, aesMode) {
            var enableSoftwareAES = this.enableSoftwareAES;
            if (enableSoftwareAES) {
              this.useSoftware = true;
              this.logEnabled = true;
              this.softwareDecrypt(data, key, iv, aesMode);
              var decryptResult = this.flush();
              if (decryptResult) {
                return decryptResult.buffer;
              }
            }
            throw new Error("WebCrypto" + (enableSoftwareAES ? " and softwareDecrypt" : "") + ": failed to decrypt data");
          };
          _proto.getValidChunk = function getValidChunk(data) {
            var currentChunk = data;
            var splitPoint = data.length - data.length % CHUNK_SIZE;
            if (splitPoint !== data.length) {
              currentChunk = data.slice(0, splitPoint);
              this.remainderData = data.slice(splitPoint);
            }
            return currentChunk;
          };
          _proto.logOnce = function logOnce(msg) {
            if (!this.logEnabled) {
              return;
            }
            logger4.log("[decrypter]: " + msg);
            this.logEnabled = false;
          };
          return Decrypter2;
        }();
        var emsgSchemePattern = /\/emsg[-/]ID3/i;
        var MP4Demuxer = /* @__PURE__ */ function() {
          function MP4Demuxer2(observer, config) {
            this.remainderData = null;
            this.timeOffset = 0;
            this.config = void 0;
            this.videoTrack = void 0;
            this.audioTrack = void 0;
            this.id3Track = void 0;
            this.txtTrack = void 0;
            this.config = config;
          }
          var _proto = MP4Demuxer2.prototype;
          _proto.resetTimeStamp = function resetTimeStamp() {
          };
          _proto.resetInitSegment = function resetInitSegment(initSegment, audioCodec, videoCodec, trackDuration) {
            var videoTrack = this.videoTrack = dummyTrack("video", 1);
            var audioTrack = this.audioTrack = dummyTrack("audio", 1);
            var captionTrack = this.txtTrack = dummyTrack("text", 1);
            this.id3Track = dummyTrack("id3", 1);
            this.timeOffset = 0;
            if (!(initSegment != null && initSegment.byteLength)) {
              return;
            }
            var initData = parseInitSegment(initSegment);
            if (initData.video) {
              var _initData$video = initData.video, id = _initData$video.id, timescale = _initData$video.timescale, codec = _initData$video.codec, supplemental = _initData$video.supplemental;
              videoTrack.id = id;
              videoTrack.timescale = captionTrack.timescale = timescale;
              videoTrack.codec = codec;
              videoTrack.supplemental = supplemental;
            }
            if (initData.audio) {
              var _initData$audio = initData.audio, _id = _initData$audio.id, _timescale = _initData$audio.timescale, _codec = _initData$audio.codec;
              audioTrack.id = _id;
              audioTrack.timescale = _timescale;
              audioTrack.codec = _codec;
            }
            captionTrack.id = RemuxerTrackIdConfig.text;
            videoTrack.sampleDuration = 0;
            videoTrack.duration = audioTrack.duration = trackDuration;
          };
          _proto.resetContiguity = function resetContiguity() {
            this.remainderData = null;
          };
          MP4Demuxer2.probe = function probe2(data) {
            return hasMoofData(data);
          };
          _proto.demux = function demux(data, timeOffset) {
            this.timeOffset = timeOffset;
            var videoSamples = data;
            var videoTrack = this.videoTrack;
            var textTrack = this.txtTrack;
            if (this.config.progressive) {
              if (this.remainderData) {
                videoSamples = appendUint8Array(this.remainderData, data);
              }
              var segmentedData = segmentValidRange(videoSamples);
              this.remainderData = segmentedData.remainder;
              videoTrack.samples = segmentedData.valid || new Uint8Array();
            } else {
              videoTrack.samples = videoSamples;
            }
            var id3Track = this.extractID3Track(videoTrack, timeOffset);
            textTrack.samples = parseSamples(timeOffset, videoTrack);
            return {
              videoTrack,
              audioTrack: this.audioTrack,
              id3Track,
              textTrack: this.txtTrack
            };
          };
          _proto.flush = function flush() {
            var timeOffset = this.timeOffset;
            var videoTrack = this.videoTrack;
            var textTrack = this.txtTrack;
            videoTrack.samples = this.remainderData || new Uint8Array();
            this.remainderData = null;
            var id3Track = this.extractID3Track(videoTrack, this.timeOffset);
            textTrack.samples = parseSamples(timeOffset, videoTrack);
            return {
              videoTrack,
              audioTrack: dummyTrack(),
              id3Track,
              textTrack: dummyTrack()
            };
          };
          _proto.extractID3Track = function extractID3Track(videoTrack, timeOffset) {
            var _this = this;
            var id3Track = this.id3Track;
            if (videoTrack.samples.length) {
              var emsgs = findBox(videoTrack.samples, ["emsg"]);
              if (emsgs) {
                emsgs.forEach(function(data) {
                  var emsgInfo = parseEmsg(data);
                  if (emsgSchemePattern.test(emsgInfo.schemeIdUri)) {
                    var pts = getEmsgStartTime(emsgInfo, timeOffset);
                    var duration = emsgInfo.eventDuration === 4294967295 ? Number.POSITIVE_INFINITY : emsgInfo.eventDuration / emsgInfo.timeScale;
                    if (duration <= 1e-3) {
                      duration = Number.POSITIVE_INFINITY;
                    }
                    var payload = emsgInfo.payload;
                    id3Track.samples.push({
                      data: payload,
                      len: payload.byteLength,
                      dts: pts,
                      pts,
                      type: MetadataSchema.emsg,
                      duration
                    });
                  } else if (_this.config.enableEmsgKLVMetadata && emsgInfo.schemeIdUri.startsWith("urn:misb:KLV:bin:1910.1")) {
                    var _pts = getEmsgStartTime(emsgInfo, timeOffset);
                    id3Track.samples.push({
                      data: emsgInfo.payload,
                      len: emsgInfo.payload.byteLength,
                      dts: _pts,
                      pts: _pts,
                      type: MetadataSchema.misbklv,
                      duration: Number.POSITIVE_INFINITY
                    });
                  }
                });
              }
            }
            return id3Track;
          };
          _proto.demuxSampleAes = function demuxSampleAes(data, keyData, timeOffset) {
            return Promise.reject(new Error("The MP4 demuxer does not support SAMPLE-AES decryption"));
          };
          _proto.destroy = function destroy() {
            this.config = null;
            this.remainderData = null;
            this.videoTrack = this.audioTrack = this.id3Track = this.txtTrack = void 0;
          };
          return MP4Demuxer2;
        }();
        function getEmsgStartTime(emsgInfo, timeOffset) {
          return isFiniteNumber(emsgInfo.presentationTime) ? emsgInfo.presentationTime / emsgInfo.timeScale : timeOffset + emsgInfo.presentationTimeDelta / emsgInfo.timeScale;
        }
        var SampleAesDecrypter = /* @__PURE__ */ function() {
          function SampleAesDecrypter2(observer, config, keyData) {
            this.keyData = void 0;
            this.decrypter = void 0;
            this.keyData = keyData;
            this.decrypter = new Decrypter(config, {
              removePKCS7Padding: false
            });
          }
          var _proto = SampleAesDecrypter2.prototype;
          _proto.decryptBuffer = function decryptBuffer(encryptedData) {
            return this.decrypter.decrypt(encryptedData, this.keyData.key.buffer, this.keyData.iv.buffer, DecrypterAesMode.cbc);
          };
          _proto.decryptAacSample = function decryptAacSample(samples, sampleIndex, callback) {
            var _this = this;
            var curUnit = samples[sampleIndex].unit;
            if (curUnit.length <= 16) {
              return;
            }
            var encryptedData = curUnit.subarray(16, curUnit.length - curUnit.length % 16);
            var encryptedBuffer = encryptedData.buffer.slice(encryptedData.byteOffset, encryptedData.byteOffset + encryptedData.length);
            this.decryptBuffer(encryptedBuffer).then(function(decryptedBuffer) {
              var decryptedData = new Uint8Array(decryptedBuffer);
              curUnit.set(decryptedData, 16);
              if (!_this.decrypter.isSync()) {
                _this.decryptAacSamples(samples, sampleIndex + 1, callback);
              }
            });
          };
          _proto.decryptAacSamples = function decryptAacSamples(samples, sampleIndex, callback) {
            for (; ; sampleIndex++) {
              if (sampleIndex >= samples.length) {
                callback();
                return;
              }
              if (samples[sampleIndex].unit.length < 32) {
                continue;
              }
              this.decryptAacSample(samples, sampleIndex, callback);
              if (!this.decrypter.isSync()) {
                return;
              }
            }
          };
          _proto.getAvcEncryptedData = function getAvcEncryptedData(decodedData) {
            var encryptedDataLen = Math.floor((decodedData.length - 48) / 160) * 16 + 16;
            var encryptedData = new Int8Array(encryptedDataLen);
            var outputPos = 0;
            for (var inputPos = 32; inputPos < decodedData.length - 16; inputPos += 160, outputPos += 16) {
              encryptedData.set(decodedData.subarray(inputPos, inputPos + 16), outputPos);
            }
            return encryptedData;
          };
          _proto.getAvcDecryptedUnit = function getAvcDecryptedUnit(decodedData, decryptedData) {
            var uint8DecryptedData = new Uint8Array(decryptedData);
            var inputPos = 0;
            for (var outputPos = 32; outputPos < decodedData.length - 16; outputPos += 160, inputPos += 16) {
              decodedData.set(uint8DecryptedData.subarray(inputPos, inputPos + 16), outputPos);
            }
            return decodedData;
          };
          _proto.decryptAvcSample = function decryptAvcSample(samples, sampleIndex, unitIndex, callback, curUnit) {
            var _this2 = this;
            var decodedData = discardEPB(curUnit.data);
            var encryptedData = this.getAvcEncryptedData(decodedData);
            this.decryptBuffer(encryptedData.buffer).then(function(decryptedBuffer) {
              curUnit.data = _this2.getAvcDecryptedUnit(decodedData, decryptedBuffer);
              if (!_this2.decrypter.isSync()) {
                _this2.decryptAvcSamples(samples, sampleIndex, unitIndex + 1, callback);
              }
            });
          };
          _proto.decryptAvcSamples = function decryptAvcSamples(samples, sampleIndex, unitIndex, callback) {
            if (samples instanceof Uint8Array) {
              throw new Error("Cannot decrypt samples of type Uint8Array");
            }
            for (; ; sampleIndex++, unitIndex = 0) {
              if (sampleIndex >= samples.length) {
                callback();
                return;
              }
              var curUnits = samples[sampleIndex].units;
              for (; ; unitIndex++) {
                if (unitIndex >= curUnits.length) {
                  break;
                }
                var curUnit = curUnits[unitIndex];
                if (curUnit.data.length <= 48 || curUnit.type !== 1 && curUnit.type !== 5) {
                  continue;
                }
                this.decryptAvcSample(samples, sampleIndex, unitIndex, callback, curUnit);
                if (!this.decrypter.isSync()) {
                  return;
                }
              }
            }
          };
          return SampleAesDecrypter2;
        }();
        var BaseVideoParser = /* @__PURE__ */ function() {
          function BaseVideoParser2() {
            this.VideoSample = null;
          }
          var _proto = BaseVideoParser2.prototype;
          _proto.createVideoSample = function createVideoSample(key, pts, dts) {
            return {
              key,
              frame: false,
              pts,
              dts,
              units: [],
              length: 0
            };
          };
          _proto.getLastNalUnit = function getLastNalUnit(samples) {
            var _VideoSample;
            var VideoSample2 = this.VideoSample;
            var lastUnit;
            if (!VideoSample2 || VideoSample2.units.length === 0) {
              VideoSample2 = samples[samples.length - 1];
            }
            if ((_VideoSample = VideoSample2) != null && _VideoSample.units) {
              var units = VideoSample2.units;
              lastUnit = units[units.length - 1];
            }
            return lastUnit;
          };
          _proto.pushAccessUnit = function pushAccessUnit(VideoSample2, videoTrack) {
            if (VideoSample2.units.length && VideoSample2.frame) {
              if (VideoSample2.pts === void 0) {
                var samples = videoTrack.samples;
                var nbSamples = samples.length;
                if (nbSamples) {
                  var lastSample = samples[nbSamples - 1];
                  VideoSample2.pts = lastSample.pts;
                  VideoSample2.dts = lastSample.dts;
                } else {
                  videoTrack.dropped++;
                  return;
                }
              }
              videoTrack.samples.push(VideoSample2);
            }
          };
          _proto.parseNALu = function parseNALu(track, array, endOfSegment) {
            var len = array.byteLength;
            var state = track.naluState || 0;
            var lastState = state;
            var units = [];
            var i = 0;
            var value;
            var overflow;
            var unitType;
            var lastUnitStart = -1;
            var lastUnitType = 0;
            if (state === -1) {
              lastUnitStart = 0;
              lastUnitType = this.getNALuType(array, 0);
              state = 0;
              i = 1;
            }
            while (i < len) {
              value = array[i++];
              if (!state) {
                state = value ? 0 : 1;
                continue;
              }
              if (state === 1) {
                state = value ? 0 : 2;
                continue;
              }
              if (!value) {
                state = 3;
              } else if (value === 1) {
                overflow = i - state - 1;
                if (lastUnitStart >= 0) {
                  var unit = {
                    data: array.subarray(lastUnitStart, overflow),
                    type: lastUnitType
                  };
                  units.push(unit);
                } else {
                  var lastUnit = this.getLastNalUnit(track.samples);
                  if (lastUnit) {
                    if (lastState && i <= 4 - lastState) {
                      if (lastUnit.state) {
                        lastUnit.data = lastUnit.data.subarray(0, lastUnit.data.byteLength - lastState);
                      }
                    }
                    if (overflow > 0) {
                      lastUnit.data = appendUint8Array(lastUnit.data, array.subarray(0, overflow));
                      lastUnit.state = 0;
                    }
                  }
                }
                if (i < len) {
                  unitType = this.getNALuType(array, i);
                  lastUnitStart = i;
                  lastUnitType = unitType;
                  state = 0;
                } else {
                  state = -1;
                }
              } else {
                state = 0;
              }
            }
            if (lastUnitStart >= 0 && state >= 0) {
              var _unit = {
                data: array.subarray(lastUnitStart, len),
                type: lastUnitType,
                state
              };
              units.push(_unit);
            }
            if (units.length === 0) {
              var _lastUnit = this.getLastNalUnit(track.samples);
              if (_lastUnit) {
                _lastUnit.data = appendUint8Array(_lastUnit.data, array);
              }
            }
            track.naluState = state;
            return units;
          };
          return BaseVideoParser2;
        }();
        var ExpGolomb2 = /* @__PURE__ */ function() {
          function ExpGolomb3(data) {
            this.data = void 0;
            this.bytesAvailable = void 0;
            this.word = void 0;
            this.bitsAvailable = void 0;
            this.data = data;
            this.bytesAvailable = data.byteLength;
            this.word = 0;
            this.bitsAvailable = 0;
          }
          var _proto = ExpGolomb3.prototype;
          _proto.loadWord = function loadWord() {
            var data = this.data;
            var bytesAvailable = this.bytesAvailable;
            var position = data.byteLength - bytesAvailable;
            var workingBytes = new Uint8Array(4);
            var availableBytes = Math.min(4, bytesAvailable);
            if (availableBytes === 0) {
              throw new Error("no bytes available");
            }
            workingBytes.set(data.subarray(position, position + availableBytes));
            this.word = new DataView(workingBytes.buffer).getUint32(0);
            this.bitsAvailable = availableBytes * 8;
            this.bytesAvailable -= availableBytes;
          };
          _proto.skipBits = function skipBits(count) {
            var skipBytes;
            count = Math.min(count, this.bytesAvailable * 8 + this.bitsAvailable);
            if (this.bitsAvailable > count) {
              this.word <<= count;
              this.bitsAvailable -= count;
            } else {
              count -= this.bitsAvailable;
              skipBytes = count >> 3;
              count -= skipBytes << 3;
              this.bytesAvailable -= skipBytes;
              this.loadWord();
              this.word <<= count;
              this.bitsAvailable -= count;
            }
          };
          _proto.readBits = function readBits(size) {
            var bits = Math.min(this.bitsAvailable, size);
            var valu = this.word >>> 32 - bits;
            if (size > 32) {
              logger4.error("Cannot read more than 32 bits at a time");
            }
            this.bitsAvailable -= bits;
            if (this.bitsAvailable > 0) {
              this.word <<= bits;
            } else if (this.bytesAvailable > 0) {
              this.loadWord();
            } else {
              throw new Error("no bits available");
            }
            bits = size - bits;
            if (bits > 0 && this.bitsAvailable) {
              return valu << bits | this.readBits(bits);
            } else {
              return valu;
            }
          };
          _proto.skipLZ = function skipLZ() {
            var leadingZeroCount;
            for (leadingZeroCount = 0; leadingZeroCount < this.bitsAvailable; ++leadingZeroCount) {
              if ((this.word & 2147483648 >>> leadingZeroCount) !== 0) {
                this.word <<= leadingZeroCount;
                this.bitsAvailable -= leadingZeroCount;
                return leadingZeroCount;
              }
            }
            this.loadWord();
            return leadingZeroCount + this.skipLZ();
          };
          _proto.skipUEG = function skipUEG() {
            this.skipBits(1 + this.skipLZ());
          };
          _proto.skipEG = function skipEG() {
            this.skipBits(1 + this.skipLZ());
          };
          _proto.readUEG = function readUEG() {
            var clz = this.skipLZ();
            return this.readBits(clz + 1) - 1;
          };
          _proto.readEG = function readEG() {
            var valu = this.readUEG();
            if (1 & valu) {
              return 1 + valu >>> 1;
            } else {
              return -1 * (valu >>> 1);
            }
          };
          _proto.readBoolean = function readBoolean() {
            return this.readBits(1) === 1;
          };
          _proto.readUByte = function readUByte() {
            return this.readBits(8);
          };
          _proto.readUShort = function readUShort() {
            return this.readBits(16);
          };
          _proto.readUInt = function readUInt() {
            return this.readBits(32);
          };
          return ExpGolomb3;
        }();
        var AvcVideoParser = /* @__PURE__ */ function(_BaseVideoParser) {
          function AvcVideoParser2() {
            return _BaseVideoParser.apply(this, arguments) || this;
          }
          _inheritsLoose(AvcVideoParser2, _BaseVideoParser);
          var _proto = AvcVideoParser2.prototype;
          _proto.parsePES = function parsePES2(track, textTrack, pes, endOfSegment) {
            var _this = this;
            var units = this.parseNALu(track, pes.data, endOfSegment);
            var VideoSample2 = this.VideoSample;
            var push2;
            var spsfound = false;
            pes.data = null;
            if (VideoSample2 && units.length && !track.audFound) {
              this.pushAccessUnit(VideoSample2, track);
              VideoSample2 = this.VideoSample = this.createVideoSample(false, pes.pts, pes.dts);
            }
            units.forEach(function(unit) {
              var _VideoSample2, _VideoSample3;
              switch (unit.type) {
                // NDR
                case 1: {
                  var iskey = false;
                  push2 = true;
                  var data = unit.data;
                  if (spsfound && data.length > 4) {
                    var sliceType = _this.readSliceType(data);
                    if (sliceType === 2 || sliceType === 4 || sliceType === 7 || sliceType === 9) {
                      iskey = true;
                    }
                  }
                  if (iskey) {
                    var _VideoSample;
                    if ((_VideoSample = VideoSample2) != null && _VideoSample.frame && !VideoSample2.key) {
                      _this.pushAccessUnit(VideoSample2, track);
                      VideoSample2 = _this.VideoSample = null;
                    }
                  }
                  if (!VideoSample2) {
                    VideoSample2 = _this.VideoSample = _this.createVideoSample(true, pes.pts, pes.dts);
                  }
                  VideoSample2.frame = true;
                  VideoSample2.key = iskey;
                  break;
                }
                case 5:
                  push2 = true;
                  if ((_VideoSample2 = VideoSample2) != null && _VideoSample2.frame && !VideoSample2.key) {
                    _this.pushAccessUnit(VideoSample2, track);
                    VideoSample2 = _this.VideoSample = null;
                  }
                  if (!VideoSample2) {
                    VideoSample2 = _this.VideoSample = _this.createVideoSample(true, pes.pts, pes.dts);
                  }
                  VideoSample2.key = true;
                  VideoSample2.frame = true;
                  break;
                // SEI
                case 6: {
                  push2 = true;
                  parseSEIMessageFromNALu(unit.data, 1, pes.pts, textTrack.samples);
                  break;
                }
                case 7: {
                  var _track$pixelRatio, _track$pixelRatio2;
                  push2 = true;
                  spsfound = true;
                  var sps = unit.data;
                  var config = _this.readSPS(sps);
                  if (!track.sps || track.width !== config.width || track.height !== config.height || ((_track$pixelRatio = track.pixelRatio) == null ? void 0 : _track$pixelRatio[0]) !== config.pixelRatio[0] || ((_track$pixelRatio2 = track.pixelRatio) == null ? void 0 : _track$pixelRatio2[1]) !== config.pixelRatio[1]) {
                    track.width = config.width;
                    track.height = config.height;
                    track.pixelRatio = config.pixelRatio;
                    track.sps = [sps];
                    var codecarray = sps.subarray(1, 4);
                    var codecstring = "avc1.";
                    for (var i = 0; i < 3; i++) {
                      var h = codecarray[i].toString(16);
                      if (h.length < 2) {
                        h = "0" + h;
                      }
                      codecstring += h;
                    }
                    track.codec = codecstring;
                  }
                  break;
                }
                // PPS
                case 8:
                  push2 = true;
                  track.pps = [unit.data];
                  break;
                // AUD
                case 9:
                  push2 = true;
                  track.audFound = true;
                  if ((_VideoSample3 = VideoSample2) != null && _VideoSample3.frame) {
                    _this.pushAccessUnit(VideoSample2, track);
                    VideoSample2 = null;
                  }
                  if (!VideoSample2) {
                    VideoSample2 = _this.VideoSample = _this.createVideoSample(false, pes.pts, pes.dts);
                  }
                  break;
                // Filler Data
                case 12:
                  push2 = true;
                  break;
                default:
                  push2 = false;
                  break;
              }
              if (VideoSample2 && push2) {
                var _units = VideoSample2.units;
                _units.push(unit);
              }
            });
            if (endOfSegment && VideoSample2) {
              this.pushAccessUnit(VideoSample2, track);
              this.VideoSample = null;
            }
          };
          _proto.getNALuType = function getNALuType(data, offset) {
            return data[offset] & 31;
          };
          _proto.readSliceType = function readSliceType(data) {
            var eg = new ExpGolomb2(data);
            eg.readUByte();
            eg.readUEG();
            return eg.readUEG();
          };
          _proto.skipScalingList = function skipScalingList(count, reader) {
            var lastScale = 8;
            var nextScale = 8;
            var deltaScale;
            for (var j = 0; j < count; j++) {
              if (nextScale !== 0) {
                deltaScale = reader.readEG();
                nextScale = (lastScale + deltaScale + 256) % 256;
              }
              lastScale = nextScale === 0 ? lastScale : nextScale;
            }
          };
          _proto.readSPS = function readSPS(sps) {
            var eg = new ExpGolomb2(sps);
            var frameCropLeftOffset = 0;
            var frameCropRightOffset = 0;
            var frameCropTopOffset = 0;
            var frameCropBottomOffset = 0;
            var numRefFramesInPicOrderCntCycle;
            var scalingListCount;
            var i;
            var readUByte = eg.readUByte.bind(eg);
            var readBits = eg.readBits.bind(eg);
            var readUEG = eg.readUEG.bind(eg);
            var readBoolean = eg.readBoolean.bind(eg);
            var skipBits = eg.skipBits.bind(eg);
            var skipEG = eg.skipEG.bind(eg);
            var skipUEG = eg.skipUEG.bind(eg);
            var skipScalingList = this.skipScalingList.bind(this);
            readUByte();
            var profileIdc = readUByte();
            readBits(5);
            skipBits(3);
            readUByte();
            skipUEG();
            if (profileIdc === 100 || profileIdc === 110 || profileIdc === 122 || profileIdc === 244 || profileIdc === 44 || profileIdc === 83 || profileIdc === 86 || profileIdc === 118 || profileIdc === 128) {
              var chromaFormatIdc = readUEG();
              if (chromaFormatIdc === 3) {
                skipBits(1);
              }
              skipUEG();
              skipUEG();
              skipBits(1);
              if (readBoolean()) {
                scalingListCount = chromaFormatIdc !== 3 ? 8 : 12;
                for (i = 0; i < scalingListCount; i++) {
                  if (readBoolean()) {
                    if (i < 6) {
                      skipScalingList(16, eg);
                    } else {
                      skipScalingList(64, eg);
                    }
                  }
                }
              }
            }
            skipUEG();
            var picOrderCntType = readUEG();
            if (picOrderCntType === 0) {
              readUEG();
            } else if (picOrderCntType === 1) {
              skipBits(1);
              skipEG();
              skipEG();
              numRefFramesInPicOrderCntCycle = readUEG();
              for (i = 0; i < numRefFramesInPicOrderCntCycle; i++) {
                skipEG();
              }
            }
            skipUEG();
            skipBits(1);
            var picWidthInMbsMinus1 = readUEG();
            var picHeightInMapUnitsMinus1 = readUEG();
            var frameMbsOnlyFlag = readBits(1);
            if (frameMbsOnlyFlag === 0) {
              skipBits(1);
            }
            skipBits(1);
            if (readBoolean()) {
              frameCropLeftOffset = readUEG();
              frameCropRightOffset = readUEG();
              frameCropTopOffset = readUEG();
              frameCropBottomOffset = readUEG();
            }
            var pixelRatio = [1, 1];
            if (readBoolean()) {
              if (readBoolean()) {
                var aspectRatioIdc = readUByte();
                switch (aspectRatioIdc) {
                  case 1:
                    pixelRatio = [1, 1];
                    break;
                  case 2:
                    pixelRatio = [12, 11];
                    break;
                  case 3:
                    pixelRatio = [10, 11];
                    break;
                  case 4:
                    pixelRatio = [16, 11];
                    break;
                  case 5:
                    pixelRatio = [40, 33];
                    break;
                  case 6:
                    pixelRatio = [24, 11];
                    break;
                  case 7:
                    pixelRatio = [20, 11];
                    break;
                  case 8:
                    pixelRatio = [32, 11];
                    break;
                  case 9:
                    pixelRatio = [80, 33];
                    break;
                  case 10:
                    pixelRatio = [18, 11];
                    break;
                  case 11:
                    pixelRatio = [15, 11];
                    break;
                  case 12:
                    pixelRatio = [64, 33];
                    break;
                  case 13:
                    pixelRatio = [160, 99];
                    break;
                  case 14:
                    pixelRatio = [4, 3];
                    break;
                  case 15:
                    pixelRatio = [3, 2];
                    break;
                  case 16:
                    pixelRatio = [2, 1];
                    break;
                  case 255: {
                    pixelRatio = [readUByte() << 8 | readUByte(), readUByte() << 8 | readUByte()];
                    break;
                  }
                }
              }
            }
            return {
              width: Math.ceil((picWidthInMbsMinus1 + 1) * 16 - frameCropLeftOffset * 2 - frameCropRightOffset * 2),
              height: (2 - frameMbsOnlyFlag) * (picHeightInMapUnitsMinus1 + 1) * 16 - (frameMbsOnlyFlag ? 2 : 4) * (frameCropTopOffset + frameCropBottomOffset),
              pixelRatio
            };
          };
          return AvcVideoParser2;
        }(BaseVideoParser);
        var PACKET_LENGTH = 188;
        var TSDemuxer = /* @__PURE__ */ function() {
          function TSDemuxer2(observer, config, typeSupported, logger5) {
            this.logger = void 0;
            this.observer = void 0;
            this.config = void 0;
            this.typeSupported = void 0;
            this.sampleAes = null;
            this.pmtParsed = false;
            this.audioCodec = void 0;
            this.videoCodec = void 0;
            this._pmtId = -1;
            this._videoTrack = void 0;
            this._audioTrack = void 0;
            this._id3Track = void 0;
            this._txtTrack = void 0;
            this.aacOverFlow = null;
            this.remainderData = null;
            this.videoParser = void 0;
            this.observer = observer;
            this.config = config;
            this.typeSupported = typeSupported;
            this.logger = logger5;
            this.videoParser = null;
          }
          TSDemuxer2.probe = function probe2(data, logger5) {
            var syncOffset = TSDemuxer2.syncOffset(data);
            if (syncOffset > 0) {
              logger5.warn("MPEG2-TS detected but first sync word found @ offset " + syncOffset);
            }
            return syncOffset !== -1;
          };
          TSDemuxer2.syncOffset = function syncOffset(data) {
            var length = data.length;
            var scanwindow = Math.min(PACKET_LENGTH * 5, length - PACKET_LENGTH) + 1;
            var i = 0;
            while (i < scanwindow) {
              var foundPat = false;
              var packetStart = -1;
              var tsPackets = 0;
              for (var j = i; j < length; j += PACKET_LENGTH) {
                if (data[j] === 71 && (length - j === PACKET_LENGTH || data[j + PACKET_LENGTH] === 71)) {
                  tsPackets++;
                  if (packetStart === -1) {
                    packetStart = j;
                    if (packetStart !== 0) {
                      scanwindow = Math.min(packetStart + PACKET_LENGTH * 99, data.length - PACKET_LENGTH) + 1;
                    }
                  }
                  if (!foundPat) {
                    foundPat = parsePID(data, j) === 0;
                  }
                  if (foundPat && tsPackets > 1 && (packetStart === 0 && tsPackets > 2 || j + PACKET_LENGTH > scanwindow)) {
                    return packetStart;
                  }
                } else if (tsPackets) {
                  return -1;
                } else {
                  break;
                }
              }
              i++;
            }
            return -1;
          };
          TSDemuxer2.createTrack = function createTrack(type, duration) {
            return {
              container: type === "video" || type === "audio" ? "video/mp2t" : void 0,
              type,
              id: RemuxerTrackIdConfig[type],
              pid: -1,
              inputTimeScale: 9e4,
              sequenceNumber: 0,
              samples: [],
              dropped: 0,
              duration: type === "audio" ? duration : void 0
            };
          };
          var _proto = TSDemuxer2.prototype;
          _proto.resetInitSegment = function resetInitSegment(initSegment, audioCodec, videoCodec, trackDuration) {
            this.pmtParsed = false;
            this._pmtId = -1;
            this._videoTrack = TSDemuxer2.createTrack("video");
            this._videoTrack.duration = trackDuration;
            this._audioTrack = TSDemuxer2.createTrack("audio", trackDuration);
            this._id3Track = TSDemuxer2.createTrack("id3");
            this._txtTrack = TSDemuxer2.createTrack("text");
            this._audioTrack.segmentCodec = "aac";
            this.aacOverFlow = null;
            this.remainderData = null;
            this.audioCodec = audioCodec;
            this.videoCodec = videoCodec;
          };
          _proto.resetTimeStamp = function resetTimeStamp() {
          };
          _proto.resetContiguity = function resetContiguity() {
            var _audioTrack = this._audioTrack, _videoTrack = this._videoTrack, _id3Track = this._id3Track;
            if (_audioTrack) {
              _audioTrack.pesData = null;
            }
            if (_videoTrack) {
              _videoTrack.pesData = null;
            }
            if (_id3Track) {
              _id3Track.pesData = null;
            }
            this.aacOverFlow = null;
            this.remainderData = null;
          };
          _proto.demux = function demux(data, timeOffset, isSampleAes, flush) {
            if (isSampleAes === void 0) {
              isSampleAes = false;
            }
            if (flush === void 0) {
              flush = false;
            }
            if (!isSampleAes) {
              this.sampleAes = null;
            }
            var pes;
            var videoTrack = this._videoTrack;
            var audioTrack = this._audioTrack;
            var id3Track = this._id3Track;
            var textTrack = this._txtTrack;
            var videoPid = videoTrack.pid;
            var videoData = videoTrack.pesData;
            var audioPid = audioTrack.pid;
            var id3Pid = id3Track.pid;
            var audioData = audioTrack.pesData;
            var id3Data = id3Track.pesData;
            var unknownPID = null;
            var pmtParsed = this.pmtParsed;
            var pmtId = this._pmtId;
            var len = data.length;
            if (this.remainderData) {
              data = appendUint8Array(this.remainderData, data);
              len = data.length;
              this.remainderData = null;
            }
            if (len < PACKET_LENGTH && !flush) {
              this.remainderData = data;
              return {
                audioTrack,
                videoTrack,
                id3Track,
                textTrack
              };
            }
            var syncOffset = Math.max(0, TSDemuxer2.syncOffset(data));
            len -= (len - syncOffset) % PACKET_LENGTH;
            if (len < data.byteLength && !flush) {
              this.remainderData = new Uint8Array(data.buffer, len, data.buffer.byteLength - len);
            }
            var tsPacketErrors = 0;
            for (var start = syncOffset; start < len; start += PACKET_LENGTH) {
              if (data[start] === 71) {
                var stt = !!(data[start + 1] & 64);
                var pid = parsePID(data, start);
                var atf = (data[start + 3] & 48) >> 4;
                var offset = void 0;
                if (atf > 1) {
                  offset = start + 5 + data[start + 4];
                  if (offset === start + PACKET_LENGTH) {
                    continue;
                  }
                } else {
                  offset = start + 4;
                }
                switch (pid) {
                  case videoPid:
                    if (stt) {
                      if (videoData && (pes = parsePES(videoData, this.logger))) {
                        if (this.videoParser === null) {
                          switch (videoTrack.segmentCodec) {
                            case "avc":
                              this.videoParser = new AvcVideoParser();
                              break;
                          }
                        }
                        if (this.videoParser !== null) {
                          this.videoParser.parsePES(videoTrack, textTrack, pes, false);
                        }
                      }
                      videoData = {
                        data: [],
                        size: 0
                      };
                    }
                    if (videoData) {
                      videoData.data.push(data.subarray(offset, start + PACKET_LENGTH));
                      videoData.size += start + PACKET_LENGTH - offset;
                    }
                    break;
                  case audioPid:
                    if (stt) {
                      if (audioData && (pes = parsePES(audioData, this.logger))) {
                        switch (audioTrack.segmentCodec) {
                          case "aac":
                            this.parseAACPES(audioTrack, pes);
                            break;
                          case "mp3":
                            this.parseMPEGPES(audioTrack, pes);
                            break;
                        }
                      }
                      audioData = {
                        data: [],
                        size: 0
                      };
                    }
                    if (audioData) {
                      audioData.data.push(data.subarray(offset, start + PACKET_LENGTH));
                      audioData.size += start + PACKET_LENGTH - offset;
                    }
                    break;
                  case id3Pid:
                    if (stt) {
                      if (id3Data && (pes = parsePES(id3Data, this.logger))) {
                        this.parseID3PES(id3Track, pes);
                      }
                      id3Data = {
                        data: [],
                        size: 0
                      };
                    }
                    if (id3Data) {
                      id3Data.data.push(data.subarray(offset, start + PACKET_LENGTH));
                      id3Data.size += start + PACKET_LENGTH - offset;
                    }
                    break;
                  case 0:
                    if (stt) {
                      offset += data[offset] + 1;
                    }
                    pmtId = this._pmtId = parsePAT(data, offset);
                    break;
                  case pmtId: {
                    if (stt) {
                      offset += data[offset] + 1;
                    }
                    var parsedPIDs = parsePMT(data, offset, this.typeSupported, isSampleAes, this.observer, this.logger);
                    videoPid = parsedPIDs.videoPid;
                    if (videoPid > 0) {
                      videoTrack.pid = videoPid;
                      videoTrack.segmentCodec = parsedPIDs.segmentVideoCodec;
                    }
                    audioPid = parsedPIDs.audioPid;
                    if (audioPid > 0) {
                      audioTrack.pid = audioPid;
                      audioTrack.segmentCodec = parsedPIDs.segmentAudioCodec;
                    }
                    id3Pid = parsedPIDs.id3Pid;
                    if (id3Pid > 0) {
                      id3Track.pid = id3Pid;
                    }
                    if (unknownPID !== null && !pmtParsed) {
                      this.logger.warn("MPEG-TS PMT found at " + start + " after unknown PID '" + unknownPID + "'. Backtracking to sync byte @" + syncOffset + " to parse all TS packets.");
                      unknownPID = null;
                      start = syncOffset - 188;
                    }
                    pmtParsed = this.pmtParsed = true;
                    break;
                  }
                  case 17:
                  case 8191:
                    break;
                  default:
                    unknownPID = pid;
                    break;
                }
              } else {
                tsPacketErrors++;
              }
            }
            if (tsPacketErrors > 0) {
              emitParsingError(this.observer, new Error("Found " + tsPacketErrors + " TS packet/s that do not start with 0x47"), void 0, this.logger);
            }
            videoTrack.pesData = videoData;
            audioTrack.pesData = audioData;
            id3Track.pesData = id3Data;
            var demuxResult = {
              audioTrack,
              videoTrack,
              id3Track,
              textTrack
            };
            if (flush) {
              this.extractRemainingSamples(demuxResult);
            }
            return demuxResult;
          };
          _proto.flush = function flush() {
            var remainderData = this.remainderData;
            this.remainderData = null;
            var result;
            if (remainderData) {
              result = this.demux(remainderData, -1, false, true);
            } else {
              result = {
                videoTrack: this._videoTrack,
                audioTrack: this._audioTrack,
                id3Track: this._id3Track,
                textTrack: this._txtTrack
              };
            }
            this.extractRemainingSamples(result);
            if (this.sampleAes) {
              return this.decrypt(result, this.sampleAes);
            }
            return result;
          };
          _proto.extractRemainingSamples = function extractRemainingSamples(demuxResult) {
            var audioTrack = demuxResult.audioTrack, videoTrack = demuxResult.videoTrack, id3Track = demuxResult.id3Track, textTrack = demuxResult.textTrack;
            var videoData = videoTrack.pesData;
            var audioData = audioTrack.pesData;
            var id3Data = id3Track.pesData;
            var pes;
            if (videoData && (pes = parsePES(videoData, this.logger))) {
              if (this.videoParser === null) {
                switch (videoTrack.segmentCodec) {
                  case "avc":
                    this.videoParser = new AvcVideoParser();
                    break;
                }
              }
              if (this.videoParser !== null) {
                this.videoParser.parsePES(videoTrack, textTrack, pes, true);
                videoTrack.pesData = null;
              }
            } else {
              videoTrack.pesData = videoData;
            }
            if (audioData && (pes = parsePES(audioData, this.logger))) {
              switch (audioTrack.segmentCodec) {
                case "aac":
                  this.parseAACPES(audioTrack, pes);
                  break;
                case "mp3":
                  this.parseMPEGPES(audioTrack, pes);
                  break;
              }
              audioTrack.pesData = null;
            } else {
              if (audioData != null && audioData.size) {
                this.logger.log("last AAC PES packet truncated,might overlap between fragments");
              }
              audioTrack.pesData = audioData;
            }
            if (id3Data && (pes = parsePES(id3Data, this.logger))) {
              this.parseID3PES(id3Track, pes);
              id3Track.pesData = null;
            } else {
              id3Track.pesData = id3Data;
            }
          };
          _proto.demuxSampleAes = function demuxSampleAes(data, keyData, timeOffset) {
            var demuxResult = this.demux(data, timeOffset, true, !this.config.progressive);
            var sampleAes = this.sampleAes = new SampleAesDecrypter(this.observer, this.config, keyData);
            return this.decrypt(demuxResult, sampleAes);
          };
          _proto.decrypt = function decrypt(demuxResult, sampleAes) {
            return new Promise(function(resolve) {
              var audioTrack = demuxResult.audioTrack, videoTrack = demuxResult.videoTrack;
              if (audioTrack.samples && audioTrack.segmentCodec === "aac") {
                sampleAes.decryptAacSamples(audioTrack.samples, 0, function() {
                  if (videoTrack.samples) {
                    sampleAes.decryptAvcSamples(videoTrack.samples, 0, 0, function() {
                      resolve(demuxResult);
                    });
                  } else {
                    resolve(demuxResult);
                  }
                });
              } else if (videoTrack.samples) {
                sampleAes.decryptAvcSamples(videoTrack.samples, 0, 0, function() {
                  resolve(demuxResult);
                });
              }
            });
          };
          _proto.destroy = function destroy() {
            if (this.observer) {
              this.observer.removeAllListeners();
            }
            this.config = this.logger = this.observer = null;
            this.aacOverFlow = this.videoParser = this.remainderData = this.sampleAes = null;
            this._videoTrack = this._audioTrack = this._id3Track = this._txtTrack = void 0;
          };
          _proto.parseAACPES = function parseAACPES(track, pes) {
            var startOffset = 0;
            var aacOverFlow = this.aacOverFlow;
            var data = pes.data;
            if (aacOverFlow) {
              this.aacOverFlow = null;
              var frameMissingBytes = aacOverFlow.missing;
              var sampleLength = aacOverFlow.sample.unit.byteLength;
              if (frameMissingBytes === -1) {
                data = appendUint8Array(aacOverFlow.sample.unit, data);
              } else {
                var frameOverflowBytes = sampleLength - frameMissingBytes;
                aacOverFlow.sample.unit.set(data.subarray(0, frameMissingBytes), frameOverflowBytes);
                track.samples.push(aacOverFlow.sample);
                startOffset = aacOverFlow.missing;
              }
            }
            var offset;
            var len;
            for (offset = startOffset, len = data.length; offset < len - 1; offset++) {
              if (isHeader$1(data, offset)) {
                break;
              }
            }
            if (offset !== startOffset) {
              var reason;
              var recoverable = offset < len - 1;
              if (recoverable) {
                reason = "AAC PES did not start with ADTS header,offset:" + offset;
              } else {
                reason = "No ADTS header found in AAC PES";
              }
              emitParsingError(this.observer, new Error(reason), recoverable, this.logger);
              if (!recoverable) {
                return;
              }
            }
            initTrackConfig(track, this.observer, data, offset, this.audioCodec);
            var pts;
            if (pes.pts !== void 0) {
              pts = pes.pts;
            } else if (aacOverFlow) {
              var frameDuration = getFrameDuration(track.samplerate);
              pts = aacOverFlow.sample.pts + frameDuration;
            } else {
              this.logger.warn("[tsdemuxer]: AAC PES unknown PTS");
              return;
            }
            var frameIndex = 0;
            var frame;
            while (offset < len) {
              frame = appendFrame$1(track, data, offset, pts, frameIndex);
              offset += frame.length;
              if (!frame.missing) {
                frameIndex++;
                for (; offset < len - 1; offset++) {
                  if (isHeader$1(data, offset)) {
                    break;
                  }
                }
              } else {
                this.aacOverFlow = frame;
                break;
              }
            }
          };
          _proto.parseMPEGPES = function parseMPEGPES(track, pes) {
            var data = pes.data;
            var length = data.length;
            var frameIndex = 0;
            var offset = 0;
            var pts = pes.pts;
            if (pts === void 0) {
              this.logger.warn("[tsdemuxer]: MPEG PES unknown PTS");
              return;
            }
            while (offset < length) {
              if (isHeader(data, offset)) {
                var frame = appendFrame(track, data, offset, pts, frameIndex);
                if (frame) {
                  offset += frame.length;
                  frameIndex++;
                } else {
                  break;
                }
              } else {
                offset++;
              }
            }
          };
          _proto.parseAC3PES = function parseAC3PES(track, pes) {
          };
          _proto.parseID3PES = function parseID3PES(id3Track, pes) {
            if (pes.pts === void 0) {
              this.logger.warn("[tsdemuxer]: ID3 PES unknown PTS");
              return;
            }
            var id3Sample = _extends({}, pes, {
              type: this._videoTrack ? MetadataSchema.emsg : MetadataSchema.audioId3,
              duration: Number.POSITIVE_INFINITY
            });
            id3Track.samples.push(id3Sample);
          };
          return TSDemuxer2;
        }();
        function parsePID(data, offset) {
          return ((data[offset + 1] & 31) << 8) + data[offset + 2];
        }
        function parsePAT(data, offset) {
          return (data[offset + 10] & 31) << 8 | data[offset + 11];
        }
        function parsePMT(data, offset, typeSupported, isSampleAes, observer, logger5) {
          var result = {
            audioPid: -1,
            videoPid: -1,
            id3Pid: -1,
            segmentVideoCodec: "avc",
            segmentAudioCodec: "aac"
          };
          var sectionLength = (data[offset + 1] & 15) << 8 | data[offset + 2];
          var tableEnd = offset + 3 + sectionLength - 4;
          var programInfoLength = (data[offset + 10] & 15) << 8 | data[offset + 11];
          offset += 12 + programInfoLength;
          while (offset < tableEnd) {
            var pid = parsePID(data, offset);
            var esInfoLength = (data[offset + 3] & 15) << 8 | data[offset + 4];
            switch (data[offset]) {
              case 207:
                if (!isSampleAes) {
                  logEncryptedSamplesFoundInUnencryptedStream("ADTS AAC", logger5);
                  break;
                }
              /* falls through */
              case 15:
                if (result.audioPid === -1) {
                  result.audioPid = pid;
                }
                break;
              // Packetized metadata (ID3)
              case 21:
                if (result.id3Pid === -1) {
                  result.id3Pid = pid;
                }
                break;
              case 219:
                if (!isSampleAes) {
                  logEncryptedSamplesFoundInUnencryptedStream("H.264", logger5);
                  break;
                }
              /* falls through */
              case 27:
                if (result.videoPid === -1) {
                  result.videoPid = pid;
                }
                break;
              // ISO/IEC 11172-3 (MPEG-1 audio)
              // or ISO/IEC 13818-3 (MPEG-2 halved sample rate audio)
              case 3:
              case 4:
                if (!typeSupported.mpeg && !typeSupported.mp3) {
                  logger5.log("MPEG audio found, not supported in this browser");
                } else if (result.audioPid === -1) {
                  result.audioPid = pid;
                  result.segmentAudioCodec = "mp3";
                }
                break;
              case 193:
                if (!isSampleAes) {
                  logEncryptedSamplesFoundInUnencryptedStream("AC-3", logger5);
                  break;
                }
              /* falls through */
              case 129:
                {
                  logger5.warn("AC-3 in M2TS support not included in build");
                }
                break;
              case 6:
                if (result.audioPid === -1 && esInfoLength > 0) {
                  var parsePos = offset + 5;
                  var remaining = esInfoLength;
                  while (remaining > 2) {
                    var descriptorId = data[parsePos];
                    switch (descriptorId) {
                      case 106:
                        {
                          logger5.warn("AC-3 in M2TS support not included in build");
                        }
                        break;
                    }
                    var descriptorLen = data[parsePos + 1] + 2;
                    parsePos += descriptorLen;
                    remaining -= descriptorLen;
                  }
                }
                break;
              case 194:
              // SAMPLE-AES EC3
              /* falls through */
              case 135:
                emitParsingError(observer, new Error("Unsupported EC-3 in M2TS found"), void 0, logger5);
                return result;
              case 36: {
                emitParsingError(observer, new Error("Unsupported HEVC in M2TS found"), void 0, logger5);
                return result;
              }
            }
            offset += esInfoLength + 5;
          }
          return result;
        }
        function emitParsingError(observer, error, levelRetry, logger5) {
          logger5.warn("parsing error: " + error.message);
          observer.emit(Events.ERROR, Events.ERROR, {
            type: ErrorTypes.MEDIA_ERROR,
            details: ErrorDetails.FRAG_PARSING_ERROR,
            fatal: false,
            levelRetry,
            error,
            reason: error.message
          });
        }
        function logEncryptedSamplesFoundInUnencryptedStream(type, logger5) {
          logger5.log(type + " with AES-128-CBC encryption found in unencrypted stream");
        }
        function parsePES(stream, logger5) {
          var i = 0;
          var frag;
          var pesLen;
          var pesHdrLen;
          var pesPts;
          var pesDts;
          var data = stream.data;
          if (!stream || stream.size === 0) {
            return null;
          }
          while (data[0].length < 19 && data.length > 1) {
            data[0] = appendUint8Array(data[0], data[1]);
            data.splice(1, 1);
          }
          frag = data[0];
          var pesPrefix = (frag[0] << 16) + (frag[1] << 8) + frag[2];
          if (pesPrefix === 1) {
            pesLen = (frag[4] << 8) + frag[5];
            if (pesLen && pesLen > stream.size - 6) {
              return null;
            }
            var pesFlags = frag[7];
            if (pesFlags & 192) {
              pesPts = (frag[9] & 14) * 536870912 + // 1 << 29
              (frag[10] & 255) * 4194304 + // 1 << 22
              (frag[11] & 254) * 16384 + // 1 << 14
              (frag[12] & 255) * 128 + // 1 << 7
              (frag[13] & 254) / 2;
              if (pesFlags & 64) {
                pesDts = (frag[14] & 14) * 536870912 + // 1 << 29
                (frag[15] & 255) * 4194304 + // 1 << 22
                (frag[16] & 254) * 16384 + // 1 << 14
                (frag[17] & 255) * 128 + // 1 << 7
                (frag[18] & 254) / 2;
                if (pesPts - pesDts > 60 * 9e4) {
                  logger5.warn(Math.round((pesPts - pesDts) / 9e4) + "s delta between PTS and DTS, align them");
                  pesPts = pesDts;
                }
              } else {
                pesDts = pesPts;
              }
            }
            pesHdrLen = frag[8];
            var payloadStartOffset = pesHdrLen + 9;
            if (stream.size <= payloadStartOffset) {
              return null;
            }
            stream.size -= payloadStartOffset;
            var pesData = new Uint8Array(stream.size);
            for (var j = 0, dataLen = data.length; j < dataLen; j++) {
              frag = data[j];
              var len = frag.byteLength;
              if (payloadStartOffset) {
                if (payloadStartOffset > len) {
                  payloadStartOffset -= len;
                  continue;
                } else {
                  frag = frag.subarray(payloadStartOffset);
                  len -= payloadStartOffset;
                  payloadStartOffset = 0;
                }
              }
              pesData.set(frag, i);
              i += len;
            }
            if (pesLen) {
              pesLen -= pesHdrLen + 3;
            }
            return {
              data: pesData,
              pts: pesPts,
              dts: pesDts,
              len: pesLen
            };
          }
          return null;
        }
        var AAC2 = /* @__PURE__ */ function() {
          function AAC3() {
          }
          AAC3.getSilentFrame = function getSilentFrame(codec, channelCount) {
            switch (codec) {
              case "mp4a.40.2":
                if (channelCount === 1) {
                  return new Uint8Array([0, 200, 0, 128, 35, 128]);
                } else if (channelCount === 2) {
                  return new Uint8Array([33, 0, 73, 144, 2, 25, 0, 35, 128]);
                } else if (channelCount === 3) {
                  return new Uint8Array([0, 200, 0, 128, 32, 132, 1, 38, 64, 8, 100, 0, 142]);
                } else if (channelCount === 4) {
                  return new Uint8Array([0, 200, 0, 128, 32, 132, 1, 38, 64, 8, 100, 0, 128, 44, 128, 8, 2, 56]);
                } else if (channelCount === 5) {
                  return new Uint8Array([0, 200, 0, 128, 32, 132, 1, 38, 64, 8, 100, 0, 130, 48, 4, 153, 0, 33, 144, 2, 56]);
                } else if (channelCount === 6) {
                  return new Uint8Array([0, 200, 0, 128, 32, 132, 1, 38, 64, 8, 100, 0, 130, 48, 4, 153, 0, 33, 144, 2, 0, 178, 0, 32, 8, 224]);
                }
                break;
              // handle HE-AAC below (mp4a.40.5 / mp4a.40.29)
              default:
                if (channelCount === 1) {
                  return new Uint8Array([1, 64, 34, 128, 163, 78, 230, 128, 186, 8, 0, 0, 0, 28, 6, 241, 193, 10, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 94]);
                } else if (channelCount === 2) {
                  return new Uint8Array([1, 64, 34, 128, 163, 94, 230, 128, 186, 8, 0, 0, 0, 0, 149, 0, 6, 241, 161, 10, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 94]);
                } else if (channelCount === 3) {
                  return new Uint8Array([1, 64, 34, 128, 163, 94, 230, 128, 186, 8, 0, 0, 0, 0, 149, 0, 6, 241, 161, 10, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 94]);
                }
                break;
            }
            return void 0;
          };
          return AAC3;
        }();
        var UINT32_MAX2 = Math.pow(2, 32) - 1;
        var MP42 = /* @__PURE__ */ function() {
          function MP43() {
          }
          MP43.init = function init() {
            MP43.types = {
              avc1: [],
              // codingname
              avcC: [],
              hvc1: [],
              hvcC: [],
              btrt: [],
              dinf: [],
              dref: [],
              esds: [],
              ftyp: [],
              hdlr: [],
              mdat: [],
              mdhd: [],
              mdia: [],
              mfhd: [],
              minf: [],
              moof: [],
              moov: [],
              mp4a: [],
              ".mp3": [],
              dac3: [],
              "ac-3": [],
              mvex: [],
              mvhd: [],
              pasp: [],
              sdtp: [],
              stbl: [],
              stco: [],
              stsc: [],
              stsd: [],
              stsz: [],
              stts: [],
              tfdt: [],
              tfhd: [],
              traf: [],
              trak: [],
              trun: [],
              trex: [],
              tkhd: [],
              vmhd: [],
              smhd: []
            };
            var i;
            for (i in MP43.types) {
              if (MP43.types.hasOwnProperty(i)) {
                MP43.types[i] = [i.charCodeAt(0), i.charCodeAt(1), i.charCodeAt(2), i.charCodeAt(3)];
              }
            }
            var videoHdlr = new Uint8Array([
              0,
              // version 0
              0,
              0,
              0,
              // flags
              0,
              0,
              0,
              0,
              // pre_defined
              118,
              105,
              100,
              101,
              // handler_type: 'vide'
              0,
              0,
              0,
              0,
              // reserved
              0,
              0,
              0,
              0,
              // reserved
              0,
              0,
              0,
              0,
              // reserved
              86,
              105,
              100,
              101,
              111,
              72,
              97,
              110,
              100,
              108,
              101,
              114,
              0
              // name: 'VideoHandler'
            ]);
            var audioHdlr = new Uint8Array([
              0,
              // version 0
              0,
              0,
              0,
              // flags
              0,
              0,
              0,
              0,
              // pre_defined
              115,
              111,
              117,
              110,
              // handler_type: 'soun'
              0,
              0,
              0,
              0,
              // reserved
              0,
              0,
              0,
              0,
              // reserved
              0,
              0,
              0,
              0,
              // reserved
              83,
              111,
              117,
              110,
              100,
              72,
              97,
              110,
              100,
              108,
              101,
              114,
              0
              // name: 'SoundHandler'
            ]);
            MP43.HDLR_TYPES = {
              video: videoHdlr,
              audio: audioHdlr
            };
            var dref = new Uint8Array([
              0,
              // version 0
              0,
              0,
              0,
              // flags
              0,
              0,
              0,
              1,
              // entry_count
              0,
              0,
              0,
              12,
              // entry_size
              117,
              114,
              108,
              32,
              // 'url' type
              0,
              // version 0
              0,
              0,
              1
              // entry_flags
            ]);
            var stco = new Uint8Array([
              0,
              // version
              0,
              0,
              0,
              // flags
              0,
              0,
              0,
              0
              // entry_count
            ]);
            MP43.STTS = MP43.STSC = MP43.STCO = stco;
            MP43.STSZ = new Uint8Array([
              0,
              // version
              0,
              0,
              0,
              // flags
              0,
              0,
              0,
              0,
              // sample_size
              0,
              0,
              0,
              0
              // sample_count
            ]);
            MP43.VMHD = new Uint8Array([
              0,
              // version
              0,
              0,
              1,
              // flags
              0,
              0,
              // graphicsmode
              0,
              0,
              0,
              0,
              0,
              0
              // opcolor
            ]);
            MP43.SMHD = new Uint8Array([
              0,
              // version
              0,
              0,
              0,
              // flags
              0,
              0,
              // balance
              0,
              0
              // reserved
            ]);
            MP43.STSD = new Uint8Array([
              0,
              // version 0
              0,
              0,
              0,
              // flags
              0,
              0,
              0,
              1
            ]);
            var majorBrand = new Uint8Array([105, 115, 111, 109]);
            var avc1Brand = new Uint8Array([97, 118, 99, 49]);
            var minorVersion = new Uint8Array([0, 0, 0, 1]);
            MP43.FTYP = MP43.box(MP43.types.ftyp, majorBrand, minorVersion, majorBrand, avc1Brand);
            MP43.DINF = MP43.box(MP43.types.dinf, MP43.box(MP43.types.dref, dref));
          };
          MP43.box = function box(type) {
            var size = 8;
            for (var _len = arguments.length, payload = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
              payload[_key - 1] = arguments[_key];
            }
            var i = payload.length;
            var len = i;
            while (i--) {
              size += payload[i].byteLength;
            }
            var result = new Uint8Array(size);
            result[0] = size >> 24 & 255;
            result[1] = size >> 16 & 255;
            result[2] = size >> 8 & 255;
            result[3] = size & 255;
            result.set(type, 4);
            for (i = 0, size = 8; i < len; i++) {
              result.set(payload[i], size);
              size += payload[i].byteLength;
            }
            return result;
          };
          MP43.hdlr = function hdlr(type) {
            return MP43.box(MP43.types.hdlr, MP43.HDLR_TYPES[type]);
          };
          MP43.mdat = function mdat(data) {
            return MP43.box(MP43.types.mdat, data);
          };
          MP43.mdhd = function mdhd(timescale, duration) {
            duration *= timescale;
            var upperWordDuration = Math.floor(duration / (UINT32_MAX2 + 1));
            var lowerWordDuration = Math.floor(duration % (UINT32_MAX2 + 1));
            return MP43.box(MP43.types.mdhd, new Uint8Array([
              1,
              // version 1
              0,
              0,
              0,
              // flags
              0,
              0,
              0,
              0,
              0,
              0,
              0,
              2,
              // creation_time
              0,
              0,
              0,
              0,
              0,
              0,
              0,
              3,
              // modification_time
              timescale >> 24 & 255,
              timescale >> 16 & 255,
              timescale >> 8 & 255,
              timescale & 255,
              // timescale
              upperWordDuration >> 24,
              upperWordDuration >> 16 & 255,
              upperWordDuration >> 8 & 255,
              upperWordDuration & 255,
              lowerWordDuration >> 24,
              lowerWordDuration >> 16 & 255,
              lowerWordDuration >> 8 & 255,
              lowerWordDuration & 255,
              85,
              196,
              // 'und' language (undetermined)
              0,
              0
            ]));
          };
          MP43.mdia = function mdia(track) {
            return MP43.box(MP43.types.mdia, MP43.mdhd(track.timescale || 0, track.duration || 0), MP43.hdlr(track.type), MP43.minf(track));
          };
          MP43.mfhd = function mfhd(sequenceNumber) {
            return MP43.box(MP43.types.mfhd, new Uint8Array([
              0,
              0,
              0,
              0,
              // flags
              sequenceNumber >> 24,
              sequenceNumber >> 16 & 255,
              sequenceNumber >> 8 & 255,
              sequenceNumber & 255
              // sequence_number
            ]));
          };
          MP43.minf = function minf(track) {
            if (track.type === "audio") {
              return MP43.box(MP43.types.minf, MP43.box(MP43.types.smhd, MP43.SMHD), MP43.DINF, MP43.stbl(track));
            } else {
              return MP43.box(MP43.types.minf, MP43.box(MP43.types.vmhd, MP43.VMHD), MP43.DINF, MP43.stbl(track));
            }
          };
          MP43.moof = function moof(sn, baseMediaDecodeTime, track) {
            return MP43.box(MP43.types.moof, MP43.mfhd(sn), MP43.traf(track, baseMediaDecodeTime));
          };
          MP43.moov = function moov(tracks) {
            var i = tracks.length;
            var boxes = [];
            while (i--) {
              boxes[i] = MP43.trak(tracks[i]);
            }
            return MP43.box.apply(null, [MP43.types.moov, MP43.mvhd(tracks[0].timescale || 0, tracks[0].duration || 0)].concat(boxes).concat(MP43.mvex(tracks)));
          };
          MP43.mvex = function mvex(tracks) {
            var i = tracks.length;
            var boxes = [];
            while (i--) {
              boxes[i] = MP43.trex(tracks[i]);
            }
            return MP43.box.apply(null, [MP43.types.mvex].concat(boxes));
          };
          MP43.mvhd = function mvhd(timescale, duration) {
            duration *= timescale;
            var upperWordDuration = Math.floor(duration / (UINT32_MAX2 + 1));
            var lowerWordDuration = Math.floor(duration % (UINT32_MAX2 + 1));
            var bytes = new Uint8Array([
              1,
              // version 1
              0,
              0,
              0,
              // flags
              0,
              0,
              0,
              0,
              0,
              0,
              0,
              2,
              // creation_time
              0,
              0,
              0,
              0,
              0,
              0,
              0,
              3,
              // modification_time
              timescale >> 24 & 255,
              timescale >> 16 & 255,
              timescale >> 8 & 255,
              timescale & 255,
              // timescale
              upperWordDuration >> 24,
              upperWordDuration >> 16 & 255,
              upperWordDuration >> 8 & 255,
              upperWordDuration & 255,
              lowerWordDuration >> 24,
              lowerWordDuration >> 16 & 255,
              lowerWordDuration >> 8 & 255,
              lowerWordDuration & 255,
              0,
              1,
              0,
              0,
              // 1.0 rate
              1,
              0,
              // 1.0 volume
              0,
              0,
              // reserved
              0,
              0,
              0,
              0,
              // reserved
              0,
              0,
              0,
              0,
              // reserved
              0,
              1,
              0,
              0,
              0,
              0,
              0,
              0,
              0,
              0,
              0,
              0,
              0,
              0,
              0,
              0,
              0,
              1,
              0,
              0,
              0,
              0,
              0,
              0,
              0,
              0,
              0,
              0,
              0,
              0,
              0,
              0,
              64,
              0,
              0,
              0,
              // transformation: unity matrix
              0,
              0,
              0,
              0,
              0,
              0,
              0,
              0,
              0,
              0,
              0,
              0,
              0,
              0,
              0,
              0,
              0,
              0,
              0,
              0,
              0,
              0,
              0,
              0,
              // pre_defined
              255,
              255,
              255,
              255
              // next_track_ID
            ]);
            return MP43.box(MP43.types.mvhd, bytes);
          };
          MP43.sdtp = function sdtp(track) {
            var samples = track.samples || [];
            var bytes = new Uint8Array(4 + samples.length);
            var i;
            var flags;
            for (i = 0; i < samples.length; i++) {
              flags = samples[i].flags;
              bytes[i + 4] = flags.dependsOn << 4 | flags.isDependedOn << 2 | flags.hasRedundancy;
            }
            return MP43.box(MP43.types.sdtp, bytes);
          };
          MP43.stbl = function stbl(track) {
            return MP43.box(MP43.types.stbl, MP43.stsd(track), MP43.box(MP43.types.stts, MP43.STTS), MP43.box(MP43.types.stsc, MP43.STSC), MP43.box(MP43.types.stsz, MP43.STSZ), MP43.box(MP43.types.stco, MP43.STCO));
          };
          MP43.avc1 = function avc1(track) {
            var sps = [];
            var pps = [];
            var i;
            var data;
            var len;
            for (i = 0; i < track.sps.length; i++) {
              data = track.sps[i];
              len = data.byteLength;
              sps.push(len >>> 8 & 255);
              sps.push(len & 255);
              sps = sps.concat(Array.prototype.slice.call(data));
            }
            for (i = 0; i < track.pps.length; i++) {
              data = track.pps[i];
              len = data.byteLength;
              pps.push(len >>> 8 & 255);
              pps.push(len & 255);
              pps = pps.concat(Array.prototype.slice.call(data));
            }
            var avcc = MP43.box(MP43.types.avcC, new Uint8Array([
              1,
              // version
              sps[3],
              // profile
              sps[4],
              // profile compat
              sps[5],
              // level
              252 | 3,
              // lengthSizeMinusOne, hard-coded to 4 bytes
              224 | track.sps.length
              // 3bit reserved (111) + numOfSequenceParameterSets
            ].concat(sps).concat([
              track.pps.length
              // numOfPictureParameterSets
            ]).concat(pps)));
            var width = track.width;
            var height = track.height;
            var hSpacing = track.pixelRatio[0];
            var vSpacing = track.pixelRatio[1];
            return MP43.box(
              MP43.types.avc1,
              new Uint8Array([
                0,
                0,
                0,
                // reserved
                0,
                0,
                0,
                // reserved
                0,
                1,
                // data_reference_index
                0,
                0,
                // pre_defined
                0,
                0,
                // reserved
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                // pre_defined
                width >> 8 & 255,
                width & 255,
                // width
                height >> 8 & 255,
                height & 255,
                // height
                0,
                72,
                0,
                0,
                // horizresolution
                0,
                72,
                0,
                0,
                // vertresolution
                0,
                0,
                0,
                0,
                // reserved
                0,
                1,
                // frame_count
                18,
                100,
                97,
                105,
                108,
                // dailymotion/hls.js
                121,
                109,
                111,
                116,
                105,
                111,
                110,
                47,
                104,
                108,
                115,
                46,
                106,
                115,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                // compressorname
                0,
                24,
                // depth = 24
                17,
                17
              ]),
              // pre_defined = -1
              avcc,
              MP43.box(MP43.types.btrt, new Uint8Array([
                0,
                28,
                156,
                128,
                // bufferSizeDB
                0,
                45,
                198,
                192,
                // maxBitrate
                0,
                45,
                198,
                192
              ])),
              // avgBitrate
              MP43.box(MP43.types.pasp, new Uint8Array([
                hSpacing >> 24,
                // hSpacing
                hSpacing >> 16 & 255,
                hSpacing >> 8 & 255,
                hSpacing & 255,
                vSpacing >> 24,
                // vSpacing
                vSpacing >> 16 & 255,
                vSpacing >> 8 & 255,
                vSpacing & 255
              ]))
            );
          };
          MP43.esds = function esds(track) {
            var config = track.config;
            return new Uint8Array([
              0,
              // version 0
              0,
              0,
              0,
              // flags
              3,
              // descriptor_type
              25,
              // length
              0,
              1,
              // es_id
              0,
              // stream_priority
              4,
              // descriptor_type
              17,
              // length
              64,
              // codec : mpeg4_audio
              21,
              // stream_type
              0,
              0,
              0,
              // buffer_size
              0,
              0,
              0,
              0,
              // maxBitrate
              0,
              0,
              0,
              0,
              // avgBitrate
              5,
              // descriptor_type
              2
            ].concat(config, [
              6,
              1,
              2
              // GASpecificConfig)); // length + audio config descriptor
            ]));
          };
          MP43.audioStsd = function audioStsd(track) {
            var samplerate = track.samplerate || 0;
            return new Uint8Array([
              0,
              0,
              0,
              // reserved
              0,
              0,
              0,
              // reserved
              0,
              1,
              // data_reference_index
              0,
              0,
              0,
              0,
              0,
              0,
              0,
              0,
              // reserved
              0,
              track.channelCount || 0,
              // channelcount
              0,
              16,
              // sampleSize:16bits
              0,
              0,
              0,
              0,
              // reserved2
              samplerate >> 8 & 255,
              samplerate & 255,
              //
              0,
              0
            ]);
          };
          MP43.mp4a = function mp4a(track) {
            return MP43.box(MP43.types.mp4a, MP43.audioStsd(track), MP43.box(MP43.types.esds, MP43.esds(track)));
          };
          MP43.mp3 = function mp3(track) {
            return MP43.box(MP43.types[".mp3"], MP43.audioStsd(track));
          };
          MP43.ac3 = function ac3(track) {
            return MP43.box(MP43.types["ac-3"], MP43.audioStsd(track), MP43.box(MP43.types.dac3, track.config));
          };
          MP43.stsd = function stsd(track) {
            var segmentCodec = track.segmentCodec;
            if (track.type === "audio") {
              if (segmentCodec === "aac") {
                return MP43.box(MP43.types.stsd, MP43.STSD, MP43.mp4a(track));
              }
              if (segmentCodec === "mp3" && track.codec === "mp3") {
                return MP43.box(MP43.types.stsd, MP43.STSD, MP43.mp3(track));
              }
            } else {
              if (track.pps && track.sps) {
                if (segmentCodec === "avc") {
                  return MP43.box(MP43.types.stsd, MP43.STSD, MP43.avc1(track));
                }
              } else {
                throw new Error("video track missing pps or sps");
              }
            }
            throw new Error("unsupported " + track.type + " segment codec (" + segmentCodec + "/" + track.codec + ")");
          };
          MP43.tkhd = function tkhd(track) {
            var id = track.id;
            var duration = (track.duration || 0) * (track.timescale || 0);
            var width = track.width || 0;
            var height = track.height || 0;
            var upperWordDuration = Math.floor(duration / (UINT32_MAX2 + 1));
            var lowerWordDuration = Math.floor(duration % (UINT32_MAX2 + 1));
            return MP43.box(MP43.types.tkhd, new Uint8Array([
              1,
              // version 1
              0,
              0,
              7,
              // flags
              0,
              0,
              0,
              0,
              0,
              0,
              0,
              2,
              // creation_time
              0,
              0,
              0,
              0,
              0,
              0,
              0,
              3,
              // modification_time
              id >> 24 & 255,
              id >> 16 & 255,
              id >> 8 & 255,
              id & 255,
              // track_ID
              0,
              0,
              0,
              0,
              // reserved
              upperWordDuration >> 24,
              upperWordDuration >> 16 & 255,
              upperWordDuration >> 8 & 255,
              upperWordDuration & 255,
              lowerWordDuration >> 24,
              lowerWordDuration >> 16 & 255,
              lowerWordDuration >> 8 & 255,
              lowerWordDuration & 255,
              0,
              0,
              0,
              0,
              0,
              0,
              0,
              0,
              // reserved
              0,
              0,
              // layer
              0,
              0,
              // alternate_group
              0,
              0,
              // non-audio track volume
              0,
              0,
              // reserved
              0,
              1,
              0,
              0,
              0,
              0,
              0,
              0,
              0,
              0,
              0,
              0,
              0,
              0,
              0,
              0,
              0,
              1,
              0,
              0,
              0,
              0,
              0,
              0,
              0,
              0,
              0,
              0,
              0,
              0,
              0,
              0,
              64,
              0,
              0,
              0,
              // transformation: unity matrix
              width >> 8 & 255,
              width & 255,
              0,
              0,
              // width
              height >> 8 & 255,
              height & 255,
              0,
              0
              // height
            ]));
          };
          MP43.traf = function traf(track, baseMediaDecodeTime) {
            var sampleDependencyTable = MP43.sdtp(track);
            var id = track.id;
            var upperWordBaseMediaDecodeTime = Math.floor(baseMediaDecodeTime / (UINT32_MAX2 + 1));
            var lowerWordBaseMediaDecodeTime = Math.floor(baseMediaDecodeTime % (UINT32_MAX2 + 1));
            return MP43.box(
              MP43.types.traf,
              MP43.box(MP43.types.tfhd, new Uint8Array([
                0,
                // version 0
                0,
                0,
                0,
                // flags
                id >> 24,
                id >> 16 & 255,
                id >> 8 & 255,
                id & 255
                // track_ID
              ])),
              MP43.box(MP43.types.tfdt, new Uint8Array([
                1,
                // version 1
                0,
                0,
                0,
                // flags
                upperWordBaseMediaDecodeTime >> 24,
                upperWordBaseMediaDecodeTime >> 16 & 255,
                upperWordBaseMediaDecodeTime >> 8 & 255,
                upperWordBaseMediaDecodeTime & 255,
                lowerWordBaseMediaDecodeTime >> 24,
                lowerWordBaseMediaDecodeTime >> 16 & 255,
                lowerWordBaseMediaDecodeTime >> 8 & 255,
                lowerWordBaseMediaDecodeTime & 255
              ])),
              MP43.trun(track, sampleDependencyTable.length + 16 + // tfhd
              20 + // tfdt
              8 + // traf header
              16 + // mfhd
              8 + // moof header
              8),
              // mdat header
              sampleDependencyTable
            );
          };
          MP43.trak = function trak(track) {
            track.duration = track.duration || 4294967295;
            return MP43.box(MP43.types.trak, MP43.tkhd(track), MP43.mdia(track));
          };
          MP43.trex = function trex(track) {
            var id = track.id;
            return MP43.box(MP43.types.trex, new Uint8Array([
              0,
              // version 0
              0,
              0,
              0,
              // flags
              id >> 24,
              id >> 16 & 255,
              id >> 8 & 255,
              id & 255,
              // track_ID
              0,
              0,
              0,
              1,
              // default_sample_description_index
              0,
              0,
              0,
              0,
              // default_sample_duration
              0,
              0,
              0,
              0,
              // default_sample_size
              0,
              1,
              0,
              1
              // default_sample_flags
            ]));
          };
          MP43.trun = function trun(track, offset) {
            var samples = track.samples || [];
            var len = samples.length;
            var arraylen = 12 + 16 * len;
            var array = new Uint8Array(arraylen);
            var i;
            var sample;
            var duration;
            var size;
            var flags;
            var cts;
            offset += 8 + arraylen;
            array.set([
              track.type === "video" ? 1 : 0,
              // version 1 for video with signed-int sample_composition_time_offset
              0,
              15,
              1,
              // flags
              len >>> 24 & 255,
              len >>> 16 & 255,
              len >>> 8 & 255,
              len & 255,
              // sample_count
              offset >>> 24 & 255,
              offset >>> 16 & 255,
              offset >>> 8 & 255,
              offset & 255
              // data_offset
            ], 0);
            for (i = 0; i < len; i++) {
              sample = samples[i];
              duration = sample.duration;
              size = sample.size;
              flags = sample.flags;
              cts = sample.cts;
              array.set([
                duration >>> 24 & 255,
                duration >>> 16 & 255,
                duration >>> 8 & 255,
                duration & 255,
                // sample_duration
                size >>> 24 & 255,
                size >>> 16 & 255,
                size >>> 8 & 255,
                size & 255,
                // sample_size
                flags.isLeading << 2 | flags.dependsOn,
                flags.isDependedOn << 6 | flags.hasRedundancy << 4 | flags.paddingValue << 1 | flags.isNonSync,
                flags.degradPrio & 240 << 8,
                flags.degradPrio & 15,
                // sample_flags
                cts >>> 24 & 255,
                cts >>> 16 & 255,
                cts >>> 8 & 255,
                cts & 255
                // sample_composition_time_offset
              ], 12 + 16 * i);
            }
            return MP43.box(MP43.types.trun, array);
          };
          MP43.initSegment = function initSegment(tracks) {
            if (!MP43.types) {
              MP43.init();
            }
            var movie = MP43.moov(tracks);
            var result = appendUint8Array(MP43.FTYP, movie);
            return result;
          };
          MP43.hvc1 = function hvc1(track) {
            {
              return new Uint8Array();
            }
          };
          return MP43;
        }();
        MP42.types = void 0;
        MP42.HDLR_TYPES = void 0;
        MP42.STTS = void 0;
        MP42.STSC = void 0;
        MP42.STCO = void 0;
        MP42.STSZ = void 0;
        MP42.VMHD = void 0;
        MP42.SMHD = void 0;
        MP42.STSD = void 0;
        MP42.FTYP = void 0;
        MP42.DINF = void 0;
        var MPEG_TS_CLOCK_FREQ_HZ = 9e4;
        function toTimescaleFromBase(baseTime, destScale, srcBase, round) {
          var result = baseTime * destScale * srcBase;
          return Math.round(result);
        }
        function toMsFromMpegTsClock(baseTime, round) {
          return toTimescaleFromBase(baseTime, 1e3, 1 / MPEG_TS_CLOCK_FREQ_HZ);
        }
        var MAX_SILENT_FRAME_DURATION2 = 10 * 1e3;
        var AAC_SAMPLES_PER_FRAME = 1024;
        var MPEG_AUDIO_SAMPLE_PER_FRAME = 1152;
        var AC3_SAMPLES_PER_FRAME = 1536;
        var chromeVersion = null;
        var safariWebkitVersion = null;
        function createMp4Sample(isKeyframe, duration, size, cts) {
          return {
            duration,
            size,
            cts,
            flags: {
              isLeading: 0,
              isDependedOn: 0,
              hasRedundancy: 0,
              degradPrio: 0,
              dependsOn: isKeyframe ? 2 : 1,
              isNonSync: isKeyframe ? 0 : 1
            }
          };
        }
        var MP4Remuxer = /* @__PURE__ */ function() {
          function MP4Remuxer2(observer, config, typeSupported, logger5) {
            this.logger = void 0;
            this.observer = void 0;
            this.config = void 0;
            this.typeSupported = void 0;
            this.ISGenerated = false;
            this._initPTS = null;
            this._initDTS = null;
            this.nextAvcDts = null;
            this.nextAudioPts = null;
            this.videoSampleDuration = null;
            this.isAudioContiguous = false;
            this.isVideoContiguous = false;
            this.videoTrackConfig = void 0;
            this.observer = observer;
            this.config = config;
            this.typeSupported = typeSupported;
            this.logger = logger5;
            this.ISGenerated = false;
            if (chromeVersion === null) {
              var userAgent = navigator.userAgent || "";
              var result = userAgent.match(/Chrome\/(\d+)/i);
              chromeVersion = result ? parseInt(result[1]) : 0;
            }
            if (safariWebkitVersion === null) {
              var _result = navigator.userAgent.match(/Safari\/(\d+)/i);
              safariWebkitVersion = _result ? parseInt(_result[1]) : 0;
            }
          }
          var _proto = MP4Remuxer2.prototype;
          _proto.destroy = function destroy() {
            this.config = this.videoTrackConfig = this._initPTS = this._initDTS = null;
          };
          _proto.resetTimeStamp = function resetTimeStamp(defaultTimeStamp) {
            this.logger.log("[mp4-remuxer]: initPTS & initDTS reset");
            this._initPTS = this._initDTS = defaultTimeStamp;
          };
          _proto.resetNextTimestamp = function resetNextTimestamp() {
            this.logger.log("[mp4-remuxer]: reset next timestamp");
            this.isVideoContiguous = false;
            this.isAudioContiguous = false;
          };
          _proto.resetInitSegment = function resetInitSegment() {
            this.logger.log("[mp4-remuxer]: ISGenerated flag reset");
            this.ISGenerated = false;
            this.videoTrackConfig = void 0;
          };
          _proto.getVideoStartPts = function getVideoStartPts(videoSamples) {
            var rolloverDetected = false;
            var firstPts = videoSamples[0].pts;
            var startPTS = videoSamples.reduce(function(minPTS, sample) {
              var pts = sample.pts;
              var delta = pts - minPTS;
              if (delta < -4294967296) {
                rolloverDetected = true;
                pts = normalizePts(pts, firstPts);
                delta = pts - minPTS;
              }
              if (delta > 0) {
                return minPTS;
              }
              return pts;
            }, firstPts);
            if (rolloverDetected) {
              this.logger.debug("PTS rollover detected");
            }
            return startPTS;
          };
          _proto.remux = function remux(audioTrack, videoTrack, id3Track, textTrack, timeOffset, accurateTimeOffset, flush, playlistType) {
            var video;
            var audio;
            var initSegment;
            var text;
            var id3;
            var independent;
            var audioTimeOffset = timeOffset;
            var videoTimeOffset = timeOffset;
            var hasAudio = audioTrack.pid > -1;
            var hasVideo = videoTrack.pid > -1;
            var length = videoTrack.samples.length;
            var enoughAudioSamples = audioTrack.samples.length > 0;
            var enoughVideoSamples = flush && length > 0 || length > 1;
            var canRemuxAvc = (!hasAudio || enoughAudioSamples) && (!hasVideo || enoughVideoSamples) || this.ISGenerated || flush;
            if (canRemuxAvc) {
              if (this.ISGenerated) {
                var _videoTrack$pixelRati, _config$pixelRatio, _videoTrack$pixelRati2, _config$pixelRatio2;
                var config = this.videoTrackConfig;
                if (config && (videoTrack.width !== config.width || videoTrack.height !== config.height || ((_videoTrack$pixelRati = videoTrack.pixelRatio) == null ? void 0 : _videoTrack$pixelRati[0]) !== ((_config$pixelRatio = config.pixelRatio) == null ? void 0 : _config$pixelRatio[0]) || ((_videoTrack$pixelRati2 = videoTrack.pixelRatio) == null ? void 0 : _videoTrack$pixelRati2[1]) !== ((_config$pixelRatio2 = config.pixelRatio) == null ? void 0 : _config$pixelRatio2[1])) || !config && enoughVideoSamples || this.nextAudioPts === null && enoughAudioSamples) {
                  this.resetInitSegment();
                }
              }
              if (!this.ISGenerated) {
                initSegment = this.generateIS(audioTrack, videoTrack, timeOffset, accurateTimeOffset);
              }
              var isVideoContiguous = this.isVideoContiguous;
              var firstKeyFrameIndex = -1;
              var firstKeyFramePTS;
              if (enoughVideoSamples) {
                firstKeyFrameIndex = findKeyframeIndex(videoTrack.samples);
                if (!isVideoContiguous && this.config.forceKeyFrameOnDiscontinuity) {
                  independent = true;
                  if (firstKeyFrameIndex > 0) {
                    this.logger.warn("[mp4-remuxer]: Dropped " + firstKeyFrameIndex + " out of " + length + " video samples due to a missing keyframe");
                    var startPTS = this.getVideoStartPts(videoTrack.samples);
                    videoTrack.samples = videoTrack.samples.slice(firstKeyFrameIndex);
                    videoTrack.dropped += firstKeyFrameIndex;
                    videoTimeOffset += (videoTrack.samples[0].pts - startPTS) / videoTrack.inputTimeScale;
                    firstKeyFramePTS = videoTimeOffset;
                  } else if (firstKeyFrameIndex === -1) {
                    this.logger.warn("[mp4-remuxer]: No keyframe found out of " + length + " video samples");
                    independent = false;
                  }
                }
              }
              if (this.ISGenerated) {
                if (enoughAudioSamples && enoughVideoSamples) {
                  var _startPTS = this.getVideoStartPts(videoTrack.samples);
                  var tsDelta = normalizePts(audioTrack.samples[0].pts, _startPTS) - _startPTS;
                  var audiovideoTimestampDelta = tsDelta / videoTrack.inputTimeScale;
                  audioTimeOffset += Math.max(0, audiovideoTimestampDelta);
                  videoTimeOffset += Math.max(0, -audiovideoTimestampDelta);
                }
                if (enoughAudioSamples) {
                  if (!audioTrack.samplerate) {
                    this.logger.warn("[mp4-remuxer]: regenerate InitSegment as audio detected");
                    initSegment = this.generateIS(audioTrack, videoTrack, timeOffset, accurateTimeOffset);
                  }
                  audio = this.remuxAudio(audioTrack, audioTimeOffset, this.isAudioContiguous, accurateTimeOffset, hasVideo || enoughVideoSamples || playlistType === PlaylistLevelType.AUDIO ? videoTimeOffset : void 0);
                  if (enoughVideoSamples) {
                    var audioTrackLength = audio ? audio.endPTS - audio.startPTS : 0;
                    if (!videoTrack.inputTimeScale) {
                      this.logger.warn("[mp4-remuxer]: regenerate InitSegment as video detected");
                      initSegment = this.generateIS(audioTrack, videoTrack, timeOffset, accurateTimeOffset);
                    }
                    video = this.remuxVideo(videoTrack, videoTimeOffset, isVideoContiguous, audioTrackLength);
                  }
                } else if (enoughVideoSamples) {
                  video = this.remuxVideo(videoTrack, videoTimeOffset, isVideoContiguous, 0);
                }
                if (video) {
                  video.firstKeyFrame = firstKeyFrameIndex;
                  video.independent = firstKeyFrameIndex !== -1;
                  video.firstKeyFramePTS = firstKeyFramePTS;
                }
              }
            }
            if (this.ISGenerated && this._initPTS && this._initDTS) {
              if (id3Track.samples.length) {
                id3 = flushTextTrackMetadataCueSamples(id3Track, timeOffset, this._initPTS, this._initDTS);
              }
              if (textTrack.samples.length) {
                text = flushTextTrackUserdataCueSamples(textTrack, timeOffset, this._initPTS);
              }
            }
            return {
              audio,
              video,
              initSegment,
              independent,
              text,
              id3
            };
          };
          _proto.generateIS = function generateIS(audioTrack, videoTrack, timeOffset, accurateTimeOffset) {
            var audioSamples = audioTrack.samples;
            var videoSamples = videoTrack.samples;
            var typeSupported = this.typeSupported;
            var tracks = {};
            var _initPTS = this._initPTS;
            var computePTSDTS = !_initPTS || accurateTimeOffset;
            var container = "audio/mp4";
            var initPTS;
            var initDTS;
            var timescale;
            if (computePTSDTS) {
              initPTS = initDTS = Infinity;
            }
            if (audioTrack.config && audioSamples.length) {
              audioTrack.timescale = audioTrack.samplerate;
              switch (audioTrack.segmentCodec) {
                case "mp3":
                  if (typeSupported.mpeg) {
                    container = "audio/mpeg";
                    audioTrack.codec = "";
                  } else if (typeSupported.mp3) {
                    audioTrack.codec = "mp3";
                  }
                  break;
                case "ac3":
                  audioTrack.codec = "ac-3";
                  break;
              }
              tracks.audio = {
                id: "audio",
                container,
                codec: audioTrack.codec,
                initSegment: audioTrack.segmentCodec === "mp3" && typeSupported.mpeg ? new Uint8Array(0) : MP42.initSegment([audioTrack]),
                metadata: {
                  channelCount: audioTrack.channelCount
                }
              };
              if (computePTSDTS) {
                timescale = audioTrack.inputTimeScale;
                if (!_initPTS || timescale !== _initPTS.timescale) {
                  initPTS = initDTS = audioSamples[0].pts - Math.round(timescale * timeOffset);
                } else {
                  computePTSDTS = false;
                }
              }
            }
            if (videoTrack.sps && videoTrack.pps && videoSamples.length) {
              videoTrack.timescale = videoTrack.inputTimeScale;
              tracks.video = {
                id: "main",
                container: "video/mp4",
                codec: videoTrack.codec,
                initSegment: MP42.initSegment([videoTrack]),
                metadata: {
                  width: videoTrack.width,
                  height: videoTrack.height
                }
              };
              if (computePTSDTS) {
                timescale = videoTrack.inputTimeScale;
                if (!_initPTS || timescale !== _initPTS.timescale) {
                  var startPTS = this.getVideoStartPts(videoSamples);
                  var startOffset = Math.round(timescale * timeOffset);
                  initDTS = Math.min(initDTS, normalizePts(videoSamples[0].dts, startPTS) - startOffset);
                  initPTS = Math.min(initPTS, startPTS - startOffset);
                } else {
                  computePTSDTS = false;
                }
              }
              this.videoTrackConfig = {
                width: videoTrack.width,
                height: videoTrack.height,
                pixelRatio: videoTrack.pixelRatio
              };
            }
            if (Object.keys(tracks).length) {
              this.ISGenerated = true;
              if (computePTSDTS) {
                this._initPTS = {
                  baseTime: initPTS,
                  timescale
                };
                this._initDTS = {
                  baseTime: initDTS,
                  timescale
                };
              } else {
                initPTS = timescale = void 0;
              }
              return {
                tracks,
                initPTS,
                timescale
              };
            }
          };
          _proto.remuxVideo = function remuxVideo(track, timeOffset, contiguous, audioTrackLength) {
            var timeScale = track.inputTimeScale;
            var inputSamples = track.samples;
            var outputSamples = [];
            var nbSamples = inputSamples.length;
            var initPTS = this._initPTS;
            var nextAvcDts = this.nextAvcDts;
            var offset = 8;
            var mp4SampleDuration = this.videoSampleDuration;
            var firstDTS;
            var lastDTS;
            var minPTS = Number.POSITIVE_INFINITY;
            var maxPTS = Number.NEGATIVE_INFINITY;
            var sortSamples = false;
            if (!contiguous || nextAvcDts === null) {
              var pts = timeOffset * timeScale;
              var cts = inputSamples[0].pts - normalizePts(inputSamples[0].dts, inputSamples[0].pts);
              if (chromeVersion && nextAvcDts !== null && Math.abs(pts - cts - nextAvcDts) < 15e3) {
                contiguous = true;
              } else {
                nextAvcDts = pts - cts;
              }
            }
            var initTime = initPTS.baseTime * timeScale / initPTS.timescale;
            for (var i = 0; i < nbSamples; i++) {
              var sample = inputSamples[i];
              sample.pts = normalizePts(sample.pts - initTime, nextAvcDts);
              sample.dts = normalizePts(sample.dts - initTime, nextAvcDts);
              if (sample.dts < inputSamples[i > 0 ? i - 1 : i].dts) {
                sortSamples = true;
              }
            }
            if (sortSamples) {
              inputSamples.sort(function(a, b) {
                var deltadts = a.dts - b.dts;
                var deltapts = a.pts - b.pts;
                return deltadts || deltapts;
              });
            }
            firstDTS = inputSamples[0].dts;
            lastDTS = inputSamples[inputSamples.length - 1].dts;
            var inputDuration = lastDTS - firstDTS;
            var averageSampleDuration = inputDuration ? Math.round(inputDuration / (nbSamples - 1)) : mp4SampleDuration || track.inputTimeScale / 30;
            if (contiguous) {
              var delta = firstDTS - nextAvcDts;
              var foundHole = delta > averageSampleDuration;
              var foundOverlap = delta < -1;
              if (foundHole || foundOverlap) {
                if (foundHole) {
                  this.logger.warn((track.segmentCodec || "").toUpperCase() + ": " + toMsFromMpegTsClock(delta) + " ms (" + delta + "dts) hole between fragments detected at " + timeOffset.toFixed(3));
                } else {
                  this.logger.warn((track.segmentCodec || "").toUpperCase() + ": " + toMsFromMpegTsClock(-delta) + " ms (" + delta + "dts) overlapping between fragments detected at " + timeOffset.toFixed(3));
                }
                if (!foundOverlap || nextAvcDts >= inputSamples[0].pts || chromeVersion) {
                  firstDTS = nextAvcDts;
                  var firstPTS = inputSamples[0].pts - delta;
                  if (foundHole) {
                    inputSamples[0].dts = firstDTS;
                    inputSamples[0].pts = firstPTS;
                  } else {
                    var isPTSOrderRetained = true;
                    for (var _i = 0; _i < inputSamples.length; _i++) {
                      if (inputSamples[_i].dts > firstPTS && isPTSOrderRetained) {
                        break;
                      }
                      var prevPTS = inputSamples[_i].pts;
                      inputSamples[_i].dts -= delta;
                      inputSamples[_i].pts -= delta;
                      if (_i < inputSamples.length - 1) {
                        var nextSamplePTS = inputSamples[_i + 1].pts;
                        var currentSamplePTS = inputSamples[_i].pts;
                        var currentOrder = nextSamplePTS <= currentSamplePTS;
                        var prevOrder = nextSamplePTS <= prevPTS;
                        isPTSOrderRetained = currentOrder == prevOrder;
                      }
                    }
                  }
                  this.logger.log("Video: Initial PTS/DTS adjusted: " + toMsFromMpegTsClock(firstPTS) + "/" + toMsFromMpegTsClock(firstDTS) + ", delta: " + toMsFromMpegTsClock(delta) + " ms");
                }
              }
            }
            firstDTS = Math.max(0, firstDTS);
            var nbNalu = 0;
            var naluLen = 0;
            var dtsStep = firstDTS;
            for (var _i2 = 0; _i2 < nbSamples; _i2++) {
              var _sample = inputSamples[_i2];
              var units = _sample.units;
              var nbUnits = units.length;
              var sampleLen = 0;
              for (var j = 0; j < nbUnits; j++) {
                sampleLen += units[j].data.length;
              }
              naluLen += sampleLen;
              nbNalu += nbUnits;
              _sample.length = sampleLen;
              if (_sample.dts < dtsStep) {
                _sample.dts = dtsStep;
                dtsStep += averageSampleDuration / 4 | 0 || 1;
              } else {
                dtsStep = _sample.dts;
              }
              minPTS = Math.min(_sample.pts, minPTS);
              maxPTS = Math.max(_sample.pts, maxPTS);
            }
            lastDTS = inputSamples[nbSamples - 1].dts;
            var mdatSize = naluLen + 4 * nbNalu + 8;
            var mdat;
            try {
              mdat = new Uint8Array(mdatSize);
            } catch (err) {
              this.observer.emit(Events.ERROR, Events.ERROR, {
                type: ErrorTypes.MUX_ERROR,
                details: ErrorDetails.REMUX_ALLOC_ERROR,
                fatal: false,
                error: err,
                bytes: mdatSize,
                reason: "fail allocating video mdat " + mdatSize
              });
              return;
            }
            var view2 = new DataView(mdat.buffer);
            view2.setUint32(0, mdatSize);
            mdat.set(MP42.types.mdat, 4);
            var stretchedLastFrame = false;
            var minDtsDelta = Number.POSITIVE_INFINITY;
            var minPtsDelta = Number.POSITIVE_INFINITY;
            var maxDtsDelta = Number.NEGATIVE_INFINITY;
            var maxPtsDelta = Number.NEGATIVE_INFINITY;
            for (var _i3 = 0; _i3 < nbSamples; _i3++) {
              var VideoSample2 = inputSamples[_i3];
              var VideoSampleUnits = VideoSample2.units;
              var mp4SampleLength = 0;
              for (var _j = 0, _nbUnits = VideoSampleUnits.length; _j < _nbUnits; _j++) {
                var unit = VideoSampleUnits[_j];
                var unitData = unit.data;
                var unitDataLen = unit.data.byteLength;
                view2.setUint32(offset, unitDataLen);
                offset += 4;
                mdat.set(unitData, offset);
                offset += unitDataLen;
                mp4SampleLength += 4 + unitDataLen;
              }
              var ptsDelta = void 0;
              if (_i3 < nbSamples - 1) {
                mp4SampleDuration = inputSamples[_i3 + 1].dts - VideoSample2.dts;
                ptsDelta = inputSamples[_i3 + 1].pts - VideoSample2.pts;
              } else {
                var config = this.config;
                var lastFrameDuration = _i3 > 0 ? VideoSample2.dts - inputSamples[_i3 - 1].dts : averageSampleDuration;
                ptsDelta = _i3 > 0 ? VideoSample2.pts - inputSamples[_i3 - 1].pts : averageSampleDuration;
                if (config.stretchShortVideoTrack && this.nextAudioPts !== null) {
                  var gapTolerance = Math.floor(config.maxBufferHole * timeScale);
                  var deltaToFrameEnd = (audioTrackLength ? minPTS + audioTrackLength * timeScale : this.nextAudioPts) - VideoSample2.pts;
                  if (deltaToFrameEnd > gapTolerance) {
                    mp4SampleDuration = deltaToFrameEnd - lastFrameDuration;
                    if (mp4SampleDuration < 0) {
                      mp4SampleDuration = lastFrameDuration;
                    } else {
                      stretchedLastFrame = true;
                    }
                    this.logger.log("[mp4-remuxer]: It is approximately " + deltaToFrameEnd / 90 + " ms to the next segment; using duration " + mp4SampleDuration / 90 + " ms for the last video frame.");
                  } else {
                    mp4SampleDuration = lastFrameDuration;
                  }
                } else {
                  mp4SampleDuration = lastFrameDuration;
                }
              }
              var compositionTimeOffset = Math.round(VideoSample2.pts - VideoSample2.dts);
              minDtsDelta = Math.min(minDtsDelta, mp4SampleDuration);
              maxDtsDelta = Math.max(maxDtsDelta, mp4SampleDuration);
              minPtsDelta = Math.min(minPtsDelta, ptsDelta);
              maxPtsDelta = Math.max(maxPtsDelta, ptsDelta);
              outputSamples.push(createMp4Sample(VideoSample2.key, mp4SampleDuration, mp4SampleLength, compositionTimeOffset));
            }
            if (outputSamples.length) {
              if (chromeVersion) {
                if (chromeVersion < 70) {
                  var flags = outputSamples[0].flags;
                  flags.dependsOn = 2;
                  flags.isNonSync = 0;
                }
              } else if (safariWebkitVersion) {
                if (maxPtsDelta - minPtsDelta < maxDtsDelta - minDtsDelta && averageSampleDuration / maxDtsDelta < 0.025 && outputSamples[0].cts === 0) {
                  this.logger.warn("Found irregular gaps in sample duration. Using PTS instead of DTS to determine MP4 sample duration.");
                  var dts = firstDTS;
                  for (var _i4 = 0, len = outputSamples.length; _i4 < len; _i4++) {
                    var nextDts = dts + outputSamples[_i4].duration;
                    var _pts = dts + outputSamples[_i4].cts;
                    if (_i4 < len - 1) {
                      var nextPts = nextDts + outputSamples[_i4 + 1].cts;
                      outputSamples[_i4].duration = nextPts - _pts;
                    } else {
                      outputSamples[_i4].duration = _i4 ? outputSamples[_i4 - 1].duration : averageSampleDuration;
                    }
                    outputSamples[_i4].cts = 0;
                    dts = nextDts;
                  }
                }
              }
            }
            mp4SampleDuration = stretchedLastFrame || !mp4SampleDuration ? averageSampleDuration : mp4SampleDuration;
            this.nextAvcDts = nextAvcDts = lastDTS + mp4SampleDuration;
            this.videoSampleDuration = mp4SampleDuration;
            this.isVideoContiguous = true;
            var moof = MP42.moof(track.sequenceNumber++, firstDTS, _extends(track, {
              samples: outputSamples
            }));
            var type = "video";
            var data = {
              data1: moof,
              data2: mdat,
              startPTS: minPTS / timeScale,
              endPTS: (maxPTS + mp4SampleDuration) / timeScale,
              startDTS: firstDTS / timeScale,
              endDTS: nextAvcDts / timeScale,
              type,
              hasAudio: false,
              hasVideo: true,
              nb: outputSamples.length,
              dropped: track.dropped
            };
            track.samples = [];
            track.dropped = 0;
            return data;
          };
          _proto.getSamplesPerFrame = function getSamplesPerFrame(track) {
            switch (track.segmentCodec) {
              case "mp3":
                return MPEG_AUDIO_SAMPLE_PER_FRAME;
              case "ac3":
                return AC3_SAMPLES_PER_FRAME;
              default:
                return AAC_SAMPLES_PER_FRAME;
            }
          };
          _proto.remuxAudio = function remuxAudio(track, timeOffset, contiguous, accurateTimeOffset, videoTimeOffset) {
            var inputTimeScale = track.inputTimeScale;
            var mp4timeScale = track.samplerate ? track.samplerate : inputTimeScale;
            var scaleFactor = inputTimeScale / mp4timeScale;
            var mp4SampleDuration = this.getSamplesPerFrame(track);
            var inputSampleDuration = mp4SampleDuration * scaleFactor;
            var initPTS = this._initPTS;
            var rawMPEG = track.segmentCodec === "mp3" && this.typeSupported.mpeg;
            var outputSamples = [];
            var alignedWithVideo = videoTimeOffset !== void 0;
            var inputSamples = track.samples;
            var offset = rawMPEG ? 0 : 8;
            var nextAudioPts = this.nextAudioPts || -1;
            var timeOffsetMpegTS = timeOffset * inputTimeScale;
            var initTime = initPTS.baseTime * inputTimeScale / initPTS.timescale;
            this.isAudioContiguous = contiguous = contiguous || inputSamples.length && nextAudioPts > 0 && (accurateTimeOffset && Math.abs(timeOffsetMpegTS - nextAudioPts) < 9e3 || Math.abs(normalizePts(inputSamples[0].pts - initTime, timeOffsetMpegTS) - nextAudioPts) < 20 * inputSampleDuration);
            inputSamples.forEach(function(sample2) {
              sample2.pts = normalizePts(sample2.pts - initTime, timeOffsetMpegTS);
            });
            if (!contiguous || nextAudioPts < 0) {
              inputSamples = inputSamples.filter(function(sample2) {
                return sample2.pts >= 0;
              });
              if (!inputSamples.length) {
                return;
              }
              if (videoTimeOffset === 0) {
                nextAudioPts = 0;
              } else if (accurateTimeOffset && !alignedWithVideo) {
                nextAudioPts = Math.max(0, timeOffsetMpegTS);
              } else {
                nextAudioPts = inputSamples[0].pts;
              }
            }
            if (track.segmentCodec === "aac") {
              var maxAudioFramesDrift = this.config.maxAudioFramesDrift;
              for (var i = 0, nextPts = nextAudioPts; i < inputSamples.length; i++) {
                var sample = inputSamples[i];
                var pts = sample.pts;
                var delta = pts - nextPts;
                var duration = Math.abs(1e3 * delta / inputTimeScale);
                if (delta <= -maxAudioFramesDrift * inputSampleDuration && alignedWithVideo) {
                  if (i === 0) {
                    this.logger.warn("Audio frame @ " + (pts / inputTimeScale).toFixed(3) + "s overlaps nextAudioPts by " + Math.round(1e3 * delta / inputTimeScale) + " ms.");
                    this.nextAudioPts = nextAudioPts = nextPts = pts;
                  }
                } else if (delta >= maxAudioFramesDrift * inputSampleDuration && duration < MAX_SILENT_FRAME_DURATION2 && alignedWithVideo) {
                  var missing = Math.round(delta / inputSampleDuration);
                  nextPts = pts - missing * inputSampleDuration;
                  if (nextPts < 0) {
                    missing--;
                    nextPts += inputSampleDuration;
                  }
                  if (i === 0) {
                    this.nextAudioPts = nextAudioPts = nextPts;
                  }
                  this.logger.warn("[mp4-remuxer]: Injecting " + missing + " audio frame @ " + (nextPts / inputTimeScale).toFixed(3) + "s due to " + Math.round(1e3 * delta / inputTimeScale) + " ms gap.");
                  for (var j = 0; j < missing; j++) {
                    var newStamp = Math.max(nextPts, 0);
                    var fillFrame = AAC2.getSilentFrame(track.parsedCodec || track.manifestCodec || track.codec, track.channelCount);
                    if (!fillFrame) {
                      this.logger.log("[mp4-remuxer]: Unable to get silent frame for given audio codec; duplicating last frame instead.");
                      fillFrame = sample.unit.subarray();
                    }
                    inputSamples.splice(i, 0, {
                      unit: fillFrame,
                      pts: newStamp
                    });
                    nextPts += inputSampleDuration;
                    i++;
                  }
                }
                sample.pts = nextPts;
                nextPts += inputSampleDuration;
              }
            }
            var firstPTS = null;
            var lastPTS = null;
            var mdat;
            var mdatSize = 0;
            var sampleLength = inputSamples.length;
            while (sampleLength--) {
              mdatSize += inputSamples[sampleLength].unit.byteLength;
            }
            for (var _j2 = 0, _nbSamples = inputSamples.length; _j2 < _nbSamples; _j2++) {
              var audioSample = inputSamples[_j2];
              var unit = audioSample.unit;
              var _pts2 = audioSample.pts;
              if (lastPTS !== null) {
                var prevSample = outputSamples[_j2 - 1];
                prevSample.duration = Math.round((_pts2 - lastPTS) / scaleFactor);
              } else {
                if (contiguous && track.segmentCodec === "aac") {
                  _pts2 = nextAudioPts;
                }
                firstPTS = _pts2;
                if (mdatSize > 0) {
                  mdatSize += offset;
                  try {
                    mdat = new Uint8Array(mdatSize);
                  } catch (err) {
                    this.observer.emit(Events.ERROR, Events.ERROR, {
                      type: ErrorTypes.MUX_ERROR,
                      details: ErrorDetails.REMUX_ALLOC_ERROR,
                      fatal: false,
                      error: err,
                      bytes: mdatSize,
                      reason: "fail allocating audio mdat " + mdatSize
                    });
                    return;
                  }
                  if (!rawMPEG) {
                    var view2 = new DataView(mdat.buffer);
                    view2.setUint32(0, mdatSize);
                    mdat.set(MP42.types.mdat, 4);
                  }
                } else {
                  return;
                }
              }
              mdat.set(unit, offset);
              var unitLen = unit.byteLength;
              offset += unitLen;
              outputSamples.push(createMp4Sample(true, mp4SampleDuration, unitLen, 0));
              lastPTS = _pts2;
            }
            var nbSamples = outputSamples.length;
            if (!nbSamples) {
              return;
            }
            var lastSample = outputSamples[outputSamples.length - 1];
            this.nextAudioPts = nextAudioPts = lastPTS + scaleFactor * lastSample.duration;
            var moof = rawMPEG ? new Uint8Array(0) : MP42.moof(track.sequenceNumber++, firstPTS / scaleFactor, _extends({}, track, {
              samples: outputSamples
            }));
            track.samples = [];
            var start = firstPTS / inputTimeScale;
            var end = nextAudioPts / inputTimeScale;
            var type = "audio";
            var audioData = {
              data1: moof,
              data2: mdat,
              startPTS: start,
              endPTS: end,
              startDTS: start,
              endDTS: end,
              type,
              hasAudio: true,
              hasVideo: false,
              nb: nbSamples
            };
            this.isAudioContiguous = true;
            return audioData;
          };
          return MP4Remuxer2;
        }();
        function normalizePts(value, reference) {
          var offset;
          if (reference === null) {
            return value;
          }
          if (reference < value) {
            offset = -8589934592;
          } else {
            offset = 8589934592;
          }
          while (Math.abs(value - reference) > 4294967296) {
            value += offset;
          }
          return value;
        }
        function findKeyframeIndex(samples) {
          for (var i = 0; i < samples.length; i++) {
            if (samples[i].key) {
              return i;
            }
          }
          return -1;
        }
        function flushTextTrackMetadataCueSamples(track, timeOffset, initPTS, initDTS) {
          var length = track.samples.length;
          if (!length) {
            return;
          }
          var inputTimeScale = track.inputTimeScale;
          for (var index = 0; index < length; index++) {
            var sample = track.samples[index];
            sample.pts = normalizePts(sample.pts - initPTS.baseTime * inputTimeScale / initPTS.timescale, timeOffset * inputTimeScale) / inputTimeScale;
            sample.dts = normalizePts(sample.dts - initDTS.baseTime * inputTimeScale / initDTS.timescale, timeOffset * inputTimeScale) / inputTimeScale;
          }
          var samples = track.samples;
          track.samples = [];
          return {
            samples
          };
        }
        function flushTextTrackUserdataCueSamples(track, timeOffset, initPTS) {
          var length = track.samples.length;
          if (!length) {
            return;
          }
          var inputTimeScale = track.inputTimeScale;
          for (var index = 0; index < length; index++) {
            var sample = track.samples[index];
            sample.pts = normalizePts(sample.pts - initPTS.baseTime * inputTimeScale / initPTS.timescale, timeOffset * inputTimeScale) / inputTimeScale;
          }
          track.samples.sort(function(a, b) {
            return a.pts - b.pts;
          });
          var samples = track.samples;
          track.samples = [];
          return {
            samples
          };
        }
        var PassThroughRemuxer = /* @__PURE__ */ function() {
          function PassThroughRemuxer2(observer, config, typeSupported, logger5) {
            this.logger = void 0;
            this.emitInitSegment = false;
            this.audioCodec = void 0;
            this.videoCodec = void 0;
            this.initData = void 0;
            this.initPTS = null;
            this.initTracks = void 0;
            this.lastEndTime = null;
            this.logger = logger5;
          }
          var _proto = PassThroughRemuxer2.prototype;
          _proto.destroy = function destroy() {
          };
          _proto.resetTimeStamp = function resetTimeStamp(defaultInitPTS) {
            this.initPTS = defaultInitPTS;
            this.lastEndTime = null;
          };
          _proto.resetNextTimestamp = function resetNextTimestamp() {
            this.lastEndTime = null;
          };
          _proto.resetInitSegment = function resetInitSegment(initSegment, audioCodec, videoCodec, decryptdata) {
            this.audioCodec = audioCodec;
            this.videoCodec = videoCodec;
            this.generateInitSegment(patchEncyptionData(initSegment, decryptdata));
            this.emitInitSegment = true;
          };
          _proto.generateInitSegment = function generateInitSegment(initSegment) {
            var audioCodec = this.audioCodec, videoCodec = this.videoCodec;
            if (!(initSegment != null && initSegment.byteLength)) {
              this.initTracks = void 0;
              this.initData = void 0;
              return;
            }
            var initData = this.initData = parseInitSegment(initSegment);
            if (initData.audio) {
              audioCodec = getParsedTrackCodec(initData.audio, ElementaryStreamTypes.AUDIO);
            }
            if (initData.video) {
              videoCodec = getParsedTrackCodec(initData.video, ElementaryStreamTypes.VIDEO);
            }
            var tracks = {};
            if (initData.audio && initData.video) {
              tracks.audiovideo = {
                container: "video/mp4",
                codec: audioCodec + "," + videoCodec,
                supplemental: initData.video.supplemental,
                initSegment,
                id: "main"
              };
            } else if (initData.audio) {
              tracks.audio = {
                container: "audio/mp4",
                codec: audioCodec,
                initSegment,
                id: "audio"
              };
            } else if (initData.video) {
              tracks.video = {
                container: "video/mp4",
                codec: videoCodec,
                supplemental: initData.video.supplemental,
                initSegment,
                id: "main"
              };
            } else {
              this.logger.warn("[passthrough-remuxer.ts]: initSegment does not contain moov or trak boxes.");
            }
            this.initTracks = tracks;
          };
          _proto.remux = function remux(audioTrack, videoTrack, id3Track, textTrack, timeOffset, accurateTimeOffset) {
            var _initData, _initData2;
            var initPTS = this.initPTS, lastEndTime = this.lastEndTime;
            var result = {
              audio: void 0,
              video: void 0,
              text: textTrack,
              id3: id3Track,
              initSegment: void 0
            };
            if (!isFiniteNumber(lastEndTime)) {
              lastEndTime = this.lastEndTime = timeOffset || 0;
            }
            var data = videoTrack.samples;
            if (!(data != null && data.length)) {
              return result;
            }
            var initSegment = {
              initPTS: void 0,
              timescale: 1
            };
            var initData = this.initData;
            if (!((_initData = initData) != null && _initData.length)) {
              this.generateInitSegment(data);
              initData = this.initData;
            }
            if (!((_initData2 = initData) != null && _initData2.length)) {
              this.logger.warn("[passthrough-remuxer.ts]: Failed to generate initSegment.");
              return result;
            }
            if (this.emitInitSegment) {
              initSegment.tracks = this.initTracks;
              this.emitInitSegment = false;
            }
            var duration = getDuration(data, initData);
            var startDTS = getStartDTS(initData, data);
            var decodeTime = startDTS === null ? timeOffset : startDTS;
            if ((accurateTimeOffset || !initPTS) && (isInvalidInitPts(initPTS, decodeTime, timeOffset, duration) || initSegment.timescale !== initPTS.timescale)) {
              initSegment.initPTS = decodeTime - timeOffset;
              if (initPTS && initPTS.timescale === 1) {
                this.logger.warn("Adjusting initPTS @" + timeOffset + " from " + initPTS.baseTime / initPTS.timescale + " to " + initSegment.initPTS);
              }
              this.initPTS = initPTS = {
                baseTime: initSegment.initPTS,
                timescale: 1
              };
            }
            var startTime = audioTrack ? decodeTime - initPTS.baseTime / initPTS.timescale : lastEndTime;
            var endTime = startTime + duration;
            offsetStartDTS(initData, data, initPTS.baseTime / initPTS.timescale);
            if (duration > 0) {
              this.lastEndTime = endTime;
            } else {
              this.logger.warn("Duration parsed from mp4 should be greater than zero");
              this.resetNextTimestamp();
            }
            var hasAudio = !!initData.audio;
            var hasVideo = !!initData.video;
            var type = "";
            if (hasAudio) {
              type += "audio";
            }
            if (hasVideo) {
              type += "video";
            }
            var track = {
              data1: data,
              startPTS: startTime,
              startDTS: startTime,
              endPTS: endTime,
              endDTS: endTime,
              type,
              hasAudio,
              hasVideo,
              nb: 1,
              dropped: 0
            };
            result.audio = track.type === "audio" ? track : void 0;
            result.video = track.type !== "audio" ? track : void 0;
            result.initSegment = initSegment;
            result.id3 = flushTextTrackMetadataCueSamples(id3Track, timeOffset, initPTS, initPTS);
            if (textTrack.samples.length) {
              result.text = flushTextTrackUserdataCueSamples(textTrack, timeOffset, initPTS);
            }
            return result;
          };
          return PassThroughRemuxer2;
        }();
        function isInvalidInitPts(initPTS, startDTS, timeOffset, duration) {
          if (initPTS === null) {
            return true;
          }
          var minDuration = Math.max(duration, 1);
          var startTime = startDTS - initPTS.baseTime / initPTS.timescale;
          return Math.abs(startTime - timeOffset) > minDuration;
        }
        function getParsedTrackCodec(track, type) {
          var parsedCodec = track == null ? void 0 : track.codec;
          if (parsedCodec && parsedCodec.length > 4) {
            return parsedCodec;
          }
          if (type === ElementaryStreamTypes.AUDIO) {
            if (parsedCodec === "ec-3" || parsedCodec === "ac-3" || parsedCodec === "alac") {
              return parsedCodec;
            }
            if (parsedCodec === "fLaC" || parsedCodec === "Opus") {
              var preferManagedMediaSource = false;
              return getCodecCompatibleName(parsedCodec, preferManagedMediaSource);
            }
            logger4.warn('Unhandled audio codec "' + parsedCodec + '" in mp4 MAP');
            return parsedCodec || "mp4a";
          }
          logger4.warn('Unhandled video codec "' + parsedCodec + '" in mp4 MAP');
          return parsedCodec || "avc1";
        }
        var now;
        try {
          now = self.performance.now.bind(self.performance);
        } catch (err) {
          now = Date.now;
        }
        var muxConfig = [{
          demux: MP4Demuxer,
          remux: PassThroughRemuxer
        }, {
          demux: TSDemuxer,
          remux: MP4Remuxer
        }, {
          demux: AACDemuxer,
          remux: MP4Remuxer
        }, {
          demux: MP3Demuxer,
          remux: MP4Remuxer
        }];
        var Transmuxer = /* @__PURE__ */ function() {
          function Transmuxer2(observer, typeSupported, config, vendor, id, logger5) {
            this.asyncResult = false;
            this.logger = void 0;
            this.observer = void 0;
            this.typeSupported = void 0;
            this.config = void 0;
            this.id = void 0;
            this.demuxer = void 0;
            this.remuxer = void 0;
            this.decrypter = void 0;
            this.probe = void 0;
            this.decryptionPromise = null;
            this.transmuxConfig = void 0;
            this.currentTransmuxState = void 0;
            this.observer = observer;
            this.typeSupported = typeSupported;
            this.config = config;
            this.id = id;
            this.logger = logger5;
          }
          var _proto = Transmuxer2.prototype;
          _proto.configure = function configure(transmuxConfig) {
            this.transmuxConfig = transmuxConfig;
            if (this.decrypter) {
              this.decrypter.reset();
            }
          };
          _proto.push = function push2(data, decryptdata, chunkMeta, state) {
            var _this = this;
            var stats = chunkMeta.transmuxing;
            stats.executeStart = now();
            var uintData = new Uint8Array(data);
            var currentTransmuxState = this.currentTransmuxState, transmuxConfig = this.transmuxConfig;
            if (state) {
              this.currentTransmuxState = state;
            }
            var _ref = state || currentTransmuxState, contiguous = _ref.contiguous, discontinuity = _ref.discontinuity, trackSwitch = _ref.trackSwitch, accurateTimeOffset = _ref.accurateTimeOffset, timeOffset = _ref.timeOffset, initSegmentChange = _ref.initSegmentChange;
            var audioCodec = transmuxConfig.audioCodec, videoCodec = transmuxConfig.videoCodec, defaultInitPts = transmuxConfig.defaultInitPts, duration = transmuxConfig.duration, initSegmentData = transmuxConfig.initSegmentData;
            var keyData = getEncryptionType(uintData, decryptdata);
            if (keyData && isFullSegmentEncryption(keyData.method)) {
              var decrypter = this.getDecrypter();
              var aesMode = getAesModeFromFullSegmentMethod(keyData.method);
              if (decrypter.isSync()) {
                var decryptedData = decrypter.softwareDecrypt(uintData, keyData.key.buffer, keyData.iv.buffer, aesMode);
                var loadingParts = chunkMeta.part > -1;
                if (loadingParts) {
                  var _data = decrypter.flush();
                  decryptedData = _data ? _data.buffer : _data;
                }
                if (!decryptedData) {
                  stats.executeEnd = now();
                  return emptyResult(chunkMeta);
                }
                uintData = new Uint8Array(decryptedData);
              } else {
                this.asyncResult = true;
                this.decryptionPromise = decrypter.webCryptoDecrypt(uintData, keyData.key.buffer, keyData.iv.buffer, aesMode).then(function(decryptedData2) {
                  var result2 = _this.push(decryptedData2, null, chunkMeta);
                  _this.decryptionPromise = null;
                  return result2;
                });
                return this.decryptionPromise;
              }
            }
            var resetMuxers = this.needsProbing(discontinuity, trackSwitch);
            if (resetMuxers) {
              var error = this.configureTransmuxer(uintData);
              if (error) {
                this.logger.warn("[transmuxer] " + error.message);
                this.observer.emit(Events.ERROR, Events.ERROR, {
                  type: ErrorTypes.MEDIA_ERROR,
                  details: ErrorDetails.FRAG_PARSING_ERROR,
                  fatal: false,
                  error,
                  reason: error.message
                });
                stats.executeEnd = now();
                return emptyResult(chunkMeta);
              }
            }
            if (discontinuity || trackSwitch || initSegmentChange || resetMuxers) {
              this.resetInitSegment(initSegmentData, audioCodec, videoCodec, duration, decryptdata);
            }
            if (discontinuity || initSegmentChange || resetMuxers) {
              this.resetInitialTimestamp(defaultInitPts);
            }
            if (!contiguous) {
              this.resetContiguity();
            }
            var result = this.transmux(uintData, keyData, timeOffset, accurateTimeOffset, chunkMeta);
            this.asyncResult = isPromise(result);
            var currentState = this.currentTransmuxState;
            currentState.contiguous = true;
            currentState.discontinuity = false;
            currentState.trackSwitch = false;
            stats.executeEnd = now();
            return result;
          };
          _proto.flush = function flush(chunkMeta) {
            var _this2 = this;
            var stats = chunkMeta.transmuxing;
            stats.executeStart = now();
            var decrypter = this.decrypter, currentTransmuxState = this.currentTransmuxState, decryptionPromise = this.decryptionPromise;
            if (decryptionPromise) {
              this.asyncResult = true;
              return decryptionPromise.then(function() {
                return _this2.flush(chunkMeta);
              });
            }
            var transmuxResults = [];
            var timeOffset = currentTransmuxState.timeOffset;
            if (decrypter) {
              var decryptedData = decrypter.flush();
              if (decryptedData) {
                transmuxResults.push(this.push(decryptedData.buffer, null, chunkMeta));
              }
            }
            var demuxer = this.demuxer, remuxer = this.remuxer;
            if (!demuxer || !remuxer) {
              stats.executeEnd = now();
              var emptyResults = [emptyResult(chunkMeta)];
              if (this.asyncResult) {
                return Promise.resolve(emptyResults);
              }
              return emptyResults;
            }
            var demuxResultOrPromise = demuxer.flush(timeOffset);
            if (isPromise(demuxResultOrPromise)) {
              this.asyncResult = true;
              return demuxResultOrPromise.then(function(demuxResult) {
                _this2.flushRemux(transmuxResults, demuxResult, chunkMeta);
                return transmuxResults;
              });
            }
            this.flushRemux(transmuxResults, demuxResultOrPromise, chunkMeta);
            if (this.asyncResult) {
              return Promise.resolve(transmuxResults);
            }
            return transmuxResults;
          };
          _proto.flushRemux = function flushRemux(transmuxResults, demuxResult, chunkMeta) {
            var audioTrack = demuxResult.audioTrack, videoTrack = demuxResult.videoTrack, id3Track = demuxResult.id3Track, textTrack = demuxResult.textTrack;
            var _this$currentTransmux = this.currentTransmuxState, accurateTimeOffset = _this$currentTransmux.accurateTimeOffset, timeOffset = _this$currentTransmux.timeOffset;
            this.logger.log("[transmuxer.ts]: Flushed " + this.id + " sn: " + chunkMeta.sn + (chunkMeta.part > -1 ? " part: " + chunkMeta.part : "") + " of " + (this.id === PlaylistLevelType.MAIN ? "level" : "track") + " " + chunkMeta.level);
            var remuxResult = this.remuxer.remux(audioTrack, videoTrack, id3Track, textTrack, timeOffset, accurateTimeOffset, true, this.id);
            transmuxResults.push({
              remuxResult,
              chunkMeta
            });
            chunkMeta.transmuxing.executeEnd = now();
          };
          _proto.resetInitialTimestamp = function resetInitialTimestamp(defaultInitPts) {
            var demuxer = this.demuxer, remuxer = this.remuxer;
            if (!demuxer || !remuxer) {
              return;
            }
            demuxer.resetTimeStamp(defaultInitPts);
            remuxer.resetTimeStamp(defaultInitPts);
          };
          _proto.resetContiguity = function resetContiguity() {
            var demuxer = this.demuxer, remuxer = this.remuxer;
            if (!demuxer || !remuxer) {
              return;
            }
            demuxer.resetContiguity();
            remuxer.resetNextTimestamp();
          };
          _proto.resetInitSegment = function resetInitSegment(initSegmentData, audioCodec, videoCodec, trackDuration, decryptdata) {
            var demuxer = this.demuxer, remuxer = this.remuxer;
            if (!demuxer || !remuxer) {
              return;
            }
            demuxer.resetInitSegment(initSegmentData, audioCodec, videoCodec, trackDuration);
            remuxer.resetInitSegment(initSegmentData, audioCodec, videoCodec, decryptdata);
          };
          _proto.destroy = function destroy() {
            if (this.demuxer) {
              this.demuxer.destroy();
              this.demuxer = void 0;
            }
            if (this.remuxer) {
              this.remuxer.destroy();
              this.remuxer = void 0;
            }
          };
          _proto.transmux = function transmux(data, keyData, timeOffset, accurateTimeOffset, chunkMeta) {
            var result;
            if (keyData && keyData.method === "SAMPLE-AES") {
              result = this.transmuxSampleAes(data, keyData, timeOffset, accurateTimeOffset, chunkMeta);
            } else {
              result = this.transmuxUnencrypted(data, timeOffset, accurateTimeOffset, chunkMeta);
            }
            return result;
          };
          _proto.transmuxUnencrypted = function transmuxUnencrypted(data, timeOffset, accurateTimeOffset, chunkMeta) {
            var _demux = this.demuxer.demux(data, timeOffset, false, !this.config.progressive), audioTrack = _demux.audioTrack, videoTrack = _demux.videoTrack, id3Track = _demux.id3Track, textTrack = _demux.textTrack;
            var remuxResult = this.remuxer.remux(audioTrack, videoTrack, id3Track, textTrack, timeOffset, accurateTimeOffset, false, this.id);
            return {
              remuxResult,
              chunkMeta
            };
          };
          _proto.transmuxSampleAes = function transmuxSampleAes(data, decryptData, timeOffset, accurateTimeOffset, chunkMeta) {
            var _this3 = this;
            return this.demuxer.demuxSampleAes(data, decryptData, timeOffset).then(function(demuxResult) {
              var remuxResult = _this3.remuxer.remux(demuxResult.audioTrack, demuxResult.videoTrack, demuxResult.id3Track, demuxResult.textTrack, timeOffset, accurateTimeOffset, false, _this3.id);
              return {
                remuxResult,
                chunkMeta
              };
            });
          };
          _proto.configureTransmuxer = function configureTransmuxer(data) {
            var config = this.config, observer = this.observer, typeSupported = this.typeSupported;
            var mux;
            for (var i = 0, len = muxConfig.length; i < len; i++) {
              var _muxConfig$i$demux;
              if ((_muxConfig$i$demux = muxConfig[i].demux) != null && _muxConfig$i$demux.probe(data, this.logger)) {
                mux = muxConfig[i];
                break;
              }
            }
            if (!mux) {
              return new Error("Failed to find demuxer by probing fragment data");
            }
            var demuxer = this.demuxer;
            var remuxer = this.remuxer;
            var Remuxer = mux.remux;
            var Demuxer = mux.demux;
            if (!remuxer || !(remuxer instanceof Remuxer)) {
              this.remuxer = new Remuxer(observer, config, typeSupported, this.logger);
            }
            if (!demuxer || !(demuxer instanceof Demuxer)) {
              this.demuxer = new Demuxer(observer, config, typeSupported, this.logger);
              this.probe = Demuxer.probe;
            }
          };
          _proto.needsProbing = function needsProbing(discontinuity, trackSwitch) {
            return !this.demuxer || !this.remuxer || discontinuity || trackSwitch;
          };
          _proto.getDecrypter = function getDecrypter() {
            var decrypter = this.decrypter;
            if (!decrypter) {
              decrypter = this.decrypter = new Decrypter(this.config);
            }
            return decrypter;
          };
          return Transmuxer2;
        }();
        function getEncryptionType(data, decryptData) {
          var encryptionType = null;
          if (data.byteLength > 0 && (decryptData == null ? void 0 : decryptData.key) != null && decryptData.iv !== null && decryptData.method != null) {
            encryptionType = decryptData;
          }
          return encryptionType;
        }
        var emptyResult = function emptyResult2(chunkMeta) {
          return {
            remuxResult: {},
            chunkMeta
          };
        };
        function isPromise(p) {
          return "then" in p && p.then instanceof Function;
        }
        var TransmuxConfig = function TransmuxConfig2(audioCodec, videoCodec, initSegmentData, duration, defaultInitPts) {
          this.audioCodec = void 0;
          this.videoCodec = void 0;
          this.initSegmentData = void 0;
          this.duration = void 0;
          this.defaultInitPts = void 0;
          this.audioCodec = audioCodec;
          this.videoCodec = videoCodec;
          this.initSegmentData = initSegmentData;
          this.duration = duration;
          this.defaultInitPts = defaultInitPts || null;
        };
        var TransmuxState = function TransmuxState2(discontinuity, contiguous, accurateTimeOffset, trackSwitch, timeOffset, initSegmentChange) {
          this.discontinuity = void 0;
          this.contiguous = void 0;
          this.accurateTimeOffset = void 0;
          this.trackSwitch = void 0;
          this.timeOffset = void 0;
          this.initSegmentChange = void 0;
          this.discontinuity = discontinuity;
          this.contiguous = contiguous;
          this.accurateTimeOffset = accurateTimeOffset;
          this.trackSwitch = trackSwitch;
          this.timeOffset = timeOffset;
          this.initSegmentChange = initSegmentChange;
        };
        function fetchSupported() {
          if (
            // @ts-ignore
            self.fetch && self.AbortController && self.ReadableStream && self.Request
          ) {
            try {
              new self.ReadableStream({});
              return true;
            } catch (e) {
            }
          }
          return false;
        }
        var BYTERANGE = /(\d+)-(\d+)\/(\d+)/;
        var FetchLoader2 = /* @__PURE__ */ function() {
          function FetchLoader3(config) {
            this.fetchSetup = void 0;
            this.requestTimeout = void 0;
            this.request = null;
            this.response = null;
            this.controller = void 0;
            this.context = null;
            this.config = null;
            this.callbacks = null;
            this.stats = void 0;
            this.loader = null;
            this.fetchSetup = config.fetchSetup || getRequest;
            this.controller = new self.AbortController();
            this.stats = new LoadStats();
          }
          var _proto = FetchLoader3.prototype;
          _proto.destroy = function destroy() {
            this.loader = this.callbacks = this.context = this.config = this.request = null;
            this.abortInternal();
            this.response = null;
            this.fetchSetup = this.controller = this.stats = null;
          };
          _proto.abortInternal = function abortInternal() {
            if (this.controller && !this.stats.loading.end) {
              this.stats.aborted = true;
              this.controller.abort();
            }
          };
          _proto.abort = function abort() {
            var _this$callbacks;
            this.abortInternal();
            if ((_this$callbacks = this.callbacks) != null && _this$callbacks.onAbort) {
              this.callbacks.onAbort(this.stats, this.context, this.response);
            }
          };
          _proto.load = function load(context, config, callbacks) {
            var _this = this;
            var stats = this.stats;
            if (stats.loading.start) {
              throw new Error("Loader can only be used once.");
            }
            stats.loading.start = self.performance.now();
            var initParams = getRequestParameters(context, this.controller.signal);
            var isArrayBuffer = context.responseType === "arraybuffer";
            var LENGTH = isArrayBuffer ? "byteLength" : "length";
            var _config$loadPolicy = config.loadPolicy, maxTimeToFirstByteMs = _config$loadPolicy.maxTimeToFirstByteMs, maxLoadTimeMs = _config$loadPolicy.maxLoadTimeMs;
            this.context = context;
            this.config = config;
            this.callbacks = callbacks;
            this.request = this.fetchSetup(context, initParams);
            self.clearTimeout(this.requestTimeout);
            config.timeout = maxTimeToFirstByteMs && isFiniteNumber(maxTimeToFirstByteMs) ? maxTimeToFirstByteMs : maxLoadTimeMs;
            this.requestTimeout = self.setTimeout(function() {
              if (_this.callbacks) {
                _this.abortInternal();
                _this.callbacks.onTimeout(stats, context, _this.response);
              }
            }, config.timeout);
            var fetchPromise = isPromise(this.request) ? this.request.then(self.fetch) : self.fetch(this.request);
            fetchPromise.then(function(response) {
              var _this$callbacks2;
              _this.response = _this.loader = response;
              var first = Math.max(self.performance.now(), stats.loading.start);
              self.clearTimeout(_this.requestTimeout);
              config.timeout = maxLoadTimeMs;
              _this.requestTimeout = self.setTimeout(function() {
                if (_this.callbacks) {
                  _this.abortInternal();
                  _this.callbacks.onTimeout(stats, context, _this.response);
                }
              }, maxLoadTimeMs - (first - stats.loading.start));
              if (!response.ok) {
                var status2 = response.status, statusText = response.statusText;
                throw new FetchError(statusText || "fetch, bad network response", status2, response);
              }
              stats.loading.first = first;
              stats.total = getContentLength(response.headers) || stats.total;
              var onProgress = (_this$callbacks2 = _this.callbacks) == null ? void 0 : _this$callbacks2.onProgress;
              if (onProgress && isFiniteNumber(config.highWaterMark)) {
                return _this.loadProgressively(response, stats, context, config.highWaterMark, onProgress);
              }
              if (isArrayBuffer) {
                return response.arrayBuffer();
              }
              if (context.responseType === "json") {
                return response.json();
              }
              return response.text();
            }).then(function(responseData) {
              var _this$callbacks3, _this$callbacks4;
              var response = _this.response;
              if (!response) {
                throw new Error("loader destroyed");
              }
              self.clearTimeout(_this.requestTimeout);
              stats.loading.end = Math.max(self.performance.now(), stats.loading.first);
              var total = responseData[LENGTH];
              if (total) {
                stats.loaded = stats.total = total;
              }
              var loaderResponse = {
                url: response.url,
                data: responseData,
                code: response.status
              };
              var onProgress = (_this$callbacks3 = _this.callbacks) == null ? void 0 : _this$callbacks3.onProgress;
              if (onProgress && !isFiniteNumber(config.highWaterMark)) {
                onProgress(stats, context, responseData, response);
              }
              (_this$callbacks4 = _this.callbacks) == null ? void 0 : _this$callbacks4.onSuccess(loaderResponse, stats, context, response);
            }).catch(function(error) {
              var _this$callbacks5;
              self.clearTimeout(_this.requestTimeout);
              if (stats.aborted) {
                return;
              }
              var code = !error ? 0 : error.code || 0;
              var text = !error ? null : error.message;
              (_this$callbacks5 = _this.callbacks) == null ? void 0 : _this$callbacks5.onError({
                code,
                text
              }, context, error ? error.details : null, stats);
            });
          };
          _proto.getCacheAge = function getCacheAge() {
            var result = null;
            if (this.response) {
              var ageHeader = this.response.headers.get("age");
              result = ageHeader ? parseFloat(ageHeader) : null;
            }
            return result;
          };
          _proto.getResponseHeader = function getResponseHeader(name) {
            return this.response ? this.response.headers.get(name) : null;
          };
          _proto.loadProgressively = function loadProgressively(response, stats, context, highWaterMark, onProgress) {
            if (highWaterMark === void 0) {
              highWaterMark = 0;
            }
            var chunkCache = new ChunkCache();
            var reader = response.body.getReader();
            var _pump = function pump() {
              return reader.read().then(function(data) {
                if (data.done) {
                  if (chunkCache.dataLength) {
                    onProgress(stats, context, chunkCache.flush().buffer, response);
                  }
                  return Promise.resolve(new ArrayBuffer(0));
                }
                var chunk = data.value;
                var len = chunk.length;
                stats.loaded += len;
                if (len < highWaterMark || chunkCache.dataLength) {
                  chunkCache.push(chunk);
                  if (chunkCache.dataLength >= highWaterMark) {
                    onProgress(stats, context, chunkCache.flush().buffer, response);
                  }
                } else {
                  onProgress(stats, context, chunk.buffer, response);
                }
                return _pump();
              }).catch(function() {
                return Promise.reject();
              });
            };
            return _pump();
          };
          return FetchLoader3;
        }();
        function getRequestParameters(context, signal) {
          var initParams = {
            method: "GET",
            mode: "cors",
            credentials: "same-origin",
            signal,
            headers: new self.Headers(_extends({}, context.headers))
          };
          if (context.rangeEnd) {
            initParams.headers.set("Range", "bytes=" + context.rangeStart + "-" + String(context.rangeEnd - 1));
          }
          return initParams;
        }
        function getByteRangeLength(byteRangeHeader) {
          var result = BYTERANGE.exec(byteRangeHeader);
          if (result) {
            return parseInt(result[2]) - parseInt(result[1]) + 1;
          }
        }
        function getContentLength(headers) {
          var contentRange = headers.get("Content-Range");
          if (contentRange) {
            var byteRangeLength = getByteRangeLength(contentRange);
            if (isFiniteNumber(byteRangeLength)) {
              return byteRangeLength;
            }
          }
          var contentLength = headers.get("Content-Length");
          if (contentLength) {
            return parseInt(contentLength);
          }
        }
        function getRequest(context, initParams) {
          return new self.Request(context.url, initParams);
        }
        var FetchError = /* @__PURE__ */ function(_Error) {
          function FetchError2(message, code, details) {
            var _this2;
            _this2 = _Error.call(this, message) || this;
            _this2.code = void 0;
            _this2.details = void 0;
            _this2.code = code;
            _this2.details = details;
            return _this2;
          }
          _inheritsLoose(FetchError2, _Error);
          return FetchError2;
        }(/* @__PURE__ */ _wrapNativeSuper2(Error));
        var AGE_HEADER_LINE_REGEX = /^age:\s*[\d.]+\s*$/im;
        var XhrLoader2 = /* @__PURE__ */ function() {
          function XhrLoader3(config) {
            this.xhrSetup = void 0;
            this.requestTimeout = void 0;
            this.retryTimeout = void 0;
            this.retryDelay = void 0;
            this.config = null;
            this.callbacks = null;
            this.context = null;
            this.loader = null;
            this.stats = void 0;
            this.xhrSetup = config ? config.xhrSetup || null : null;
            this.stats = new LoadStats();
            this.retryDelay = 0;
          }
          var _proto = XhrLoader3.prototype;
          _proto.destroy = function destroy() {
            this.callbacks = null;
            this.abortInternal();
            this.loader = null;
            this.config = null;
            this.context = null;
            this.xhrSetup = null;
          };
          _proto.abortInternal = function abortInternal() {
            var loader = this.loader;
            self.clearTimeout(this.requestTimeout);
            self.clearTimeout(this.retryTimeout);
            if (loader) {
              loader.onreadystatechange = null;
              loader.onprogress = null;
              if (loader.readyState !== 4) {
                this.stats.aborted = true;
                loader.abort();
              }
            }
          };
          _proto.abort = function abort() {
            var _this$callbacks;
            this.abortInternal();
            if ((_this$callbacks = this.callbacks) != null && _this$callbacks.onAbort) {
              this.callbacks.onAbort(this.stats, this.context, this.loader);
            }
          };
          _proto.load = function load(context, config, callbacks) {
            if (this.stats.loading.start) {
              throw new Error("Loader can only be used once.");
            }
            this.stats.loading.start = self.performance.now();
            this.context = context;
            this.config = config;
            this.callbacks = callbacks;
            this.loadInternal();
          };
          _proto.loadInternal = function loadInternal() {
            var _this = this;
            var config = this.config, context = this.context;
            if (!config || !context) {
              return;
            }
            var xhr = this.loader = new self.XMLHttpRequest();
            var stats = this.stats;
            stats.loading.first = 0;
            stats.loaded = 0;
            stats.aborted = false;
            var xhrSetup = this.xhrSetup;
            if (xhrSetup) {
              Promise.resolve().then(function() {
                if (_this.loader !== xhr || _this.stats.aborted) return;
                return xhrSetup(xhr, context.url);
              }).catch(function(error) {
                if (_this.loader !== xhr || _this.stats.aborted) return;
                xhr.open("GET", context.url, true);
                return xhrSetup(xhr, context.url);
              }).then(function() {
                if (_this.loader !== xhr || _this.stats.aborted) return;
                _this.openAndSendXhr(xhr, context, config);
              }).catch(function(error) {
                var _this$callbacks2;
                (_this$callbacks2 = _this.callbacks) == null ? void 0 : _this$callbacks2.onError({
                  code: xhr.status,
                  text: error.message
                }, context, xhr, stats);
                return;
              });
            } else {
              this.openAndSendXhr(xhr, context, config);
            }
          };
          _proto.openAndSendXhr = function openAndSendXhr(xhr, context, config) {
            if (!xhr.readyState) {
              xhr.open("GET", context.url, true);
            }
            var headers = context.headers;
            var _config$loadPolicy = config.loadPolicy, maxTimeToFirstByteMs = _config$loadPolicy.maxTimeToFirstByteMs, maxLoadTimeMs = _config$loadPolicy.maxLoadTimeMs;
            if (headers) {
              for (var header in headers) {
                xhr.setRequestHeader(header, headers[header]);
              }
            }
            if (context.rangeEnd) {
              xhr.setRequestHeader("Range", "bytes=" + context.rangeStart + "-" + (context.rangeEnd - 1));
            }
            xhr.onreadystatechange = this.readystatechange.bind(this);
            xhr.onprogress = this.loadprogress.bind(this);
            xhr.responseType = context.responseType;
            self.clearTimeout(this.requestTimeout);
            config.timeout = maxTimeToFirstByteMs && isFiniteNumber(maxTimeToFirstByteMs) ? maxTimeToFirstByteMs : maxLoadTimeMs;
            this.requestTimeout = self.setTimeout(this.loadtimeout.bind(this), config.timeout);
            xhr.send();
          };
          _proto.readystatechange = function readystatechange() {
            var context = this.context, xhr = this.loader, stats = this.stats;
            if (!context || !xhr) {
              return;
            }
            var readyState = xhr.readyState;
            var config = this.config;
            if (stats.aborted) {
              return;
            }
            if (readyState >= 2) {
              if (stats.loading.first === 0) {
                stats.loading.first = Math.max(self.performance.now(), stats.loading.start);
                if (config.timeout !== config.loadPolicy.maxLoadTimeMs) {
                  self.clearTimeout(this.requestTimeout);
                  config.timeout = config.loadPolicy.maxLoadTimeMs;
                  this.requestTimeout = self.setTimeout(this.loadtimeout.bind(this), config.loadPolicy.maxLoadTimeMs - (stats.loading.first - stats.loading.start));
                }
              }
              if (readyState === 4) {
                self.clearTimeout(this.requestTimeout);
                xhr.onreadystatechange = null;
                xhr.onprogress = null;
                var _status = xhr.status;
                var useResponseText = xhr.responseType === "text" ? xhr.responseText : null;
                if (_status >= 200 && _status < 300) {
                  var data = useResponseText != null ? useResponseText : xhr.response;
                  if (data != null) {
                    var _this$callbacks3, _this$callbacks4;
                    stats.loading.end = Math.max(self.performance.now(), stats.loading.first);
                    var len = xhr.responseType === "arraybuffer" ? data.byteLength : data.length;
                    stats.loaded = stats.total = len;
                    stats.bwEstimate = stats.total * 8e3 / (stats.loading.end - stats.loading.first);
                    var onProgress = (_this$callbacks3 = this.callbacks) == null ? void 0 : _this$callbacks3.onProgress;
                    if (onProgress) {
                      onProgress(stats, context, data, xhr);
                    }
                    var _response = {
                      url: xhr.responseURL,
                      data,
                      code: _status
                    };
                    (_this$callbacks4 = this.callbacks) == null ? void 0 : _this$callbacks4.onSuccess(_response, stats, context, xhr);
                    return;
                  }
                }
                var retryConfig = config.loadPolicy.errorRetry;
                var retryCount = stats.retry;
                var response = {
                  url: context.url,
                  data: void 0,
                  code: _status
                };
                if (shouldRetry(retryConfig, retryCount, false, response)) {
                  this.retry(retryConfig);
                } else {
                  var _this$callbacks5;
                  logger4.error(_status + " while loading " + context.url);
                  (_this$callbacks5 = this.callbacks) == null ? void 0 : _this$callbacks5.onError({
                    code: _status,
                    text: xhr.statusText
                  }, context, xhr, stats);
                }
              }
            }
          };
          _proto.loadtimeout = function loadtimeout() {
            if (!this.config) return;
            var retryConfig = this.config.loadPolicy.timeoutRetry;
            var retryCount = this.stats.retry;
            if (shouldRetry(retryConfig, retryCount, true)) {
              this.retry(retryConfig);
            } else {
              var _this$context;
              logger4.warn("timeout while loading " + ((_this$context = this.context) == null ? void 0 : _this$context.url));
              var callbacks = this.callbacks;
              if (callbacks) {
                this.abortInternal();
                callbacks.onTimeout(this.stats, this.context, this.loader);
              }
            }
          };
          _proto.retry = function retry(retryConfig) {
            var context = this.context, stats = this.stats;
            this.retryDelay = getRetryDelay(retryConfig, stats.retry);
            stats.retry++;
            logger4.warn((status ? "HTTP Status " + status : "Timeout") + " while loading " + (context == null ? void 0 : context.url) + ", retrying " + stats.retry + "/" + retryConfig.maxNumRetry + " in " + this.retryDelay + "ms");
            this.abortInternal();
            this.loader = null;
            self.clearTimeout(this.retryTimeout);
            this.retryTimeout = self.setTimeout(this.loadInternal.bind(this), this.retryDelay);
          };
          _proto.loadprogress = function loadprogress(event) {
            var stats = this.stats;
            stats.loaded = event.loaded;
            if (event.lengthComputable) {
              stats.total = event.total;
            }
          };
          _proto.getCacheAge = function getCacheAge() {
            var result = null;
            if (this.loader && AGE_HEADER_LINE_REGEX.test(this.loader.getAllResponseHeaders())) {
              var ageHeader = this.loader.getResponseHeader("age");
              result = ageHeader ? parseFloat(ageHeader) : null;
            }
            return result;
          };
          _proto.getResponseHeader = function getResponseHeader(name) {
            if (this.loader && new RegExp("^" + name + ":\\s*[\\d.]+\\s*$", "im").test(this.loader.getAllResponseHeaders())) {
              return this.loader.getResponseHeader(name);
            }
            return null;
          };
          return XhrLoader3;
        }();
        var defaultLoadPolicy = {
          maxTimeToFirstByteMs: 8e3,
          maxLoadTimeMs: 2e4,
          timeoutRetry: null,
          errorRetry: null
        };
        var hlsDefaultConfig = _objectSpread23(_objectSpread23({
          autoStartLoad: true,
          // used by stream-controller
          startPosition: -1,
          // used by stream-controller
          defaultAudioCodec: void 0,
          // used by stream-controller
          debug: false,
          // used by logger
          capLevelOnFPSDrop: false,
          // used by fps-controller
          capLevelToPlayerSize: false,
          // used by cap-level-controller
          ignoreDevicePixelRatio: false,
          // used by cap-level-controller
          maxDevicePixelRatio: Number.POSITIVE_INFINITY,
          // used by cap-level-controller
          preferManagedMediaSource: true,
          initialLiveManifestSize: 1,
          // used by stream-controller
          maxBufferLength: 30,
          // used by stream-controller
          backBufferLength: Infinity,
          // used by buffer-controller
          frontBufferFlushThreshold: Infinity,
          maxBufferSize: 60 * 1e3 * 1e3,
          // used by stream-controller
          maxFragLookUpTolerance: 0.25,
          // used by stream-controller
          maxBufferHole: 0.1,
          // used by stream-controller and gap-controller
          detectStallWithCurrentTimeMs: 1250,
          // used by gap-controller
          highBufferWatchdogPeriod: 2,
          // used by gap-controller
          nudgeOffset: 0.1,
          // used by gap-controller
          nudgeMaxRetry: 3,
          // used by gap-controller
          nudgeOnVideoHole: true,
          // used by gap-controller
          liveSyncDurationCount: 3,
          // used by latency-controller
          liveSyncOnStallIncrease: 1,
          // used by latency-controller
          liveMaxLatencyDurationCount: Infinity,
          // used by latency-controller
          liveSyncDuration: void 0,
          // used by latency-controller
          liveMaxLatencyDuration: void 0,
          // used by latency-controller
          maxLiveSyncPlaybackRate: 1,
          // used by latency-controller
          liveDurationInfinity: false,
          // used by buffer-controller
          /**
           * @deprecated use backBufferLength
           */
          liveBackBufferLength: null,
          // used by buffer-controller
          maxMaxBufferLength: 600,
          // used by stream-controller
          enableWorker: true,
          // used by transmuxer
          workerPath: null,
          // used by transmuxer
          enableSoftwareAES: true,
          // used by decrypter
          startLevel: void 0,
          // used by level-controller
          startFragPrefetch: false,
          // used by stream-controller
          fpsDroppedMonitoringPeriod: 5e3,
          // used by fps-controller
          fpsDroppedMonitoringThreshold: 0.2,
          // used by fps-controller
          appendErrorMaxRetry: 3,
          // used by buffer-controller
          ignorePlaylistParsingErrors: false,
          loader: XhrLoader2,
          // loader: FetchLoader,
          fLoader: void 0,
          // used by fragment-loader
          pLoader: void 0,
          // used by playlist-loader
          xhrSetup: void 0,
          // used by xhr-loader
          licenseXhrSetup: void 0,
          // used by eme-controller
          licenseResponseCallback: void 0,
          // used by eme-controller
          abrController: AbrController,
          bufferController: BufferController,
          capLevelController: CapLevelController,
          errorController: ErrorController,
          fpsController: FPSController,
          stretchShortVideoTrack: false,
          // used by mp4-remuxer
          maxAudioFramesDrift: 1,
          // used by mp4-remuxer
          forceKeyFrameOnDiscontinuity: true,
          // used by ts-demuxer
          abrEwmaFastLive: 3,
          // used by abr-controller
          abrEwmaSlowLive: 9,
          // used by abr-controller
          abrEwmaFastVoD: 3,
          // used by abr-controller
          abrEwmaSlowVoD: 9,
          // used by abr-controller
          abrEwmaDefaultEstimate: 5e5,
          // 500 kbps  // used by abr-controller
          abrEwmaDefaultEstimateMax: 5e6,
          // 5 mbps
          abrBandWidthFactor: 0.95,
          // used by abr-controller
          abrBandWidthUpFactor: 0.7,
          // used by abr-controller
          abrMaxWithRealBitrate: false,
          // used by abr-controller
          maxStarvationDelay: 4,
          // used by abr-controller
          maxLoadingDelay: 4,
          // used by abr-controller
          minAutoBitrate: 0,
          // used by hls
          emeEnabled: false,
          // used by eme-controller
          widevineLicenseUrl: void 0,
          // used by eme-controller
          drmSystems: {},
          // used by eme-controller
          drmSystemOptions: {},
          // used by eme-controller
          requestMediaKeySystemAccessFunc: null,
          // used by eme-controller
          testBandwidth: true,
          progressive: false,
          lowLatencyMode: true,
          cmcd: void 0,
          enableDateRangeMetadataCues: true,
          enableEmsgMetadataCues: true,
          enableEmsgKLVMetadata: false,
          enableID3MetadataCues: true,
          enableInterstitialPlayback: false,
          interstitialAppendInPlace: true,
          interstitialLiveLookAhead: 10,
          useMediaCapabilities: false,
          certLoadPolicy: {
            default: defaultLoadPolicy
          },
          keyLoadPolicy: {
            default: {
              maxTimeToFirstByteMs: 8e3,
              maxLoadTimeMs: 2e4,
              timeoutRetry: {
                maxNumRetry: 1,
                retryDelayMs: 1e3,
                maxRetryDelayMs: 2e4,
                backoff: "linear"
              },
              errorRetry: {
                maxNumRetry: 8,
                retryDelayMs: 1e3,
                maxRetryDelayMs: 2e4,
                backoff: "linear"
              }
            }
          },
          manifestLoadPolicy: {
            default: {
              maxTimeToFirstByteMs: Infinity,
              maxLoadTimeMs: 2e4,
              timeoutRetry: {
                maxNumRetry: 2,
                retryDelayMs: 0,
                maxRetryDelayMs: 0
              },
              errorRetry: {
                maxNumRetry: 1,
                retryDelayMs: 1e3,
                maxRetryDelayMs: 8e3
              }
            }
          },
          playlistLoadPolicy: {
            default: {
              maxTimeToFirstByteMs: 1e4,
              maxLoadTimeMs: 2e4,
              timeoutRetry: {
                maxNumRetry: 2,
                retryDelayMs: 0,
                maxRetryDelayMs: 0
              },
              errorRetry: {
                maxNumRetry: 2,
                retryDelayMs: 1e3,
                maxRetryDelayMs: 8e3
              }
            }
          },
          fragLoadPolicy: {
            default: {
              maxTimeToFirstByteMs: 1e4,
              maxLoadTimeMs: 12e4,
              timeoutRetry: {
                maxNumRetry: 4,
                retryDelayMs: 0,
                maxRetryDelayMs: 0
              },
              errorRetry: {
                maxNumRetry: 6,
                retryDelayMs: 1e3,
                maxRetryDelayMs: 8e3
              }
            }
          },
          steeringManifestLoadPolicy: {
            default: {
              maxTimeToFirstByteMs: 1e4,
              maxLoadTimeMs: 2e4,
              timeoutRetry: {
                maxNumRetry: 2,
                retryDelayMs: 0,
                maxRetryDelayMs: 0
              },
              errorRetry: {
                maxNumRetry: 1,
                retryDelayMs: 1e3,
                maxRetryDelayMs: 8e3
              }
            }
          },
          interstitialAssetListLoadPolicy: {
            default: defaultLoadPolicy
          },
          // These default settings are deprecated in favor of the above policies
          // and are maintained for backwards compatibility
          manifestLoadingTimeOut: 1e4,
          manifestLoadingMaxRetry: 1,
          manifestLoadingRetryDelay: 1e3,
          manifestLoadingMaxRetryTimeout: 64e3,
          levelLoadingTimeOut: 1e4,
          levelLoadingMaxRetry: 4,
          levelLoadingRetryDelay: 1e3,
          levelLoadingMaxRetryTimeout: 64e3,
          fragLoadingTimeOut: 2e4,
          fragLoadingMaxRetry: 6,
          fragLoadingRetryDelay: 1e3,
          fragLoadingMaxRetryTimeout: 64e3
        }, timelineConfig()), {}, {
          subtitleStreamController: void 0,
          subtitleTrackController: void 0,
          timelineController: void 0,
          audioStreamController: void 0,
          audioTrackController: void 0,
          emeController: void 0,
          cmcdController: void 0,
          contentSteeringController: ContentSteeringController,
          interstitialsController: void 0
        });
        function timelineConfig() {
          return {
            cueHandler: Cues,
            // used by timeline-controller
            enableWebVTT: false,
            // used by timeline-controller
            enableIMSC1: false,
            // used by timeline-controller
            enableCEA708Captions: false,
            // used by timeline-controller
            captionsTextTrack1Label: "English",
            // used by timeline-controller
            captionsTextTrack1LanguageCode: "en",
            // used by timeline-controller
            captionsTextTrack2Label: "Spanish",
            // used by timeline-controller
            captionsTextTrack2LanguageCode: "es",
            // used by timeline-controller
            captionsTextTrack3Label: "Unknown CC",
            // used by timeline-controller
            captionsTextTrack3LanguageCode: "",
            // used by timeline-controller
            captionsTextTrack4Label: "Unknown CC",
            // used by timeline-controller
            captionsTextTrack4LanguageCode: "",
            // used by timeline-controller
            renderTextTracksNatively: true
          };
        }
        function mergeConfig(defaultConfig, userConfig, logger5) {
          if ((userConfig.liveSyncDurationCount || userConfig.liveMaxLatencyDurationCount) && (userConfig.liveSyncDuration || userConfig.liveMaxLatencyDuration)) {
            throw new Error("Illegal hls.js config: don't mix up liveSyncDurationCount/liveMaxLatencyDurationCount and liveSyncDuration/liveMaxLatencyDuration");
          }
          if (userConfig.liveMaxLatencyDurationCount !== void 0 && (userConfig.liveSyncDurationCount === void 0 || userConfig.liveMaxLatencyDurationCount <= userConfig.liveSyncDurationCount)) {
            throw new Error('Illegal hls.js config: "liveMaxLatencyDurationCount" must be greater than "liveSyncDurationCount"');
          }
          if (userConfig.liveMaxLatencyDuration !== void 0 && (userConfig.liveSyncDuration === void 0 || userConfig.liveMaxLatencyDuration <= userConfig.liveSyncDuration)) {
            throw new Error('Illegal hls.js config: "liveMaxLatencyDuration" must be greater than "liveSyncDuration"');
          }
          var defaultsCopy = deepCpy(defaultConfig);
          var deprecatedSettingTypes = ["manifest", "level", "frag"];
          var deprecatedSettings = ["TimeOut", "MaxRetry", "RetryDelay", "MaxRetryTimeout"];
          deprecatedSettingTypes.forEach(function(type) {
            var policyName = (type === "level" ? "playlist" : type) + "LoadPolicy";
            var policyNotSet = userConfig[policyName] === void 0;
            var report = [];
            deprecatedSettings.forEach(function(setting) {
              var deprecatedSetting = type + "Loading" + setting;
              var value = userConfig[deprecatedSetting];
              if (value !== void 0 && policyNotSet) {
                report.push(deprecatedSetting);
                var settings = defaultsCopy[policyName].default;
                userConfig[policyName] = {
                  default: settings
                };
                switch (setting) {
                  case "TimeOut":
                    settings.maxLoadTimeMs = value;
                    settings.maxTimeToFirstByteMs = value;
                    break;
                  case "MaxRetry":
                    settings.errorRetry.maxNumRetry = value;
                    settings.timeoutRetry.maxNumRetry = value;
                    break;
                  case "RetryDelay":
                    settings.errorRetry.retryDelayMs = value;
                    settings.timeoutRetry.retryDelayMs = value;
                    break;
                  case "MaxRetryTimeout":
                    settings.errorRetry.maxRetryDelayMs = value;
                    settings.timeoutRetry.maxRetryDelayMs = value;
                    break;
                }
              }
            });
            if (report.length) {
              logger5.warn('hls.js config: "' + report.join('", "') + '" setting(s) are deprecated, use "' + policyName + '": ' + stringify2(userConfig[policyName]));
            }
          });
          return _objectSpread23(_objectSpread23({}, defaultsCopy), userConfig);
        }
        function deepCpy(obj) {
          if (obj && typeof obj === "object") {
            if (Array.isArray(obj)) {
              return obj.map(deepCpy);
            }
            return Object.keys(obj).reduce(function(result, key) {
              result[key] = deepCpy(obj[key]);
              return result;
            }, {});
          }
          return obj;
        }
        function enableStreamingMode(config, logger5) {
          var currentLoader = config.loader;
          if (currentLoader !== FetchLoader2 && currentLoader !== XhrLoader2) {
            logger5.log("[config]: Custom loader detected, cannot enable progressive streaming");
            config.progressive = false;
          } else {
            var canStreamProgressively = fetchSupported();
            if (canStreamProgressively) {
              config.loader = FetchLoader2;
              config.progressive = true;
              config.enableSoftwareAES = true;
              logger5.log("[config]: Progressive streaming enabled, using FetchLoader");
            }
          }
        }
        var FragmentState = {
          NOT_LOADED: "NOT_LOADED",
          APPENDING: "APPENDING",
          PARTIAL: "PARTIAL",
          OK: "OK"
        };
        var FragmentTracker = /* @__PURE__ */ function() {
          function FragmentTracker2(hls) {
            this.activePartLists = /* @__PURE__ */ Object.create(null);
            this.endListFragments = /* @__PURE__ */ Object.create(null);
            this.fragments = /* @__PURE__ */ Object.create(null);
            this.timeRanges = /* @__PURE__ */ Object.create(null);
            this.bufferPadding = 0.2;
            this.hls = void 0;
            this.hasGaps = false;
            this.hls = hls;
            this._registerListeners();
          }
          var _proto = FragmentTracker2.prototype;
          _proto._registerListeners = function _registerListeners() {
            var hls = this.hls;
            hls.on(Events.MANIFEST_LOADING, this.onManifestLoading, this);
            hls.on(Events.BUFFER_APPENDED, this.onBufferAppended, this);
            hls.on(Events.FRAG_BUFFERED, this.onFragBuffered, this);
            hls.on(Events.FRAG_LOADED, this.onFragLoaded, this);
          };
          _proto._unregisterListeners = function _unregisterListeners() {
            var hls = this.hls;
            hls.off(Events.MANIFEST_LOADING, this.onManifestLoading, this);
            hls.off(Events.BUFFER_APPENDED, this.onBufferAppended, this);
            hls.off(Events.FRAG_BUFFERED, this.onFragBuffered, this);
            hls.off(Events.FRAG_LOADED, this.onFragLoaded, this);
          };
          _proto.destroy = function destroy() {
            this._unregisterListeners();
            this.fragments = // @ts-ignore
            this.activePartLists = // @ts-ignore
            this.endListFragments = this.timeRanges = null;
          };
          _proto.getAppendedFrag = function getAppendedFrag(position, levelType) {
            var activeParts = this.activePartLists[levelType];
            if (activeParts) {
              for (var i = activeParts.length; i--; ) {
                var activePart = activeParts[i];
                if (!activePart) {
                  break;
                }
                var appendedPTS = activePart.end;
                if (activePart.start <= position && appendedPTS !== null && position <= appendedPTS) {
                  return activePart;
                }
              }
            }
            return this.getBufferedFrag(position, levelType);
          };
          _proto.getBufferedFrag = function getBufferedFrag(position, levelType) {
            return this.getFragAtPos(position, levelType, true);
          };
          _proto.getFragAtPos = function getFragAtPos(position, levelType, buffered) {
            var fragments = this.fragments;
            var keys = Object.keys(fragments);
            for (var i = keys.length; i--; ) {
              var fragmentEntity = fragments[keys[i]];
              if ((fragmentEntity == null ? void 0 : fragmentEntity.body.type) === levelType && (!buffered || fragmentEntity.buffered)) {
                var frag = fragmentEntity.body;
                if (frag.start <= position && position <= frag.end) {
                  return frag;
                }
              }
            }
            return null;
          };
          _proto.detectEvictedFragments = function detectEvictedFragments(elementaryStream, timeRange, playlistType, appendedPart, removeAppending) {
            var _this = this;
            if (this.timeRanges) {
              this.timeRanges[elementaryStream] = timeRange;
            }
            var appendedPartSn = (appendedPart == null ? void 0 : appendedPart.fragment.sn) || -1;
            Object.keys(this.fragments).forEach(function(key) {
              var fragmentEntity = _this.fragments[key];
              if (!fragmentEntity) {
                return;
              }
              if (appendedPartSn >= fragmentEntity.body.sn) {
                return;
              }
              if (!fragmentEntity.buffered && (!fragmentEntity.loaded || removeAppending)) {
                if (fragmentEntity.body.type === playlistType) {
                  _this.removeFragment(fragmentEntity.body);
                }
                return;
              }
              var esData = fragmentEntity.range[elementaryStream];
              if (!esData) {
                return;
              }
              if (esData.time.length === 0) {
                _this.removeFragment(fragmentEntity.body);
                return;
              }
              esData.time.some(function(time) {
                var isNotBuffered = !_this.isTimeBuffered(time.startPTS, time.endPTS, timeRange);
                if (isNotBuffered) {
                  _this.removeFragment(fragmentEntity.body);
                }
                return isNotBuffered;
              });
            });
          };
          _proto.detectPartialFragments = function detectPartialFragments(data) {
            var _this2 = this;
            var timeRanges = this.timeRanges;
            if (!timeRanges || data.frag.sn === "initSegment") {
              return;
            }
            var frag = data.frag;
            var fragKey = getFragmentKey(frag);
            var fragmentEntity = this.fragments[fragKey];
            if (!fragmentEntity || fragmentEntity.buffered && frag.gap) {
              return;
            }
            var isFragHint = !frag.relurl;
            Object.keys(timeRanges).forEach(function(elementaryStream) {
              var streamInfo = frag.elementaryStreams[elementaryStream];
              if (!streamInfo) {
                return;
              }
              var timeRange = timeRanges[elementaryStream];
              var partial = isFragHint || streamInfo.partial === true;
              fragmentEntity.range[elementaryStream] = _this2.getBufferedTimes(frag, data.part, partial, timeRange);
            });
            fragmentEntity.loaded = null;
            if (Object.keys(fragmentEntity.range).length) {
              fragmentEntity.buffered = true;
              var endList = fragmentEntity.body.endList = frag.endList || fragmentEntity.body.endList;
              if (endList) {
                this.endListFragments[fragmentEntity.body.type] = fragmentEntity;
              }
              if (!isPartial(fragmentEntity)) {
                this.removeParts(frag.sn - 1, frag.type);
              }
            } else {
              this.removeFragment(fragmentEntity.body);
            }
          };
          _proto.removeParts = function removeParts(snToKeep, levelType) {
            var activeParts = this.activePartLists[levelType];
            if (!activeParts) {
              return;
            }
            this.activePartLists[levelType] = activeParts.filter(function(part) {
              return part.fragment.sn >= snToKeep;
            });
          };
          _proto.fragBuffered = function fragBuffered(frag, force) {
            var fragKey = getFragmentKey(frag);
            var fragmentEntity = this.fragments[fragKey];
            if (!fragmentEntity && force) {
              fragmentEntity = this.fragments[fragKey] = {
                body: frag,
                appendedPTS: null,
                loaded: null,
                buffered: false,
                range: /* @__PURE__ */ Object.create(null)
              };
              if (frag.gap) {
                this.hasGaps = true;
              }
            }
            if (fragmentEntity) {
              fragmentEntity.loaded = null;
              fragmentEntity.buffered = true;
            }
          };
          _proto.getBufferedTimes = function getBufferedTimes(fragment, part, partial, timeRange) {
            var buffered = {
              time: [],
              partial
            };
            var startPTS = fragment.start;
            var endPTS = fragment.end;
            var minEndPTS = fragment.minEndPTS || endPTS;
            var maxStartPTS = fragment.maxStartPTS || startPTS;
            for (var i = 0; i < timeRange.length; i++) {
              var startTime = timeRange.start(i) - this.bufferPadding;
              var endTime = timeRange.end(i) + this.bufferPadding;
              if (maxStartPTS >= startTime && minEndPTS <= endTime) {
                buffered.time.push({
                  startPTS: Math.max(startPTS, timeRange.start(i)),
                  endPTS: Math.min(endPTS, timeRange.end(i))
                });
                break;
              } else if (startPTS < endTime && endPTS > startTime) {
                var start = Math.max(startPTS, timeRange.start(i));
                var end = Math.min(endPTS, timeRange.end(i));
                if (end > start) {
                  buffered.partial = true;
                  buffered.time.push({
                    startPTS: start,
                    endPTS: end
                  });
                }
              } else if (endPTS <= startTime) {
                break;
              }
            }
            return buffered;
          };
          _proto.getPartialFragment = function getPartialFragment(time) {
            var bestFragment = null;
            var timePadding;
            var startTime;
            var endTime;
            var bestOverlap = 0;
            var bufferPadding = this.bufferPadding, fragments = this.fragments;
            Object.keys(fragments).forEach(function(key) {
              var fragmentEntity = fragments[key];
              if (!fragmentEntity) {
                return;
              }
              if (isPartial(fragmentEntity)) {
                startTime = fragmentEntity.body.start - bufferPadding;
                endTime = fragmentEntity.body.end + bufferPadding;
                if (time >= startTime && time <= endTime) {
                  timePadding = Math.min(time - startTime, endTime - time);
                  if (bestOverlap <= timePadding) {
                    bestFragment = fragmentEntity.body;
                    bestOverlap = timePadding;
                  }
                }
              }
            });
            return bestFragment;
          };
          _proto.isEndListAppended = function isEndListAppended(type) {
            var lastFragmentEntity = this.endListFragments[type];
            return lastFragmentEntity !== void 0 && (lastFragmentEntity.buffered || isPartial(lastFragmentEntity));
          };
          _proto.getState = function getState(fragment) {
            var fragKey = getFragmentKey(fragment);
            var fragmentEntity = this.fragments[fragKey];
            if (fragmentEntity) {
              if (!fragmentEntity.buffered) {
                return FragmentState.APPENDING;
              } else if (isPartial(fragmentEntity)) {
                return FragmentState.PARTIAL;
              } else {
                return FragmentState.OK;
              }
            }
            return FragmentState.NOT_LOADED;
          };
          _proto.isTimeBuffered = function isTimeBuffered(startPTS, endPTS, timeRange) {
            var startTime;
            var endTime;
            for (var i = 0; i < timeRange.length; i++) {
              startTime = timeRange.start(i) - this.bufferPadding;
              endTime = timeRange.end(i) + this.bufferPadding;
              if (startPTS >= startTime && endPTS <= endTime) {
                return true;
              }
              if (endPTS <= startTime) {
                return false;
              }
            }
            return false;
          };
          _proto.onManifestLoading = function onManifestLoading() {
            this.removeAllFragments();
          };
          _proto.onFragLoaded = function onFragLoaded(event, data) {
            if (data.frag.sn === "initSegment" || data.frag.bitrateTest) {
              return;
            }
            var frag = data.frag;
            var loaded = data.part ? null : data;
            var fragKey = getFragmentKey(frag);
            this.fragments[fragKey] = {
              body: frag,
              appendedPTS: null,
              loaded,
              buffered: false,
              range: /* @__PURE__ */ Object.create(null)
            };
          };
          _proto.onBufferAppended = function onBufferAppended(event, data) {
            var frag = data.frag, part = data.part, timeRanges = data.timeRanges, type = data.type;
            if (frag.sn === "initSegment") {
              return;
            }
            var playlistType = frag.type;
            if (part) {
              var activeParts = this.activePartLists[playlistType];
              if (!activeParts) {
                this.activePartLists[playlistType] = activeParts = [];
              }
              activeParts.push(part);
            }
            this.timeRanges = timeRanges;
            var timeRange = timeRanges[type];
            this.detectEvictedFragments(type, timeRange, playlistType, part);
          };
          _proto.onFragBuffered = function onFragBuffered(event, data) {
            this.detectPartialFragments(data);
          };
          _proto.hasFragment = function hasFragment(fragment) {
            var fragKey = getFragmentKey(fragment);
            return !!this.fragments[fragKey];
          };
          _proto.hasFragments = function hasFragments(type) {
            var fragments = this.fragments;
            var keys = Object.keys(fragments);
            if (!type) {
              return keys.length > 0;
            }
            for (var i = keys.length; i--; ) {
              var fragmentEntity = fragments[keys[i]];
              if ((fragmentEntity == null ? void 0 : fragmentEntity.body.type) === type) {
                return true;
              }
            }
            return false;
          };
          _proto.hasParts = function hasParts(type) {
            var _this$activePartLists;
            return !!((_this$activePartLists = this.activePartLists[type]) != null && _this$activePartLists.length);
          };
          _proto.removeFragmentsInRange = function removeFragmentsInRange(start, end, playlistType, withGapOnly, unbufferedOnly) {
            var _this3 = this;
            if (withGapOnly && !this.hasGaps) {
              return;
            }
            Object.keys(this.fragments).forEach(function(key) {
              var fragmentEntity = _this3.fragments[key];
              if (!fragmentEntity) {
                return;
              }
              var frag = fragmentEntity.body;
              if (frag.type !== playlistType || withGapOnly && !frag.gap) {
                return;
              }
              if (frag.start < end && frag.end > start && (fragmentEntity.buffered || unbufferedOnly)) {
                _this3.removeFragment(frag);
              }
            });
          };
          _proto.removeFragment = function removeFragment(fragment) {
            var fragKey = getFragmentKey(fragment);
            fragment.clearElementaryStreamInfo();
            var activeParts = this.activePartLists[fragment.type];
            if (activeParts) {
              var snToRemove = fragment.sn;
              this.activePartLists[fragment.type] = activeParts.filter(function(part) {
                return part.fragment.sn !== snToRemove;
              });
            }
            delete this.fragments[fragKey];
            if (fragment.endList) {
              delete this.endListFragments[fragment.type];
            }
          };
          _proto.removeAllFragments = function removeAllFragments() {
            var _this$hls, _this$hls$latestLevel;
            this.fragments = /* @__PURE__ */ Object.create(null);
            this.endListFragments = /* @__PURE__ */ Object.create(null);
            this.activePartLists = /* @__PURE__ */ Object.create(null);
            this.hasGaps = false;
            var partlist = (_this$hls = this.hls) == null ? void 0 : (_this$hls$latestLevel = _this$hls.latestLevelDetails) == null ? void 0 : _this$hls$latestLevel.partList;
            if (partlist) {
              partlist.forEach(function(part) {
                return part.clearElementaryStreamInfo();
              });
            }
          };
          return FragmentTracker2;
        }();
        function isPartial(fragmentEntity) {
          var _fragmentEntity$range, _fragmentEntity$range2, _fragmentEntity$range3;
          return fragmentEntity.buffered && (fragmentEntity.body.gap || ((_fragmentEntity$range = fragmentEntity.range.video) == null ? void 0 : _fragmentEntity$range.partial) || ((_fragmentEntity$range2 = fragmentEntity.range.audio) == null ? void 0 : _fragmentEntity$range2.partial) || ((_fragmentEntity$range3 = fragmentEntity.range.audiovideo) == null ? void 0 : _fragmentEntity$range3.partial));
        }
        function getFragmentKey(fragment) {
          return fragment.type + "_" + fragment.level + "_" + fragment.sn;
        }
        var MIN_CHUNK_SIZE = Math.pow(2, 17);
        var FragmentLoader = /* @__PURE__ */ function() {
          function FragmentLoader2(config) {
            this.config = void 0;
            this.loader = null;
            this.partLoadTimeout = -1;
            this.config = config;
          }
          var _proto = FragmentLoader2.prototype;
          _proto.destroy = function destroy() {
            if (this.loader) {
              this.loader.destroy();
              this.loader = null;
            }
          };
          _proto.abort = function abort() {
            if (this.loader) {
              this.loader.abort();
            }
          };
          _proto.load = function load(frag, onProgress) {
            var _this = this;
            var url = frag.url;
            if (!url) {
              return Promise.reject(new LoadError({
                type: ErrorTypes.NETWORK_ERROR,
                details: ErrorDetails.FRAG_LOAD_ERROR,
                fatal: false,
                frag,
                error: new Error("Fragment does not have a " + (url ? "part list" : "url")),
                networkDetails: null
              }));
            }
            this.abort();
            var config = this.config;
            var FragmentILoader = config.fLoader;
            var DefaultILoader = config.loader;
            return new Promise(function(resolve, reject) {
              if (_this.loader) {
                _this.loader.destroy();
              }
              if (frag.gap) {
                if (frag.tagList.some(function(tags) {
                  return tags[0] === "GAP";
                })) {
                  reject(createGapLoadError(frag));
                  return;
                } else {
                  frag.gap = false;
                }
              }
              var loader = _this.loader = FragmentILoader ? new FragmentILoader(config) : new DefaultILoader(config);
              var loaderContext = createLoaderContext(frag);
              frag.loader = loader;
              var loadPolicy = getLoaderConfigWithoutReties(config.fragLoadPolicy.default);
              var loaderConfig = {
                loadPolicy,
                timeout: loadPolicy.maxLoadTimeMs,
                maxRetry: 0,
                retryDelay: 0,
                maxRetryDelay: 0,
                highWaterMark: frag.sn === "initSegment" ? Infinity : MIN_CHUNK_SIZE
              };
              frag.stats = loader.stats;
              var callbacks = {
                onSuccess: function onSuccess(response, stats, context, networkDetails) {
                  _this.resetLoader(frag, loader);
                  var payload = response.data;
                  if (context.resetIV && frag.decryptdata) {
                    frag.decryptdata.iv = new Uint8Array(payload.slice(0, 16));
                    payload = payload.slice(16);
                  }
                  resolve({
                    frag,
                    part: null,
                    payload,
                    networkDetails
                  });
                },
                onError: function onError(response, context, networkDetails, stats) {
                  _this.resetLoader(frag, loader);
                  reject(new LoadError({
                    type: ErrorTypes.NETWORK_ERROR,
                    details: ErrorDetails.FRAG_LOAD_ERROR,
                    fatal: false,
                    frag,
                    response: _objectSpread23({
                      url,
                      data: void 0
                    }, response),
                    error: new Error("HTTP Error " + response.code + " " + response.text),
                    networkDetails,
                    stats
                  }));
                },
                onAbort: function onAbort(stats, context, networkDetails) {
                  _this.resetLoader(frag, loader);
                  reject(new LoadError({
                    type: ErrorTypes.NETWORK_ERROR,
                    details: ErrorDetails.INTERNAL_ABORTED,
                    fatal: false,
                    frag,
                    error: new Error("Aborted"),
                    networkDetails,
                    stats
                  }));
                },
                onTimeout: function onTimeout(stats, context, networkDetails) {
                  _this.resetLoader(frag, loader);
                  reject(new LoadError({
                    type: ErrorTypes.NETWORK_ERROR,
                    details: ErrorDetails.FRAG_LOAD_TIMEOUT,
                    fatal: false,
                    frag,
                    error: new Error("Timeout after " + loaderConfig.timeout + "ms"),
                    networkDetails,
                    stats
                  }));
                }
              };
              if (onProgress) {
                callbacks.onProgress = function(stats, context, data, networkDetails) {
                  return onProgress({
                    frag,
                    part: null,
                    payload: data,
                    networkDetails
                  });
                };
              }
              loader.load(loaderContext, loaderConfig, callbacks);
            });
          };
          _proto.loadPart = function loadPart(frag, part, onProgress) {
            var _this2 = this;
            this.abort();
            var config = this.config;
            var FragmentILoader = config.fLoader;
            var DefaultILoader = config.loader;
            return new Promise(function(resolve, reject) {
              if (_this2.loader) {
                _this2.loader.destroy();
              }
              if (frag.gap || part.gap) {
                reject(createGapLoadError(frag, part));
                return;
              }
              var loader = _this2.loader = FragmentILoader ? new FragmentILoader(config) : new DefaultILoader(config);
              var loaderContext = createLoaderContext(frag, part);
              frag.loader = loader;
              var loadPolicy = getLoaderConfigWithoutReties(config.fragLoadPolicy.default);
              var loaderConfig = {
                loadPolicy,
                timeout: loadPolicy.maxLoadTimeMs,
                maxRetry: 0,
                retryDelay: 0,
                maxRetryDelay: 0,
                highWaterMark: MIN_CHUNK_SIZE
              };
              part.stats = loader.stats;
              loader.load(loaderContext, loaderConfig, {
                onSuccess: function onSuccess(response, stats, context, networkDetails) {
                  _this2.resetLoader(frag, loader);
                  _this2.updateStatsFromPart(frag, part);
                  var partLoadedData = {
                    frag,
                    part,
                    payload: response.data,
                    networkDetails
                  };
                  onProgress(partLoadedData);
                  resolve(partLoadedData);
                },
                onError: function onError(response, context, networkDetails, stats) {
                  _this2.resetLoader(frag, loader);
                  reject(new LoadError({
                    type: ErrorTypes.NETWORK_ERROR,
                    details: ErrorDetails.FRAG_LOAD_ERROR,
                    fatal: false,
                    frag,
                    part,
                    response: _objectSpread23({
                      url: loaderContext.url,
                      data: void 0
                    }, response),
                    error: new Error("HTTP Error " + response.code + " " + response.text),
                    networkDetails,
                    stats
                  }));
                },
                onAbort: function onAbort(stats, context, networkDetails) {
                  frag.stats.aborted = part.stats.aborted;
                  _this2.resetLoader(frag, loader);
                  reject(new LoadError({
                    type: ErrorTypes.NETWORK_ERROR,
                    details: ErrorDetails.INTERNAL_ABORTED,
                    fatal: false,
                    frag,
                    part,
                    error: new Error("Aborted"),
                    networkDetails,
                    stats
                  }));
                },
                onTimeout: function onTimeout(stats, context, networkDetails) {
                  _this2.resetLoader(frag, loader);
                  reject(new LoadError({
                    type: ErrorTypes.NETWORK_ERROR,
                    details: ErrorDetails.FRAG_LOAD_TIMEOUT,
                    fatal: false,
                    frag,
                    part,
                    error: new Error("Timeout after " + loaderConfig.timeout + "ms"),
                    networkDetails,
                    stats
                  }));
                }
              });
            });
          };
          _proto.updateStatsFromPart = function updateStatsFromPart(frag, part) {
            var fragStats = frag.stats;
            var partStats = part.stats;
            var partTotal = partStats.total;
            fragStats.loaded += partStats.loaded;
            if (partTotal) {
              var estTotalParts = Math.round(frag.duration / part.duration);
              var estLoadedParts = Math.min(Math.round(fragStats.loaded / partTotal), estTotalParts);
              var estRemainingParts = estTotalParts - estLoadedParts;
              var estRemainingBytes = estRemainingParts * Math.round(fragStats.loaded / estLoadedParts);
              fragStats.total = fragStats.loaded + estRemainingBytes;
            } else {
              fragStats.total = Math.max(fragStats.loaded, fragStats.total);
            }
            var fragLoading = fragStats.loading;
            var partLoading = partStats.loading;
            if (fragLoading.start) {
              fragLoading.first += partLoading.first - partLoading.start;
            } else {
              fragLoading.start = partLoading.start;
              fragLoading.first = partLoading.first;
            }
            fragLoading.end = partLoading.end;
          };
          _proto.resetLoader = function resetLoader(frag, loader) {
            frag.loader = null;
            if (this.loader === loader) {
              self.clearTimeout(this.partLoadTimeout);
              this.loader = null;
            }
            loader.destroy();
          };
          return FragmentLoader2;
        }();
        function createLoaderContext(frag, part) {
          if (part === void 0) {
            part = null;
          }
          var segment = part || frag;
          var loaderContext = {
            frag,
            part,
            responseType: "arraybuffer",
            url: segment.url,
            headers: {},
            rangeStart: 0,
            rangeEnd: 0
          };
          var start = segment.byteRangeStartOffset;
          var end = segment.byteRangeEndOffset;
          if (isFiniteNumber(start) && isFiniteNumber(end)) {
            var _frag$decryptdata;
            var byteRangeStart = start;
            var byteRangeEnd = end;
            if (frag.sn === "initSegment" && isMethodFullSegmentAesCbc((_frag$decryptdata = frag.decryptdata) == null ? void 0 : _frag$decryptdata.method)) {
              var fragmentLen = end - start;
              if (fragmentLen % 16) {
                byteRangeEnd = end + (16 - fragmentLen % 16);
              }
              if (start !== 0) {
                loaderContext.resetIV = true;
                byteRangeStart = start - 16;
              }
            }
            loaderContext.rangeStart = byteRangeStart;
            loaderContext.rangeEnd = byteRangeEnd;
          }
          return loaderContext;
        }
        function createGapLoadError(frag, part) {
          var error = new Error("GAP " + (frag.gap ? "tag" : "attribute") + " found");
          var errorData = {
            type: ErrorTypes.MEDIA_ERROR,
            details: ErrorDetails.FRAG_GAP,
            fatal: false,
            frag,
            error,
            networkDetails: null
          };
          if (part) {
            errorData.part = part;
          }
          (part ? part : frag).stats.aborted = true;
          return new LoadError(errorData);
        }
        function isMethodFullSegmentAesCbc(method) {
          return method === "AES-128" || method === "AES-256";
        }
        var LoadError = /* @__PURE__ */ function(_Error) {
          function LoadError2(data) {
            var _this3;
            _this3 = _Error.call(this, data.error.message) || this;
            _this3.data = void 0;
            _this3.data = data;
            return _this3;
          }
          _inheritsLoose(LoadError2, _Error);
          return LoadError2;
        }(/* @__PURE__ */ _wrapNativeSuper2(Error));
        var TaskLoop = /* @__PURE__ */ function(_Logger) {
          function TaskLoop2(label, logger5) {
            var _this;
            _this = _Logger.call(this, label, logger5) || this;
            _this._boundTick = void 0;
            _this._tickTimer = null;
            _this._tickInterval = null;
            _this._tickCallCount = 0;
            _this._boundTick = _this.tick.bind(_this);
            return _this;
          }
          _inheritsLoose(TaskLoop2, _Logger);
          var _proto = TaskLoop2.prototype;
          _proto.destroy = function destroy() {
            this.onHandlerDestroying();
            this.onHandlerDestroyed();
          };
          _proto.onHandlerDestroying = function onHandlerDestroying() {
            this.clearNextTick();
            this.clearInterval();
          };
          _proto.onHandlerDestroyed = function onHandlerDestroyed() {
          };
          _proto.hasInterval = function hasInterval() {
            return !!this._tickInterval;
          };
          _proto.hasNextTick = function hasNextTick() {
            return !!this._tickTimer;
          };
          _proto.setInterval = function setInterval(millis) {
            if (!this._tickInterval) {
              this._tickCallCount = 0;
              this._tickInterval = self.setInterval(this._boundTick, millis);
              return true;
            }
            return false;
          };
          _proto.clearInterval = function clearInterval2() {
            if (this._tickInterval) {
              self.clearInterval(this._tickInterval);
              this._tickInterval = null;
              return true;
            }
            return false;
          };
          _proto.clearNextTick = function clearNextTick() {
            if (this._tickTimer) {
              self.clearTimeout(this._tickTimer);
              this._tickTimer = null;
              return true;
            }
            return false;
          };
          _proto.tick = function tick() {
            this._tickCallCount++;
            if (this._tickCallCount === 1) {
              this.doTick();
              if (this._tickCallCount > 1) {
                this.tickImmediate();
              }
              this._tickCallCount = 0;
            }
          };
          _proto.tickImmediate = function tickImmediate() {
            this.clearNextTick();
            this._tickTimer = self.setTimeout(this._boundTick, 0);
          };
          _proto.doTick = function doTick() {
          };
          return TaskLoop2;
        }(Logger4);
        var ChunkMetadata = function ChunkMetadata2(level, sn, id, size, part, partial) {
          if (size === void 0) {
            size = 0;
          }
          if (part === void 0) {
            part = -1;
          }
          if (partial === void 0) {
            partial = false;
          }
          this.level = void 0;
          this.sn = void 0;
          this.part = void 0;
          this.id = void 0;
          this.size = void 0;
          this.partial = void 0;
          this.transmuxing = getNewPerformanceTiming();
          this.buffering = {
            audio: getNewPerformanceTiming(),
            video: getNewPerformanceTiming(),
            audiovideo: getNewPerformanceTiming()
          };
          this.level = level;
          this.sn = sn;
          this.id = id;
          this.size = size;
          this.part = part;
          this.partial = partial;
        };
        function getNewPerformanceTiming() {
          return {
            start: 0,
            executeStart: 0,
            executeEnd: 0,
            end: 0
          };
        }
        function findFirstFragWithCC(fragments, cc) {
          for (var i = 0, len = fragments.length; i < len; i++) {
            var _fragments$i;
            if (((_fragments$i = fragments[i]) == null ? void 0 : _fragments$i.cc) === cc) {
              return fragments[i];
            }
          }
          return null;
        }
        function shouldAlignOnDiscontinuities(refDetails, details) {
          if (refDetails) {
            if (details.startCC < refDetails.endCC && details.endCC > refDetails.startCC) {
              return true;
            }
          }
          return false;
        }
        function adjustFragmentStart(frag, sliding) {
          if (frag) {
            var start = frag.start + sliding;
            frag.start = frag.startPTS = start;
            frag.endPTS = start + frag.duration;
          }
        }
        function adjustSlidingStart(sliding, details) {
          var fragments = details.fragments;
          for (var i = 0, len = fragments.length; i < len; i++) {
            adjustFragmentStart(fragments[i], sliding);
          }
          if (details.fragmentHint) {
            adjustFragmentStart(details.fragmentHint, sliding);
          }
          details.alignedSliding = true;
        }
        function alignStream(switchDetails, details) {
          if (!switchDetails) {
            return;
          }
          alignDiscontinuities(details, switchDetails);
          if (!details.alignedSliding && switchDetails) {
            alignMediaPlaylistByPDT(details, switchDetails);
          }
          if (!details.alignedSliding && switchDetails && !details.skippedSegments) {
            adjustSliding(switchDetails, details, false);
          }
        }
        function alignDiscontinuities(details, refDetails) {
          if (!shouldAlignOnDiscontinuities(refDetails, details)) {
            return;
          }
          var targetCC = Math.min(refDetails.endCC, details.endCC);
          var refFrag = findFirstFragWithCC(refDetails.fragments, targetCC);
          var frag = findFirstFragWithCC(details.fragments, targetCC);
          if (!refFrag || !frag) {
            return;
          }
          logger4.log("Aligning playlist at start of dicontinuity sequence " + targetCC);
          var delta = refFrag.start - frag.start;
          adjustSlidingStart(delta, details);
        }
        function alignMediaPlaylistByPDT(details, refDetails) {
          if (!details.hasProgramDateTime || !refDetails.hasProgramDateTime) {
            return;
          }
          var fragments = details.fragments;
          var refFragments = refDetails.fragments;
          if (!fragments.length || !refFragments.length) {
            return;
          }
          var refFrag;
          var frag;
          var targetCC = Math.min(refDetails.endCC, details.endCC);
          if (refDetails.startCC < targetCC && details.startCC < targetCC) {
            refFrag = findFirstFragWithCC(refFragments, targetCC);
            frag = findFirstFragWithCC(fragments, targetCC);
          }
          if (!refFrag || !frag) {
            refFrag = refFragments[Math.floor(refFragments.length / 2)];
            frag = findFirstFragWithCC(fragments, refFrag.cc) || fragments[Math.floor(fragments.length / 2)];
          }
          var refPDT = refFrag.programDateTime;
          var targetPDT = frag.programDateTime;
          if (!refPDT || !targetPDT) {
            return;
          }
          var delta = (targetPDT - refPDT) / 1e3 - (frag.start - refFrag.start);
          adjustSlidingStart(delta, details);
        }
        var TimeRanges2 = {
          toString: function toString2(r) {
            var log = "";
            var len = r.length;
            for (var i = 0; i < len; i++) {
              log += "[" + r.start(i).toFixed(3) + "-" + r.end(i).toFixed(3) + "]";
            }
            return log;
          }
        };
        var State = {
          STOPPED: "STOPPED",
          IDLE: "IDLE",
          KEY_LOADING: "KEY_LOADING",
          FRAG_LOADING: "FRAG_LOADING",
          FRAG_LOADING_WAITING_RETRY: "FRAG_LOADING_WAITING_RETRY",
          PARSING: "PARSING",
          PARSED: "PARSED",
          ENDED: "ENDED",
          ERROR: "ERROR",
          WAITING_LEVEL: "WAITING_LEVEL"
        };
        var BaseStreamController = /* @__PURE__ */ function(_TaskLoop) {
          function BaseStreamController2(hls, fragmentTracker, keyLoader, logPrefix, playlistType) {
            var _this;
            _this = _TaskLoop.call(this, logPrefix, hls.logger) || this;
            _this.hls = void 0;
            _this.fragPrevious = null;
            _this.fragCurrent = null;
            _this.fragmentTracker = void 0;
            _this.transmuxer = null;
            _this._state = State.STOPPED;
            _this.playlistType = void 0;
            _this.media = null;
            _this.mediaBuffer = null;
            _this.config = void 0;
            _this.bitrateTest = false;
            _this.lastCurrentTime = 0;
            _this.nextLoadPosition = 0;
            _this.startPosition = 0;
            _this.startTimeOffset = null;
            _this.retryDate = 0;
            _this.levels = null;
            _this.fragmentLoader = void 0;
            _this.keyLoader = void 0;
            _this.levelLastLoaded = null;
            _this.startFragRequested = false;
            _this.decrypter = void 0;
            _this.initPTS = [];
            _this.buffering = true;
            _this.loadingParts = false;
            _this.loopSn = void 0;
            _this.onMediaSeeking = function() {
              var _this2 = _this, config = _this2.config, fragCurrent = _this2.fragCurrent, media = _this2.media, mediaBuffer = _this2.mediaBuffer, state = _this2.state;
              var currentTime = media ? media.currentTime : 0;
              var bufferInfo = BufferHelper.bufferInfo(mediaBuffer ? mediaBuffer : media, currentTime, config.maxBufferHole);
              _this.log("media seeking to " + (isFiniteNumber(currentTime) ? currentTime.toFixed(3) : currentTime) + ", state: " + state);
              if (_this.state === State.ENDED) {
                _this.resetLoadingState();
              } else if (fragCurrent) {
                var tolerance = config.maxFragLookUpTolerance;
                var fragStartOffset = fragCurrent.start - tolerance;
                var fragEndOffset = fragCurrent.start + fragCurrent.duration + tolerance;
                if (!bufferInfo.len || fragEndOffset < bufferInfo.start || fragStartOffset > bufferInfo.end) {
                  var pastFragment = currentTime > fragEndOffset;
                  if (currentTime < fragStartOffset || pastFragment) {
                    if (pastFragment && fragCurrent.loader) {
                      _this.log("seeking outside of buffer while fragment load in progress, cancel fragment load");
                      fragCurrent.abortRequests();
                      _this.resetLoadingState();
                    }
                    _this.fragPrevious = null;
                  }
                }
              }
              if (media) {
                _this.fragmentTracker.removeFragmentsInRange(currentTime, Infinity, _this.playlistType, true);
                var lastCurrentTime = _this.lastCurrentTime;
                if (currentTime > lastCurrentTime) {
                  _this.lastCurrentTime = currentTime;
                }
                if (!_this.loadingParts) {
                  var bufferEnd = Math.max(bufferInfo.end, currentTime);
                  var shouldLoadParts = _this.shouldLoadParts(_this.getLevelDetails(), bufferEnd);
                  if (shouldLoadParts) {
                    _this.log("LL-Part loading ON after seeking to " + currentTime.toFixed(2) + " with buffer @" + bufferEnd.toFixed(2));
                    _this.loadingParts = shouldLoadParts;
                  }
                }
              }
              if (!_this.hls.hasEnoughToStart && !bufferInfo.len) {
                _this.log("setting startPosition to " + currentTime + " because of seek before start");
                _this.nextLoadPosition = _this.startPosition = currentTime;
              }
              _this.tickImmediate();
            };
            _this.onMediaEnded = function() {
              _this.log("setting startPosition to 0 because media ended");
              _this.startPosition = _this.lastCurrentTime = 0;
            };
            _this.playlistType = playlistType;
            _this.hls = hls;
            _this.fragmentLoader = new FragmentLoader(hls.config);
            _this.keyLoader = keyLoader;
            _this.fragmentTracker = fragmentTracker;
            _this.config = hls.config;
            _this.decrypter = new Decrypter(hls.config);
            return _this;
          }
          _inheritsLoose(BaseStreamController2, _TaskLoop);
          var _proto = BaseStreamController2.prototype;
          _proto.registerListeners = function registerListeners() {
            var hls = this.hls;
            hls.on(Events.MEDIA_ATTACHED, this.onMediaAttached, this);
            hls.on(Events.MEDIA_DETACHING, this.onMediaDetaching, this);
            hls.on(Events.MANIFEST_LOADING, this.onManifestLoading, this);
            hls.on(Events.MANIFEST_LOADED, this.onManifestLoaded, this);
            hls.on(Events.ERROR, this.onError, this);
          };
          _proto.unregisterListeners = function unregisterListeners() {
            var hls = this.hls;
            hls.off(Events.MEDIA_ATTACHED, this.onMediaAttached, this);
            hls.off(Events.MEDIA_DETACHING, this.onMediaDetaching, this);
            hls.off(Events.MANIFEST_LOADING, this.onManifestLoading, this);
            hls.off(Events.MANIFEST_LOADED, this.onManifestLoaded, this);
            hls.off(Events.ERROR, this.onError, this);
          };
          _proto.doTick = function doTick() {
            this.onTickEnd();
          };
          _proto.onTickEnd = function onTickEnd() {
          };
          _proto.startLoad = function startLoad(startPosition) {
          };
          _proto.stopLoad = function stopLoad() {
            if (this.state === State.STOPPED) {
              return;
            }
            this.fragmentLoader.abort();
            this.keyLoader.abort(this.playlistType);
            var frag = this.fragCurrent;
            if (frag != null && frag.loader) {
              frag.abortRequests();
              this.fragmentTracker.removeFragment(frag);
            }
            this.resetTransmuxer();
            this.fragCurrent = null;
            this.fragPrevious = null;
            this.clearInterval();
            this.clearNextTick();
            this.state = State.STOPPED;
          };
          _proto.pauseBuffering = function pauseBuffering() {
            this.buffering = false;
          };
          _proto.resumeBuffering = function resumeBuffering() {
            this.buffering = true;
          };
          _proto._streamEnded = function _streamEnded(bufferInfo, levelDetails) {
            if (levelDetails.live || !this.media) {
              return false;
            }
            var bufferEnd = bufferInfo.end || 0;
            var timelineStart = this.config.timelineOffset || 0;
            if (bufferEnd <= timelineStart) {
              return false;
            }
            var nextStart = bufferInfo.nextStart;
            var hasSecondBufferedRange = nextStart && nextStart > timelineStart && nextStart < levelDetails.edge;
            if (hasSecondBufferedRange) {
              return false;
            }
            if (this.media.currentTime < bufferInfo.start) {
              return false;
            }
            var partList = levelDetails.partList;
            if (partList != null && partList.length) {
              var lastPart = partList[partList.length - 1];
              var lastPartBuffered = BufferHelper.isBuffered(this.media, lastPart.start + lastPart.duration / 2);
              return lastPartBuffered;
            }
            var playlistType = levelDetails.fragments[levelDetails.fragments.length - 1].type;
            return this.fragmentTracker.isEndListAppended(playlistType);
          };
          _proto.getLevelDetails = function getLevelDetails() {
            if (this.levels && this.levelLastLoaded !== null) {
              var _this$levelLastLoaded;
              return (_this$levelLastLoaded = this.levelLastLoaded) == null ? void 0 : _this$levelLastLoaded.details;
            }
          };
          _proto.onMediaAttached = function onMediaAttached(event, data) {
            var media = this.media = this.mediaBuffer = data.media;
            media.removeEventListener("seeking", this.onMediaSeeking);
            media.removeEventListener("ended", this.onMediaEnded);
            media.addEventListener("seeking", this.onMediaSeeking);
            media.addEventListener("ended", this.onMediaEnded);
            var config = this.config;
            if (this.levels && config.autoStartLoad && this.state === State.STOPPED) {
              this.startLoad(config.startPosition);
            }
          };
          _proto.onMediaDetaching = function onMediaDetaching(event, data) {
            var transferringMedia = !!data.transferMedia;
            var media = this.media;
            if (media === null) {
              return;
            }
            if (media.ended) {
              this.log("MSE detaching and video ended, reset startPosition");
              this.startPosition = this.lastCurrentTime = 0;
            }
            media.removeEventListener("seeking", this.onMediaSeeking);
            media.removeEventListener("ended", this.onMediaEnded);
            if (this.keyLoader && !transferringMedia) {
              this.keyLoader.detach();
            }
            this.media = this.mediaBuffer = null;
            this.loopSn = void 0;
            if (transferringMedia) {
              this.resetLoadingState();
              this.resetTransmuxer();
              return;
            }
            this.loadingParts = false;
            this.fragmentTracker.removeAllFragments();
            this.stopLoad();
          };
          _proto.onManifestLoading = function onManifestLoading() {
            this.initPTS = [];
            this.levels = this.levelLastLoaded = this.fragCurrent = null;
            this.lastCurrentTime = this.startPosition = 0;
            this.startFragRequested = false;
          };
          _proto.onError = function onError(event, data) {
          };
          _proto.onManifestLoaded = function onManifestLoaded(event, data) {
            this.startTimeOffset = data.startTimeOffset;
          };
          _proto.onHandlerDestroying = function onHandlerDestroying() {
            this.stopLoad();
            if (this.transmuxer) {
              this.transmuxer.destroy();
              this.transmuxer = null;
            }
            _TaskLoop.prototype.onHandlerDestroying.call(this);
            this.hls = this.onMediaSeeking = this.onMediaEnded = null;
          };
          _proto.onHandlerDestroyed = function onHandlerDestroyed() {
            this.state = State.STOPPED;
            if (this.fragmentLoader) {
              this.fragmentLoader.destroy();
            }
            if (this.keyLoader) {
              this.keyLoader.destroy();
            }
            if (this.decrypter) {
              this.decrypter.destroy();
            }
            this.hls = this.log = this.warn = this.decrypter = this.keyLoader = this.fragmentLoader = this.fragmentTracker = null;
            _TaskLoop.prototype.onHandlerDestroyed.call(this);
          };
          _proto.loadFragment = function loadFragment(frag, level, targetBufferTime) {
            this.startFragRequested = true;
            this._loadFragForPlayback(frag, level, targetBufferTime);
          };
          _proto._loadFragForPlayback = function _loadFragForPlayback(fragment, level, targetBufferTime) {
            var _this3 = this;
            var progressCallback = function progressCallback2(data) {
              var frag = data.frag;
              if (_this3.fragContextChanged(frag)) {
                _this3.warn(frag.type + " sn: " + frag.sn + (data.part ? " part: " + data.part.index : "") + " of " + _this3.fragInfo(frag, false, data.part) + ") was dropped during download.");
                _this3.fragmentTracker.removeFragment(frag);
                return;
              }
              frag.stats.chunkCount++;
              _this3._handleFragmentLoadProgress(data);
            };
            this._doFragLoad(fragment, level, targetBufferTime, progressCallback).then(function(data) {
              if (!data) {
                return;
              }
              var state = _this3.state;
              var frag = data.frag;
              if (_this3.fragContextChanged(frag)) {
                if (state === State.FRAG_LOADING || !_this3.fragCurrent && state === State.PARSING) {
                  _this3.fragmentTracker.removeFragment(frag);
                  _this3.state = State.IDLE;
                }
                return;
              }
              if ("payload" in data) {
                _this3.log("Loaded " + frag.type + " sn: " + frag.sn + " of " + _this3.playlistLabel() + " " + frag.level);
                _this3.hls.trigger(Events.FRAG_LOADED, data);
              }
              _this3._handleFragmentLoadComplete(data);
            }).catch(function(reason) {
              if (_this3.state === State.STOPPED || _this3.state === State.ERROR) {
                return;
              }
              _this3.warn("Frag error: " + ((reason == null ? void 0 : reason.message) || reason));
              _this3.resetFragmentLoading(fragment);
            });
          };
          _proto.clearTrackerIfNeeded = function clearTrackerIfNeeded(frag) {
            var _this$mediaBuffer;
            var fragmentTracker = this.fragmentTracker;
            var fragState = fragmentTracker.getState(frag);
            if (fragState === FragmentState.APPENDING) {
              var playlistType = frag.type;
              var bufferedInfo = this.getFwdBufferInfo(this.mediaBuffer, playlistType);
              var minForwardBufferLength = Math.max(frag.duration, bufferedInfo ? bufferedInfo.len : this.config.maxBufferLength);
              var backtrackFragment = this.backtrackFragment;
              var backtracked = backtrackFragment ? frag.sn - backtrackFragment.sn : 0;
              if (backtracked === 1 || this.reduceMaxBufferLength(minForwardBufferLength, frag.duration)) {
                fragmentTracker.removeFragment(frag);
              }
            } else if (((_this$mediaBuffer = this.mediaBuffer) == null ? void 0 : _this$mediaBuffer.buffered.length) === 0) {
              fragmentTracker.removeAllFragments();
            } else if (fragmentTracker.hasParts(frag.type)) {
              fragmentTracker.detectPartialFragments({
                frag,
                part: null,
                stats: frag.stats,
                id: frag.type
              });
              if (fragmentTracker.getState(frag) === FragmentState.PARTIAL) {
                fragmentTracker.removeFragment(frag);
              }
            }
          };
          _proto.checkLiveUpdate = function checkLiveUpdate(details) {
            if (details.updated && !details.live) {
              var lastFragment = details.fragments[details.fragments.length - 1];
              this.fragmentTracker.detectPartialFragments({
                frag: lastFragment,
                part: null,
                stats: lastFragment.stats,
                id: lastFragment.type
              });
            }
            if (!details.fragments[0]) {
              details.deltaUpdateFailed = true;
            }
          };
          _proto.waitForLive = function waitForLive(levelInfo) {
            var details = levelInfo.details;
            return (details == null ? void 0 : details.live) && details.type !== "EVENT" && (this.levelLastLoaded !== levelInfo || details.expired);
          };
          _proto.flushMainBuffer = function flushMainBuffer(startOffset, endOffset, type) {
            if (type === void 0) {
              type = null;
            }
            if (!(startOffset - endOffset)) {
              return;
            }
            var flushScope = {
              startOffset,
              endOffset,
              type
            };
            this.hls.trigger(Events.BUFFER_FLUSHING, flushScope);
          };
          _proto._loadInitSegment = function _loadInitSegment(fragment, level) {
            var _this4 = this;
            this._doFragLoad(fragment, level).then(function(data) {
              var frag = data == null ? void 0 : data.frag;
              if (!frag || _this4.fragContextChanged(frag) || !_this4.levels) {
                throw new Error("init load aborted");
              }
              return data;
            }).then(function(data) {
              var hls = _this4.hls;
              var frag = data.frag, payload = data.payload;
              var decryptData = frag.decryptdata;
              if (payload && payload.byteLength > 0 && decryptData != null && decryptData.key && decryptData.iv && isFullSegmentEncryption(decryptData.method)) {
                var startTime = self.performance.now();
                return _this4.decrypter.decrypt(new Uint8Array(payload), decryptData.key.buffer, decryptData.iv.buffer, getAesModeFromFullSegmentMethod(decryptData.method)).catch(function(err) {
                  hls.trigger(Events.ERROR, {
                    type: ErrorTypes.MEDIA_ERROR,
                    details: ErrorDetails.FRAG_DECRYPT_ERROR,
                    fatal: false,
                    error: err,
                    reason: err.message,
                    frag
                  });
                  throw err;
                }).then(function(decryptedData) {
                  var endTime = self.performance.now();
                  hls.trigger(Events.FRAG_DECRYPTED, {
                    frag,
                    payload: decryptedData,
                    stats: {
                      tstart: startTime,
                      tdecrypt: endTime
                    }
                  });
                  data.payload = decryptedData;
                  return _this4.completeInitSegmentLoad(data);
                });
              }
              return _this4.completeInitSegmentLoad(data);
            }).catch(function(reason) {
              if (_this4.state === State.STOPPED || _this4.state === State.ERROR) {
                return;
              }
              _this4.warn(reason);
              _this4.resetFragmentLoading(fragment);
            });
          };
          _proto.completeInitSegmentLoad = function completeInitSegmentLoad(data) {
            var levels = this.levels;
            if (!levels) {
              throw new Error("init load aborted, missing levels");
            }
            var stats = data.frag.stats;
            if (this.state !== State.STOPPED) {
              this.state = State.IDLE;
            }
            data.frag.data = new Uint8Array(data.payload);
            stats.parsing.start = stats.buffering.start = self.performance.now();
            stats.parsing.end = stats.buffering.end = self.performance.now();
            this.tick();
          };
          _proto.fragContextChanged = function fragContextChanged(frag) {
            var fragCurrent = this.fragCurrent;
            return !frag || !fragCurrent || frag.sn !== fragCurrent.sn || frag.level !== fragCurrent.level;
          };
          _proto.fragBufferedComplete = function fragBufferedComplete(frag, part) {
            var media = this.mediaBuffer ? this.mediaBuffer : this.media;
            this.log("Buffered " + frag.type + " sn: " + frag.sn + (part ? " part: " + part.index : "") + " of " + this.fragInfo(frag, false, part) + " > buffer:" + (media ? TimeRanges2.toString(BufferHelper.getBuffered(media)) : "(detached)") + ")");
            if (isMediaFragment(frag)) {
              var _this$levels;
              if (frag.type !== PlaylistLevelType.SUBTITLE) {
                var el = frag.elementaryStreams;
                if (!Object.keys(el).some(function(type) {
                  return !!el[type];
                })) {
                  this.state = State.IDLE;
                  return;
                }
              }
              var level = (_this$levels = this.levels) == null ? void 0 : _this$levels[frag.level];
              if (level != null && level.fragmentError) {
                this.log("Resetting level fragment error count of " + level.fragmentError + " on frag buffered");
                level.fragmentError = 0;
              }
            }
            this.state = State.IDLE;
          };
          _proto._handleFragmentLoadComplete = function _handleFragmentLoadComplete(fragLoadedEndData) {
            var transmuxer = this.transmuxer;
            if (!transmuxer) {
              return;
            }
            var frag = fragLoadedEndData.frag, part = fragLoadedEndData.part, partsLoaded = fragLoadedEndData.partsLoaded;
            var complete = !partsLoaded || partsLoaded.length === 0 || partsLoaded.some(function(fragLoaded) {
              return !fragLoaded;
            });
            var chunkMeta = new ChunkMetadata(frag.level, frag.sn, frag.stats.chunkCount + 1, 0, part ? part.index : -1, !complete);
            transmuxer.flush(chunkMeta);
          };
          _proto._handleFragmentLoadProgress = function _handleFragmentLoadProgress(frag) {
          };
          _proto._doFragLoad = function _doFragLoad(frag, level, targetBufferTime, progressCallback) {
            var _frag$decryptdata, _this5 = this;
            if (targetBufferTime === void 0) {
              targetBufferTime = null;
            }
            this.fragCurrent = frag;
            var details = level == null ? void 0 : level.details;
            if (!this.levels || !details) {
              throw new Error("frag load aborted, missing level" + (details ? "" : " detail") + "s");
            }
            var keyLoadingPromise = null;
            if (frag.encrypted && !((_frag$decryptdata = frag.decryptdata) != null && _frag$decryptdata.key)) {
              this.log("Loading key for " + frag.sn + " of [" + details.startSN + "-" + details.endSN + "], " + this.playlistLabel() + " " + frag.level);
              this.state = State.KEY_LOADING;
              this.fragCurrent = frag;
              keyLoadingPromise = this.keyLoader.load(frag).then(function(keyLoadedData) {
                if (!_this5.fragContextChanged(keyLoadedData.frag)) {
                  _this5.hls.trigger(Events.KEY_LOADED, keyLoadedData);
                  if (_this5.state === State.KEY_LOADING) {
                    _this5.state = State.IDLE;
                  }
                  return keyLoadedData;
                }
              });
              this.hls.trigger(Events.KEY_LOADING, {
                frag
              });
              if (this.fragCurrent === null) {
                keyLoadingPromise = Promise.reject(new Error("frag load aborted, context changed in KEY_LOADING"));
              }
            } else if (!frag.encrypted && details.encryptedFragments.length) {
              this.keyLoader.loadClear(frag, details.encryptedFragments);
            }
            var fragPrevious = this.fragPrevious;
            if (isMediaFragment(frag) && (!fragPrevious || frag.sn !== fragPrevious.sn)) {
              var shouldLoadParts = this.shouldLoadParts(level.details, frag.end);
              if (shouldLoadParts !== this.loadingParts) {
                this.log("LL-Part loading " + (shouldLoadParts ? "ON" : "OFF") + " loading sn " + (fragPrevious == null ? void 0 : fragPrevious.sn) + "->" + frag.sn);
                this.loadingParts = shouldLoadParts;
              }
            }
            targetBufferTime = Math.max(frag.start, targetBufferTime || 0);
            if (this.loadingParts && isMediaFragment(frag)) {
              var partList = details.partList;
              if (partList && progressCallback) {
                if (targetBufferTime > frag.end && details.fragmentHint) {
                  frag = details.fragmentHint;
                }
                var partIndex = this.getNextPart(partList, frag, targetBufferTime);
                if (partIndex > -1) {
                  var part = partList[partIndex];
                  frag = this.fragCurrent = part.fragment;
                  this.log("Loading " + frag.type + " sn: " + frag.sn + " part: " + part.index + " (" + partIndex + "/" + (partList.length - 1) + ") of " + this.fragInfo(frag, false, part) + ") cc: " + frag.cc + " [" + details.startSN + "-" + details.endSN + "], target: " + parseFloat(targetBufferTime.toFixed(3)));
                  this.nextLoadPosition = part.start + part.duration;
                  this.state = State.FRAG_LOADING;
                  var _result;
                  if (keyLoadingPromise) {
                    _result = keyLoadingPromise.then(function(keyLoadedData) {
                      if (!keyLoadedData || _this5.fragContextChanged(keyLoadedData.frag)) {
                        return null;
                      }
                      return _this5.doFragPartsLoad(frag, part, level, progressCallback);
                    }).catch(function(error) {
                      return _this5.handleFragLoadError(error);
                    });
                  } else {
                    _result = this.doFragPartsLoad(frag, part, level, progressCallback).catch(function(error) {
                      return _this5.handleFragLoadError(error);
                    });
                  }
                  this.hls.trigger(Events.FRAG_LOADING, {
                    frag,
                    part,
                    targetBufferTime
                  });
                  if (this.fragCurrent === null) {
                    return Promise.reject(new Error("frag load aborted, context changed in FRAG_LOADING parts"));
                  }
                  return _result;
                } else if (!frag.url || this.loadedEndOfParts(partList, targetBufferTime)) {
                  return Promise.resolve(null);
                }
              }
            }
            if (isMediaFragment(frag) && this.loadingParts) {
              this.log("LL-Part loading OFF after next part miss @" + targetBufferTime.toFixed(2));
              this.loadingParts = false;
            } else if (!frag.url) {
              return Promise.resolve(null);
            }
            this.log("Loading " + frag.type + " sn: " + frag.sn + " of " + this.fragInfo(frag, false) + ") cc: " + frag.cc + " " + (details ? "[" + details.startSN + "-" + details.endSN + "]" : "") + ", target: " + parseFloat(targetBufferTime.toFixed(3)));
            if (isFiniteNumber(frag.sn) && !this.bitrateTest) {
              this.nextLoadPosition = frag.start + frag.duration;
            }
            this.state = State.FRAG_LOADING;
            var dataOnProgress = this.config.progressive;
            var result;
            if (dataOnProgress && keyLoadingPromise) {
              result = keyLoadingPromise.then(function(keyLoadedData) {
                if (!keyLoadedData || _this5.fragContextChanged(keyLoadedData == null ? void 0 : keyLoadedData.frag)) {
                  return null;
                }
                return _this5.fragmentLoader.load(frag, progressCallback);
              }).catch(function(error) {
                return _this5.handleFragLoadError(error);
              });
            } else {
              result = Promise.all([this.fragmentLoader.load(frag, dataOnProgress ? progressCallback : void 0), keyLoadingPromise]).then(function(_ref) {
                var fragLoadedData = _ref[0];
                if (!dataOnProgress && fragLoadedData && progressCallback) {
                  progressCallback(fragLoadedData);
                }
                return fragLoadedData;
              }).catch(function(error) {
                return _this5.handleFragLoadError(error);
              });
            }
            this.hls.trigger(Events.FRAG_LOADING, {
              frag,
              targetBufferTime
            });
            if (this.fragCurrent === null) {
              return Promise.reject(new Error("frag load aborted, context changed in FRAG_LOADING"));
            }
            return result;
          };
          _proto.doFragPartsLoad = function doFragPartsLoad(frag, fromPart, level, progressCallback) {
            var _this6 = this;
            return new Promise(function(resolve, reject) {
              var _level$details;
              var partsLoaded = [];
              var initialPartList = (_level$details = level.details) == null ? void 0 : _level$details.partList;
              var _loadPart = function loadPart(part) {
                _this6.fragmentLoader.loadPart(frag, part, progressCallback).then(function(partLoadedData) {
                  partsLoaded[part.index] = partLoadedData;
                  var loadedPart = partLoadedData.part;
                  _this6.hls.trigger(Events.FRAG_LOADED, partLoadedData);
                  var nextPart = getPartWith(level.details, frag.sn, part.index + 1) || findPart(initialPartList, frag.sn, part.index + 1);
                  if (nextPart) {
                    _loadPart(nextPart);
                  } else {
                    return resolve({
                      frag,
                      part: loadedPart,
                      partsLoaded
                    });
                  }
                }).catch(reject);
              };
              _loadPart(fromPart);
            });
          };
          _proto.handleFragLoadError = function handleFragLoadError(error) {
            if ("data" in error) {
              var data = error.data;
              if (error.data && data.details === ErrorDetails.INTERNAL_ABORTED) {
                this.handleFragLoadAborted(data.frag, data.part);
              } else {
                this.hls.trigger(Events.ERROR, data);
              }
            } else {
              this.hls.trigger(Events.ERROR, {
                type: ErrorTypes.OTHER_ERROR,
                details: ErrorDetails.INTERNAL_EXCEPTION,
                err: error,
                error,
                fatal: true
              });
            }
            return null;
          };
          _proto._handleTransmuxerFlush = function _handleTransmuxerFlush(chunkMeta) {
            var context = this.getCurrentContext(chunkMeta);
            if (!context || this.state !== State.PARSING) {
              if (!this.fragCurrent && this.state !== State.STOPPED && this.state !== State.ERROR) {
                this.state = State.IDLE;
              }
              return;
            }
            var frag = context.frag, part = context.part, level = context.level;
            var now2 = self.performance.now();
            frag.stats.parsing.end = now2;
            if (part) {
              part.stats.parsing.end = now2;
            }
            var levelDetails = this.getLevelDetails();
            var loadingPartsAtEdge = levelDetails && frag.sn > levelDetails.endSN;
            var shouldLoadParts = loadingPartsAtEdge || this.shouldLoadParts(levelDetails, frag.end);
            if (shouldLoadParts !== this.loadingParts) {
              this.log("LL-Part loading " + (shouldLoadParts ? "ON" : "OFF") + " after parsing segment ending @" + frag.end.toFixed(2));
              this.loadingParts = shouldLoadParts;
            }
            this.updateLevelTiming(frag, part, level, chunkMeta.partial);
          };
          _proto.shouldLoadParts = function shouldLoadParts(details, bufferEnd) {
            if (this.config.lowLatencyMode) {
              if (!details) {
                return this.loadingParts;
              }
              if (details != null && details.partList) {
                var _details$fragmentHint;
                var firstPart = details.partList[0];
                var safePartStart = firstPart.end + (((_details$fragmentHint = details.fragmentHint) == null ? void 0 : _details$fragmentHint.duration) || 0);
                if (bufferEnd >= safePartStart) {
                  var _this$media;
                  var playhead = this.hls.hasEnoughToStart ? ((_this$media = this.media) == null ? void 0 : _this$media.currentTime) || this.lastCurrentTime : this.getLoadPosition();
                  if (playhead > firstPart.start - firstPart.fragment.duration) {
                    return true;
                  }
                }
              }
            }
            return false;
          };
          _proto.getCurrentContext = function getCurrentContext(chunkMeta) {
            var levels = this.levels, fragCurrent = this.fragCurrent;
            var levelIndex = chunkMeta.level, sn = chunkMeta.sn, partIndex = chunkMeta.part;
            if (!(levels != null && levels[levelIndex])) {
              this.warn("Levels object was unset while buffering fragment " + sn + " of " + this.playlistLabel() + " " + levelIndex + ". The current chunk will not be buffered.");
              return null;
            }
            var level = levels[levelIndex];
            var levelDetails = level.details;
            var part = partIndex > -1 ? getPartWith(levelDetails, sn, partIndex) : null;
            var frag = part ? part.fragment : getFragmentWithSN(levelDetails, sn, fragCurrent);
            if (!frag) {
              return null;
            }
            if (fragCurrent && fragCurrent !== frag) {
              frag.stats = fragCurrent.stats;
            }
            return {
              frag,
              part,
              level
            };
          };
          _proto.bufferFragmentData = function bufferFragmentData(data, frag, part, chunkMeta, noBacktracking) {
            var _buffer;
            if (!data || this.state !== State.PARSING) {
              return;
            }
            var data1 = data.data1, data2 = data.data2;
            var buffer = data1;
            if (data1 && data2) {
              buffer = appendUint8Array(data1, data2);
            }
            if (!((_buffer = buffer) != null && _buffer.length)) {
              return;
            }
            var segment = {
              type: data.type,
              frag,
              part,
              chunkMeta,
              parent: frag.type,
              data: buffer
            };
            this.hls.trigger(Events.BUFFER_APPENDING, segment);
            if (data.dropped && data.independent && !part) {
              if (noBacktracking) {
                return;
              }
              this.flushBufferGap(frag);
            }
          };
          _proto.flushBufferGap = function flushBufferGap(frag) {
            var media = this.media;
            if (!media) {
              return;
            }
            if (!BufferHelper.isBuffered(media, media.currentTime)) {
              this.flushMainBuffer(0, frag.start);
              return;
            }
            var currentTime = media.currentTime;
            var bufferInfo = BufferHelper.bufferInfo(media, currentTime, 0);
            var fragDuration = frag.duration;
            var segmentFraction = Math.min(this.config.maxFragLookUpTolerance * 2, fragDuration * 0.25);
            var start = Math.max(Math.min(frag.start - segmentFraction, bufferInfo.end - segmentFraction), currentTime + segmentFraction);
            if (frag.start - start > segmentFraction) {
              this.flushMainBuffer(start, frag.start);
            }
          };
          _proto.getFwdBufferInfo = function getFwdBufferInfo(bufferable, type) {
            var _this$media2;
            var pos = this.getLoadPosition();
            if (!isFiniteNumber(pos)) {
              return null;
            }
            var backwardSeek = this.lastCurrentTime > pos;
            var maxBufferHole = backwardSeek || (_this$media2 = this.media) != null && _this$media2.paused ? 0 : this.config.maxBufferHole;
            return this.getFwdBufferInfoAtPos(bufferable, pos, type, maxBufferHole);
          };
          _proto.getFwdBufferInfoAtPos = function getFwdBufferInfoAtPos(bufferable, pos, type, maxBufferHole) {
            var bufferInfo = BufferHelper.bufferInfo(bufferable, pos, maxBufferHole);
            if (bufferInfo.len === 0 && bufferInfo.nextStart !== void 0) {
              var bufferedFragAtPos = this.fragmentTracker.getBufferedFrag(pos, type);
              if (bufferedFragAtPos && (bufferInfo.nextStart <= bufferedFragAtPos.end || bufferedFragAtPos.gap)) {
                var gapDuration = Math.max(Math.min(bufferInfo.nextStart, bufferedFragAtPos.end) - pos, maxBufferHole);
                return BufferHelper.bufferInfo(bufferable, pos, gapDuration);
              }
            }
            return bufferInfo;
          };
          _proto.getMaxBufferLength = function getMaxBufferLength(levelBitrate) {
            var config = this.config;
            var maxBufLen;
            if (levelBitrate) {
              maxBufLen = Math.max(8 * config.maxBufferSize / levelBitrate, config.maxBufferLength);
            } else {
              maxBufLen = config.maxBufferLength;
            }
            return Math.min(maxBufLen, config.maxMaxBufferLength);
          };
          _proto.reduceMaxBufferLength = function reduceMaxBufferLength(threshold, fragDuration) {
            var config = this.config;
            var minLength = Math.max(Math.min(threshold - fragDuration, config.maxBufferLength), fragDuration);
            var reducedLength = Math.max(threshold - fragDuration * 3, config.maxMaxBufferLength / 2, minLength);
            if (reducedLength >= minLength) {
              config.maxMaxBufferLength = reducedLength;
              this.warn("Reduce max buffer length to " + reducedLength + "s");
              return true;
            }
            return false;
          };
          _proto.getAppendedFrag = function getAppendedFrag(position, playlistType) {
            var _this$fragmentTracker;
            if (playlistType === void 0) {
              playlistType = PlaylistLevelType.MAIN;
            }
            var fragOrPart = (_this$fragmentTracker = this.fragmentTracker) == null ? void 0 : _this$fragmentTracker.getAppendedFrag(position, playlistType);
            if (fragOrPart && "fragment" in fragOrPart) {
              return fragOrPart.fragment;
            }
            return fragOrPart;
          };
          _proto.getNextFragment = function getNextFragment(pos, levelDetails) {
            var fragments = levelDetails.fragments;
            var fragLen = fragments.length;
            if (!fragLen) {
              return null;
            }
            var config = this.config;
            var start = fragments[0].start;
            var canLoadParts = config.lowLatencyMode && !!levelDetails.partList;
            var frag = null;
            if (levelDetails.live) {
              var initialLiveManifestSize = config.initialLiveManifestSize;
              if (fragLen < initialLiveManifestSize) {
                this.warn("Not enough fragments to start playback (have: " + fragLen + ", need: " + initialLiveManifestSize + ")");
                return null;
              }
              if (!levelDetails.PTSKnown && !this.startFragRequested && this.startPosition === -1 || pos < start) {
                var _frag;
                if (canLoadParts && !this.loadingParts) {
                  this.log("LL-Part loading ON for initial live fragment");
                  this.loadingParts = true;
                }
                frag = this.getInitialLiveFragment(levelDetails, fragments);
                var mainStart = this.hls.startPosition;
                var liveSyncPosition = this.hls.liveSyncPosition;
                var startPosition = frag ? (mainStart !== -1 && mainStart >= start ? mainStart : liveSyncPosition) || frag.start : pos;
                this.log("Setting startPosition to " + startPosition + " to match start frag at live edge. mainStart: " + mainStart + " liveSyncPosition: " + liveSyncPosition + " frag.start: " + ((_frag = frag) == null ? void 0 : _frag.start));
                this.startPosition = this.nextLoadPosition = startPosition;
              }
            } else if (pos <= start) {
              frag = fragments[0];
            }
            if (!frag) {
              var end = this.loadingParts ? levelDetails.partEnd : levelDetails.fragmentEnd;
              frag = this.getFragmentAtPosition(pos, end, levelDetails);
            }
            var programFrag = this.filterReplacedPrimary(frag, levelDetails);
            if (!programFrag && frag) {
              var curSNIdx = frag.sn - levelDetails.startSN;
              programFrag = this.filterReplacedPrimary(fragments[curSNIdx + 1] || null, levelDetails);
            }
            return this.mapToInitFragWhenRequired(programFrag);
          };
          _proto.isLoopLoading = function isLoopLoading(frag, targetBufferTime) {
            var trackerState = this.fragmentTracker.getState(frag);
            return (trackerState === FragmentState.OK || trackerState === FragmentState.PARTIAL && !!frag.gap) && this.nextLoadPosition > targetBufferTime;
          };
          _proto.getNextFragmentLoopLoading = function getNextFragmentLoopLoading(frag, levelDetails, bufferInfo, playlistType, maxBufLen) {
            var nextFragment = null;
            if (frag.gap) {
              nextFragment = this.getNextFragment(this.nextLoadPosition, levelDetails);
              if (nextFragment && !nextFragment.gap && bufferInfo.nextStart) {
                var nextbufferInfo = this.getFwdBufferInfoAtPos(this.mediaBuffer ? this.mediaBuffer : this.media, bufferInfo.nextStart, playlistType, 0);
                if (nextbufferInfo !== null && bufferInfo.len + nextbufferInfo.len >= maxBufLen) {
                  var sn = nextFragment.sn;
                  if (this.loopSn !== sn) {
                    this.log('buffer full after gaps in "' + playlistType + '" playlist starting at sn: ' + sn);
                    this.loopSn = sn;
                  }
                  return null;
                }
              }
            }
            this.loopSn = void 0;
            return nextFragment;
          };
          _proto.filterReplacedPrimary = function filterReplacedPrimary(frag, details) {
            if (!frag) {
              return frag;
            }
            if (interstitialsEnabled(this.hls.config)) ;
            return frag;
          };
          _proto.mapToInitFragWhenRequired = function mapToInitFragWhenRequired(frag) {
            if (frag != null && frag.initSegment && !(frag != null && frag.initSegment.data) && !this.bitrateTest) {
              return frag.initSegment;
            }
            return frag;
          };
          _proto.getNextPart = function getNextPart(partList, frag, targetBufferTime) {
            var nextPart = -1;
            var contiguous = false;
            var independentAttrOmitted = true;
            for (var i = 0, len = partList.length; i < len; i++) {
              var part = partList[i];
              independentAttrOmitted = independentAttrOmitted && !part.independent;
              if (nextPart > -1 && targetBufferTime < part.start) {
                break;
              }
              var loaded = part.loaded;
              if (loaded) {
                nextPart = -1;
              } else if ((contiguous || part.independent || independentAttrOmitted) && part.fragment === frag) {
                nextPart = i;
              }
              contiguous = loaded;
            }
            return nextPart;
          };
          _proto.loadedEndOfParts = function loadedEndOfParts(partList, targetBufferTime) {
            var lastPart = partList[partList.length - 1];
            return lastPart && targetBufferTime > lastPart.start && lastPart.loaded;
          };
          _proto.getInitialLiveFragment = function getInitialLiveFragment(levelDetails, fragments) {
            var fragPrevious = this.fragPrevious;
            var frag = null;
            if (fragPrevious) {
              if (levelDetails.hasProgramDateTime) {
                this.log("Live playlist, switching playlist, load frag with same PDT: " + fragPrevious.programDateTime);
                frag = findFragmentByPDT(fragments, fragPrevious.endProgramDateTime, this.config.maxFragLookUpTolerance);
              }
              if (!frag) {
                var targetSN = fragPrevious.sn + 1;
                if (targetSN >= levelDetails.startSN && targetSN <= levelDetails.endSN) {
                  var fragNext = fragments[targetSN - levelDetails.startSN];
                  if (fragPrevious.cc === fragNext.cc) {
                    frag = fragNext;
                    this.log("Live playlist, switching playlist, load frag with next SN: " + frag.sn);
                  }
                }
                if (!frag) {
                  frag = findFragWithCC(fragments, fragPrevious.cc);
                  if (frag) {
                    this.log("Live playlist, switching playlist, load frag with same CC: " + frag.sn);
                  }
                }
              }
            } else {
              var liveStart = this.hls.liveSyncPosition;
              if (liveStart !== null) {
                frag = this.getFragmentAtPosition(liveStart, this.bitrateTest ? levelDetails.fragmentEnd : levelDetails.edge, levelDetails);
              }
            }
            return frag;
          };
          _proto.getFragmentAtPosition = function getFragmentAtPosition(bufferEnd, end, levelDetails) {
            var config = this.config;
            var fragPrevious = this.fragPrevious;
            var fragments = levelDetails.fragments, endSN = levelDetails.endSN;
            var fragmentHint = levelDetails.fragmentHint;
            var maxFragLookUpTolerance = config.maxFragLookUpTolerance;
            var partList = levelDetails.partList;
            var loadingParts = !!(this.loadingParts && partList != null && partList.length && fragmentHint);
            if (loadingParts && fragmentHint && !this.bitrateTest && partList[partList.length - 1].fragment.sn === fragmentHint.sn) {
              fragments = fragments.concat(fragmentHint);
              endSN = fragmentHint.sn;
            }
            var frag;
            if (bufferEnd < end) {
              var _this$media3;
              var backwardSeek = bufferEnd < this.lastCurrentTime;
              var lookupTolerance = backwardSeek || bufferEnd > end - maxFragLookUpTolerance || (_this$media3 = this.media) != null && _this$media3.paused || !this.startFragRequested ? 0 : maxFragLookUpTolerance;
              frag = findFragmentByPTS(fragPrevious, fragments, bufferEnd, lookupTolerance);
            } else {
              frag = fragments[fragments.length - 1];
            }
            if (frag) {
              var curSNIdx = frag.sn - levelDetails.startSN;
              var fragState = this.fragmentTracker.getState(frag);
              if (fragState === FragmentState.OK || fragState === FragmentState.PARTIAL && frag.gap) {
                fragPrevious = frag;
              }
              if (fragPrevious && frag.sn === fragPrevious.sn && (!loadingParts || partList[0].fragment.sn > frag.sn || !levelDetails.live && !loadingParts)) {
                var sameLevel = fragPrevious && frag.level === fragPrevious.level;
                if (sameLevel) {
                  var nextFrag = fragments[curSNIdx + 1];
                  if (frag.sn < endSN && this.fragmentTracker.getState(nextFrag) !== FragmentState.OK) {
                    frag = nextFrag;
                  } else {
                    frag = null;
                  }
                }
              }
            }
            return frag;
          };
          _proto.alignPlaylists = function alignPlaylists(details, previousDetails, switchDetails) {
            var length = details.fragments.length;
            if (!length) {
              this.warn("No fragments in live playlist");
              return 0;
            }
            var slidingStart = details.fragmentStart;
            var firstLevelLoad = !previousDetails;
            var aligned = details.alignedSliding && isFiniteNumber(slidingStart);
            if (firstLevelLoad || !aligned && !slidingStart) {
              alignStream(switchDetails, details);
              var alignedSlidingStart = details.fragmentStart;
              this.log("Live playlist sliding: " + alignedSlidingStart.toFixed(2) + " start-sn: " + (previousDetails ? previousDetails.startSN : "na") + "->" + details.startSN + " fragments: " + length);
              return alignedSlidingStart;
            }
            return slidingStart;
          };
          _proto.waitForCdnTuneIn = function waitForCdnTuneIn(details) {
            var advancePartLimit = 3;
            return details.live && details.canBlockReload && details.partTarget && details.tuneInGoal > Math.max(details.partHoldBack, details.partTarget * advancePartLimit);
          };
          _proto.setStartPosition = function setStartPosition(details, sliding) {
            var startPosition = this.startPosition;
            if (startPosition < sliding) {
              startPosition = -1;
            }
            var timelineOffset = this.timelineOffset;
            if (startPosition === -1) {
              var offsetInMultivariantPlaylist = this.startTimeOffset !== null;
              var startTimeOffset = offsetInMultivariantPlaylist ? this.startTimeOffset : details.startTimeOffset;
              if (startTimeOffset !== null && isFiniteNumber(startTimeOffset)) {
                startPosition = sliding + startTimeOffset;
                if (startTimeOffset < 0) {
                  startPosition += details.edge;
                }
                startPosition = Math.min(Math.max(sliding, startPosition), sliding + details.totalduration);
                this.log("Setting startPosition to " + startPosition + " for start time offset " + startTimeOffset + " found in " + (offsetInMultivariantPlaylist ? "multivariant" : "media") + " playlist");
                this.startPosition = startPosition;
              } else if (details.live) {
                startPosition = this.hls.liveSyncPosition || sliding;
                this.log("Setting startPosition to -1 to start at live edge " + startPosition);
                this.startPosition = -1;
              } else {
                this.log("setting startPosition to 0 by default");
                this.startPosition = startPosition = 0;
              }
              this.lastCurrentTime = startPosition + timelineOffset;
            }
            this.nextLoadPosition = startPosition + timelineOffset;
          };
          _proto.getLoadPosition = function getLoadPosition() {
            var _this$hls;
            var media = this.media;
            var pos = 0;
            if ((_this$hls = this.hls) != null && _this$hls.hasEnoughToStart && media) {
              pos = media.currentTime;
            } else if (this.nextLoadPosition >= 0) {
              pos = this.nextLoadPosition;
            }
            return pos;
          };
          _proto.handleFragLoadAborted = function handleFragLoadAborted(frag, part) {
            if (this.transmuxer && frag.type === this.playlistType && isMediaFragment(frag) && frag.stats.aborted) {
              this.warn("Fragment " + frag.sn + (part ? " part " + part.index : "") + " of " + this.playlistLabel() + " " + frag.level + " was aborted");
              this.resetFragmentLoading(frag);
            }
          };
          _proto.resetFragmentLoading = function resetFragmentLoading(frag) {
            if (!this.fragCurrent || !this.fragContextChanged(frag) && this.state !== State.FRAG_LOADING_WAITING_RETRY) {
              this.state = State.IDLE;
            }
          };
          _proto.onFragmentOrKeyLoadError = function onFragmentOrKeyLoadError(filterType, data) {
            if (data.chunkMeta && !data.frag) {
              var context = this.getCurrentContext(data.chunkMeta);
              if (context) {
                data.frag = context.frag;
              }
            }
            var frag = data.frag;
            if (!frag || frag.type !== filterType || !this.levels) {
              return;
            }
            if (this.fragContextChanged(frag)) {
              var _this$fragCurrent;
              this.warn("Frag load error must match current frag to retry " + frag.url + " > " + ((_this$fragCurrent = this.fragCurrent) == null ? void 0 : _this$fragCurrent.url));
              return;
            }
            var gapTagEncountered = data.details === ErrorDetails.FRAG_GAP;
            if (gapTagEncountered) {
              this.fragmentTracker.fragBuffered(frag, true);
            }
            var errorAction = data.errorAction;
            var _ref2 = errorAction || {}, action = _ref2.action, flags = _ref2.flags, _ref2$retryCount = _ref2.retryCount, retryCount = _ref2$retryCount === void 0 ? 0 : _ref2$retryCount, retryConfig = _ref2.retryConfig;
            var couldRetry = !!errorAction && !!retryConfig;
            var retry = couldRetry && action === NetworkErrorAction.RetryRequest;
            var noAlternate = couldRetry && !errorAction.resolved && flags === ErrorActionFlags.MoveAllAlternatesMatchingHost;
            if (!retry && noAlternate && isMediaFragment(frag) && !frag.endList) {
              this.resetFragmentErrors(filterType);
              this.treatAsGap(frag);
              errorAction.resolved = true;
            } else if ((retry || noAlternate) && retryCount < retryConfig.maxNumRetry) {
              this.resetStartWhenNotLoaded(this.levelLastLoaded);
              var delay = getRetryDelay(retryConfig, retryCount);
              this.warn("Fragment " + frag.sn + " of " + filterType + " " + frag.level + " errored with " + data.details + ", retrying loading " + (retryCount + 1) + "/" + retryConfig.maxNumRetry + " in " + delay + "ms");
              errorAction.resolved = true;
              this.retryDate = self.performance.now() + delay;
              this.state = State.FRAG_LOADING_WAITING_RETRY;
            } else if (retryConfig && errorAction) {
              this.resetFragmentErrors(filterType);
              if (retryCount < retryConfig.maxNumRetry) {
                if (!gapTagEncountered && action !== NetworkErrorAction.RemoveAlternatePermanently) {
                  errorAction.resolved = true;
                }
              } else {
                this.warn(data.details + " reached or exceeded max retry (" + retryCount + ")");
                return;
              }
            } else if (action === NetworkErrorAction.SendAlternateToPenaltyBox) {
              this.state = State.WAITING_LEVEL;
            } else {
              this.state = State.ERROR;
            }
            this.tickImmediate();
          };
          _proto.reduceLengthAndFlushBuffer = function reduceLengthAndFlushBuffer(data) {
            if (this.state === State.PARSING || this.state === State.PARSED) {
              var frag = data.frag;
              var playlistType = data.parent;
              var bufferedInfo = this.getFwdBufferInfo(this.mediaBuffer, playlistType);
              var buffered = bufferedInfo && bufferedInfo.len > 0.5;
              if (buffered) {
                this.reduceMaxBufferLength(bufferedInfo.len, (frag == null ? void 0 : frag.duration) || 10);
              }
              var flushBuffer = !buffered;
              if (flushBuffer) {
                this.warn("Buffer full error while media.currentTime is not buffered, flush " + playlistType + " buffer");
              }
              if (frag) {
                this.fragmentTracker.removeFragment(frag);
                this.nextLoadPosition = frag.start;
              }
              this.resetLoadingState();
              return flushBuffer;
            }
            return false;
          };
          _proto.resetFragmentErrors = function resetFragmentErrors(filterType) {
            if (filterType === PlaylistLevelType.AUDIO) {
              this.fragCurrent = null;
            }
            if (!this.hls.hasEnoughToStart) {
              this.startFragRequested = false;
            }
            if (this.state !== State.STOPPED) {
              this.state = State.IDLE;
            }
          };
          _proto.afterBufferFlushed = function afterBufferFlushed(media, bufferType, playlistType) {
            if (!media) {
              return;
            }
            var bufferedTimeRanges = BufferHelper.getBuffered(media);
            this.fragmentTracker.detectEvictedFragments(bufferType, bufferedTimeRanges, playlistType);
            if (this.state === State.ENDED) {
              this.resetLoadingState();
            }
          };
          _proto.resetLoadingState = function resetLoadingState() {
            this.log("Reset loading state");
            this.fragCurrent = null;
            this.fragPrevious = null;
            if (this.state !== State.STOPPED) {
              this.state = State.IDLE;
            }
          };
          _proto.resetStartWhenNotLoaded = function resetStartWhenNotLoaded(level) {
            if (!this.hls.hasEnoughToStart) {
              this.startFragRequested = false;
              var details = level ? level.details : null;
              if (details != null && details.live) {
                this.log("resetting startPosition for live start");
                this.startPosition = -1;
                this.setStartPosition(details, details.fragmentStart);
                this.resetLoadingState();
              } else {
                this.nextLoadPosition = this.startPosition;
              }
            }
          };
          _proto.resetWhenMissingContext = function resetWhenMissingContext(chunkMeta) {
            this.warn("The loading context changed while buffering fragment " + chunkMeta.sn + " of " + this.playlistLabel() + " " + chunkMeta.level + ". This chunk will not be buffered.");
            this.removeUnbufferedFrags();
            this.resetStartWhenNotLoaded(this.levelLastLoaded);
            this.resetLoadingState();
          };
          _proto.removeUnbufferedFrags = function removeUnbufferedFrags(start) {
            if (start === void 0) {
              start = 0;
            }
            this.fragmentTracker.removeFragmentsInRange(start, Infinity, this.playlistType, false, true);
          };
          _proto.updateLevelTiming = function updateLevelTiming(frag, part, level, partial) {
            var _this7 = this;
            var details = level.details;
            if (!details) {
              this.warn("level.details undefined");
              return;
            }
            var parsed = Object.keys(frag.elementaryStreams).reduce(function(result, type) {
              var info = frag.elementaryStreams[type];
              if (info) {
                var parsedDuration = info.endPTS - info.startPTS;
                if (parsedDuration <= 0) {
                  _this7.warn("Could not parse fragment " + frag.sn + " " + type + " duration reliably (" + parsedDuration + ")");
                  return result || false;
                }
                var drift = partial ? 0 : updateFragPTSDTS(details, frag, info.startPTS, info.endPTS, info.startDTS, info.endDTS);
                _this7.hls.trigger(Events.LEVEL_PTS_UPDATED, {
                  details,
                  level,
                  drift,
                  type,
                  frag,
                  start: info.startPTS,
                  end: info.endPTS
                });
                return true;
              }
              return result;
            }, false);
            if (!parsed) {
              var _this$transmuxer;
              if (level.fragmentError === 0) {
                this.treatAsGap(frag, level);
              }
              if (((_this$transmuxer = this.transmuxer) == null ? void 0 : _this$transmuxer.error) === null) {
                var error = new Error("Found no media in fragment " + frag.sn + " of " + this.playlistLabel() + " " + frag.level + " resetting transmuxer to fallback to playlist timing");
                this.warn(error.message);
                this.hls.trigger(Events.ERROR, {
                  type: ErrorTypes.MEDIA_ERROR,
                  details: ErrorDetails.FRAG_PARSING_ERROR,
                  fatal: false,
                  error,
                  frag,
                  reason: "Found no media in msn " + frag.sn + " of " + this.playlistLabel() + ' "' + level.url + '"'
                });
                if (!this.hls) {
                  return;
                }
                this.resetTransmuxer();
              }
            }
            this.state = State.PARSED;
            this.log("Parsed " + frag.type + " sn: " + frag.sn + (part ? " part: " + part.index : "") + " of " + this.fragInfo(frag, false, part) + ")");
            this.hls.trigger(Events.FRAG_PARSED, {
              frag,
              part
            });
          };
          _proto.playlistLabel = function playlistLabel() {
            return this.playlistType === PlaylistLevelType.MAIN ? "level" : "track";
          };
          _proto.fragInfo = function fragInfo(frag, pts, part) {
            var _ref3, _ref4;
            if (pts === void 0) {
              pts = true;
            }
            return this.playlistLabel() + " " + frag.level + " (" + (part ? "part" : "frag") + ":[" + ((_ref3 = pts && !part ? frag.startPTS : (part || frag).start) != null ? _ref3 : NaN).toFixed(3) + "-" + ((_ref4 = pts && !part ? frag.endPTS : (part || frag).end) != null ? _ref4 : NaN).toFixed(3) + "]" + (part && frag.type === "main" ? "INDEPENDENT=" + (part.independent ? "YES" : "NO") : "");
          };
          _proto.treatAsGap = function treatAsGap(frag, level) {
            if (level) {
              level.fragmentError++;
            }
            frag.gap = true;
            this.fragmentTracker.removeFragment(frag);
            this.fragmentTracker.fragBuffered(frag, true);
          };
          _proto.resetTransmuxer = function resetTransmuxer() {
            var _this$transmuxer2;
            (_this$transmuxer2 = this.transmuxer) == null ? void 0 : _this$transmuxer2.reset();
          };
          _proto.recoverWorkerError = function recoverWorkerError(data) {
            if (data.event === "demuxerWorker") {
              this.fragmentTracker.removeAllFragments();
              if (this.transmuxer) {
                this.transmuxer.destroy();
                this.transmuxer = null;
              }
              this.resetStartWhenNotLoaded(this.levelLastLoaded);
              this.resetLoadingState();
            }
          };
          return _createClass4(BaseStreamController2, [{
            key: "startPositionValue",
            get: function get() {
              var nextLoadPosition = this.nextLoadPosition, startPosition = this.startPosition;
              if (startPosition === -1 && nextLoadPosition) {
                return nextLoadPosition;
              }
              return startPosition;
            }
          }, {
            key: "bufferingEnabled",
            get: function get() {
              return this.buffering;
            }
          }, {
            key: "inFlightFrag",
            get: function get() {
              return {
                frag: this.fragCurrent,
                state: this.state
              };
            }
          }, {
            key: "timelineOffset",
            get: function get() {
              var configuredTimelineOffset = this.config.timelineOffset;
              if (configuredTimelineOffset) {
                var _this$getLevelDetails;
                return ((_this$getLevelDetails = this.getLevelDetails()) == null ? void 0 : _this$getLevelDetails.appliedTimelineOffset) || configuredTimelineOffset;
              }
              return 0;
            }
          }, {
            key: "primaryPrefetch",
            get: function get() {
              if (interstitialsEnabled(this.hls.config)) ;
              return false;
            }
          }, {
            key: "state",
            get: function get() {
              return this._state;
            },
            set: function set(nextState) {
              var previousState = this._state;
              if (previousState !== nextState) {
                this._state = nextState;
                this.log(previousState + "->" + nextState);
              }
            }
          }]);
        }(TaskLoop);
        function interstitialsEnabled(config) {
          return false;
        }
        function addEventListener(el, type, listener) {
          removeEventListener(el, type, listener);
          el.addEventListener(type, listener);
        }
        function removeEventListener(el, type, listener) {
          el.removeEventListener(type, listener);
        }
        var MAX_START_GAP_JUMP = 2;
        var SKIP_BUFFER_HOLE_STEP_SECONDS = 0.1;
        var SKIP_BUFFER_RANGE_START = 0.05;
        var TICK_INTERVAL$1 = 100;
        var GapController = /* @__PURE__ */ function(_TaskLoop) {
          function GapController2(hls, fragmentTracker) {
            var _this;
            _this = _TaskLoop.call(this, "gap-controller", hls.logger) || this;
            _this.hls = null;
            _this.fragmentTracker = null;
            _this.media = null;
            _this.mediaSource = void 0;
            _this.nudgeRetry = 0;
            _this.stallReported = false;
            _this.stalled = null;
            _this.moved = false;
            _this.seeking = false;
            _this.buffered = {};
            _this.lastCurrentTime = 0;
            _this.ended = 0;
            _this.waiting = 0;
            _this.onMediaPlaying = function() {
              _this.ended = 0;
              _this.waiting = 0;
            };
            _this.onMediaWaiting = function() {
              var _this$media;
              if ((_this$media = _this.media) != null && _this$media.seeking) {
                return;
              }
              _this.waiting = self.performance.now();
              _this.tick();
            };
            _this.onMediaEnded = function() {
              if (_this.hls) {
                var _this$media2;
                _this.ended = ((_this$media2 = _this.media) == null ? void 0 : _this$media2.currentTime) || 1;
                _this.hls.trigger(Events.MEDIA_ENDED, {
                  stalled: false
                });
              }
            };
            _this.hls = hls;
            _this.fragmentTracker = fragmentTracker;
            _this.registerListeners();
            return _this;
          }
          _inheritsLoose(GapController2, _TaskLoop);
          var _proto = GapController2.prototype;
          _proto.registerListeners = function registerListeners() {
            var hls = this.hls;
            if (hls) {
              hls.on(Events.MEDIA_ATTACHED, this.onMediaAttached, this);
              hls.on(Events.MEDIA_DETACHING, this.onMediaDetaching, this);
              hls.on(Events.BUFFER_APPENDED, this.onBufferAppended, this);
            }
          };
          _proto.unregisterListeners = function unregisterListeners() {
            var hls = this.hls;
            if (hls) {
              hls.off(Events.MEDIA_ATTACHED, this.onMediaAttached, this);
              hls.off(Events.MEDIA_DETACHING, this.onMediaDetaching, this);
              hls.off(Events.BUFFER_APPENDED, this.onBufferAppended, this);
            }
          };
          _proto.destroy = function destroy() {
            _TaskLoop.prototype.destroy.call(this);
            this.unregisterListeners();
            this.media = this.hls = this.fragmentTracker = null;
            this.mediaSource = void 0;
          };
          _proto.onMediaAttached = function onMediaAttached(event, data) {
            this.setInterval(TICK_INTERVAL$1);
            this.mediaSource = data.mediaSource;
            var media = this.media = data.media;
            addEventListener(media, "playing", this.onMediaPlaying);
            addEventListener(media, "waiting", this.onMediaWaiting);
            addEventListener(media, "ended", this.onMediaEnded);
          };
          _proto.onMediaDetaching = function onMediaDetaching(event, data) {
            this.clearInterval();
            var media = this.media;
            if (media) {
              removeEventListener(media, "playing", this.onMediaPlaying);
              removeEventListener(media, "waiting", this.onMediaWaiting);
              removeEventListener(media, "ended", this.onMediaEnded);
              this.media = null;
            }
            this.mediaSource = void 0;
          };
          _proto.onBufferAppended = function onBufferAppended(event, data) {
            this.buffered = data.timeRanges;
          };
          _proto.tick = function tick() {
            var _this$media3;
            if (!((_this$media3 = this.media) != null && _this$media3.readyState) || !this.hasBuffered) {
              return;
            }
            var currentTime = this.media.currentTime;
            this.poll(currentTime, this.lastCurrentTime);
            this.lastCurrentTime = currentTime;
          };
          _proto.poll = function poll(currentTime, lastCurrentTime) {
            var _this$hls, _this$hls2;
            var config = (_this$hls = this.hls) == null ? void 0 : _this$hls.config;
            if (!config) {
              return;
            }
            var media = this.media, stalled = this.stalled;
            if (!media) {
              return;
            }
            var seeking = media.seeking;
            var seeked = this.seeking && !seeking;
            var beginSeek = !this.seeking && seeking;
            var pausedEndedOrHalted = media.paused && !seeking || media.ended || media.playbackRate === 0;
            this.seeking = seeking;
            if (currentTime !== lastCurrentTime) {
              if (lastCurrentTime) {
                this.ended = 0;
              }
              this.moved = true;
              if (!seeking) {
                this.nudgeRetry = 0;
                if (config.nudgeOnVideoHole && !pausedEndedOrHalted && currentTime > lastCurrentTime) {
                  this.nudgeOnVideoHole(currentTime, lastCurrentTime);
                }
              }
              if (this.waiting === 0) {
                this.stallResolved(currentTime);
              }
              return;
            }
            if (beginSeek || seeked) {
              if (seeked) {
                this.stallResolved(currentTime);
              }
              return;
            }
            if (pausedEndedOrHalted) {
              this.nudgeRetry = 0;
              this.stallResolved(currentTime);
              if (!this.ended && media.ended && this.hls) {
                this.ended = currentTime || 1;
                this.hls.trigger(Events.MEDIA_ENDED, {
                  stalled: false
                });
              }
              return;
            }
            if (!BufferHelper.getBuffered(media).length) {
              this.nudgeRetry = 0;
              return;
            }
            var bufferInfo = BufferHelper.bufferInfo(media, currentTime, 0);
            var nextStart = bufferInfo.nextStart || 0;
            var fragmentTracker = this.fragmentTracker;
            if (seeking && fragmentTracker && this.hls) {
              var inFlightDependency = getInFlightDependency(this.hls.inFlightFragments, currentTime);
              var hasEnoughBuffer = bufferInfo.len > MAX_START_GAP_JUMP;
              var noBufferHole = !nextStart || inFlightDependency || nextStart - currentTime > MAX_START_GAP_JUMP && !fragmentTracker.getPartialFragment(currentTime);
              if (hasEnoughBuffer || noBufferHole) {
                return;
              }
              this.moved = false;
            }
            var levelDetails = (_this$hls2 = this.hls) == null ? void 0 : _this$hls2.latestLevelDetails;
            if (!this.moved && this.stalled !== null && fragmentTracker) {
              var isBuffered = bufferInfo.len > 0;
              if (!isBuffered && !nextStart) {
                return;
              }
              var startJump = Math.max(nextStart, bufferInfo.start || 0) - currentTime;
              var isLive = !!(levelDetails != null && levelDetails.live);
              var maxStartGapJump = isLive ? levelDetails.targetduration * 2 : MAX_START_GAP_JUMP;
              var partialOrGap = fragmentTracker.getPartialFragment(currentTime);
              if (startJump > 0 && (startJump <= maxStartGapJump || partialOrGap)) {
                if (!media.paused) {
                  this._trySkipBufferHole(partialOrGap);
                }
                return;
              }
            }
            var detectStallWithCurrentTimeMs = config.detectStallWithCurrentTimeMs;
            var tnow = self.performance.now();
            var tWaiting = this.waiting;
            if (stalled === null) {
              if (tWaiting > 0 && tnow - tWaiting < detectStallWithCurrentTimeMs) {
                this.stalled = tWaiting;
              } else {
                this.stalled = tnow;
              }
              return;
            }
            var stalledDuration = tnow - stalled;
            if (!seeking && (stalledDuration >= detectStallWithCurrentTimeMs || tWaiting) && this.hls) {
              var _this$mediaSource;
              if (((_this$mediaSource = this.mediaSource) == null ? void 0 : _this$mediaSource.readyState) === "ended" && !(levelDetails != null && levelDetails.live) && Math.abs(currentTime - ((levelDetails == null ? void 0 : levelDetails.edge) || 0)) < 1) {
                if (this.ended) {
                  return;
                }
                this.ended = currentTime || 1;
                this.hls.trigger(Events.MEDIA_ENDED, {
                  stalled: true
                });
                return;
              }
              this._reportStall(bufferInfo);
              if (!this.media || !this.hls) {
                return;
              }
            }
            var bufferedWithHoles = BufferHelper.bufferInfo(media, currentTime, config.maxBufferHole);
            this._tryFixBufferStall(bufferedWithHoles, stalledDuration);
          };
          _proto.stallResolved = function stallResolved(currentTime) {
            var stalled = this.stalled;
            if (stalled && this.hls) {
              this.stalled = null;
              if (this.stallReported) {
                var stalledDuration = self.performance.now() - stalled;
                this.log("playback not stuck anymore @" + currentTime + ", after " + Math.round(stalledDuration) + "ms");
                this.stallReported = false;
                this.waiting = 0;
                this.hls.trigger(Events.STALL_RESOLVED, {});
              }
            }
          };
          _proto.nudgeOnVideoHole = function nudgeOnVideoHole(currentTime, lastCurrentTime) {
            var _this$buffered$audio;
            var videoSourceBuffered = this.buffered.video;
            if (this.hls && this.media && this.fragmentTracker && (_this$buffered$audio = this.buffered.audio) != null && _this$buffered$audio.length && videoSourceBuffered && videoSourceBuffered.length > 1 && currentTime > videoSourceBuffered.end(0)) {
              var audioBufferInfo = BufferHelper.bufferedInfo(BufferHelper.timeRangesToArray(this.buffered.audio), currentTime, 0);
              if (audioBufferInfo.len > 1 && lastCurrentTime >= audioBufferInfo.start) {
                var videoTimes = BufferHelper.timeRangesToArray(videoSourceBuffered);
                var lastBufferedIndex = BufferHelper.bufferedInfo(videoTimes, lastCurrentTime, 0).bufferedIndex;
                if (lastBufferedIndex > -1 && lastBufferedIndex < videoTimes.length - 1) {
                  var bufferedIndex = BufferHelper.bufferedInfo(videoTimes, currentTime, 0).bufferedIndex;
                  var holeStart = videoTimes[lastBufferedIndex].end;
                  var holeEnd = videoTimes[lastBufferedIndex + 1].start;
                  if ((bufferedIndex === -1 || bufferedIndex > lastBufferedIndex) && holeEnd - holeStart < 1 && // `maxBufferHole` may be too small and setting it to 0 should not disable this feature
                  currentTime - holeStart < 2) {
                    var error = new Error("nudging playhead to flush pipeline after video hole. currentTime: " + currentTime + " hole: " + holeStart + " -> " + holeEnd + " buffered index: " + bufferedIndex);
                    this.warn(error.message);
                    this.media.currentTime += 1e-6;
                    var frag = this.fragmentTracker.getPartialFragment(currentTime) || void 0;
                    var bufferInfo = BufferHelper.bufferInfo(this.media, currentTime, 0);
                    this.hls.trigger(Events.ERROR, {
                      type: ErrorTypes.MEDIA_ERROR,
                      details: ErrorDetails.BUFFER_SEEK_OVER_HOLE,
                      fatal: false,
                      error,
                      reason: error.message,
                      frag,
                      buffer: bufferInfo.len,
                      bufferInfo
                    });
                  }
                }
              }
            }
          };
          _proto._tryFixBufferStall = function _tryFixBufferStall(bufferInfo, stalledDurationMs) {
            var _this$hls3, _this$hls4;
            var fragmentTracker = this.fragmentTracker, media = this.media;
            var config = (_this$hls3 = this.hls) == null ? void 0 : _this$hls3.config;
            if (!media || !fragmentTracker || !config) {
              return;
            }
            var currentTime = media.currentTime;
            var levelDetails = (_this$hls4 = this.hls) == null ? void 0 : _this$hls4.latestLevelDetails;
            var partial = fragmentTracker.getPartialFragment(currentTime);
            if (partial || levelDetails != null && levelDetails.live && currentTime < levelDetails.fragmentStart) {
              var targetTime = this._trySkipBufferHole(partial);
              if (targetTime || !this.media) {
                return;
              }
            }
            var bufferedRanges = bufferInfo.buffered;
            if ((bufferedRanges && bufferedRanges.length > 1 && bufferInfo.len > config.maxBufferHole || bufferInfo.nextStart && bufferInfo.nextStart - currentTime < config.maxBufferHole) && (stalledDurationMs > config.highBufferWatchdogPeriod * 1e3 || this.waiting)) {
              this.warn("Trying to nudge playhead over buffer-hole");
              this._tryNudgeBuffer(bufferInfo);
            }
          };
          _proto._reportStall = function _reportStall(bufferInfo) {
            var hls = this.hls, media = this.media, stallReported = this.stallReported, stalled = this.stalled;
            if (!stallReported && stalled !== null && media && hls) {
              this.stallReported = true;
              var error = new Error("Playback stalling at @" + media.currentTime + " due to low buffer (" + stringify2(bufferInfo) + ")");
              this.warn(error.message);
              hls.trigger(Events.ERROR, {
                type: ErrorTypes.MEDIA_ERROR,
                details: ErrorDetails.BUFFER_STALLED_ERROR,
                fatal: false,
                error,
                buffer: bufferInfo.len,
                bufferInfo,
                stalled: {
                  start: stalled
                }
              });
            }
          };
          _proto._trySkipBufferHole = function _trySkipBufferHole(partial) {
            var _this$hls5;
            var fragmentTracker = this.fragmentTracker, media = this.media;
            var config = (_this$hls5 = this.hls) == null ? void 0 : _this$hls5.config;
            if (!media || !fragmentTracker || !config) {
              return 0;
            }
            var currentTime = media.currentTime;
            var bufferInfo = BufferHelper.bufferInfo(media, currentTime, 0);
            var startTime = currentTime < bufferInfo.start ? bufferInfo.start : bufferInfo.nextStart;
            if (startTime && this.hls) {
              var bufferStarved = bufferInfo.len <= config.maxBufferHole;
              var waiting = bufferInfo.len > 0 && bufferInfo.len < 1 && media.readyState < 3;
              var gapLength = startTime - currentTime;
              if (gapLength > 0 && (bufferStarved || waiting)) {
                if (gapLength > config.maxBufferHole) {
                  var startGap = false;
                  if (currentTime === 0) {
                    var startFrag = fragmentTracker.getAppendedFrag(0, PlaylistLevelType.MAIN);
                    if (startFrag && startTime < startFrag.end) {
                      startGap = true;
                    }
                  }
                  if (!startGap) {
                    var startProvisioned = partial || fragmentTracker.getAppendedFrag(currentTime, PlaylistLevelType.MAIN);
                    if (startProvisioned) {
                      var _this$hls$loadLevelOb;
                      if (!((_this$hls$loadLevelOb = this.hls.loadLevelObj) != null && _this$hls$loadLevelOb.details)) {
                        return 0;
                      }
                      var inFlightDependency = getInFlightDependency(this.hls.inFlightFragments, startTime);
                      if (inFlightDependency) {
                        return 0;
                      }
                      var moreToLoad = false;
                      var pos = startProvisioned.end;
                      while (pos < startTime) {
                        var provisioned = fragmentTracker.getPartialFragment(pos);
                        if (provisioned) {
                          pos += provisioned.duration;
                        } else {
                          moreToLoad = true;
                          break;
                        }
                      }
                      if (moreToLoad) {
                        return 0;
                      }
                    }
                  }
                }
                var targetTime = Math.max(startTime + SKIP_BUFFER_RANGE_START, currentTime + SKIP_BUFFER_HOLE_STEP_SECONDS);
                this.warn("skipping hole, adjusting currentTime from " + currentTime + " to " + targetTime);
                this.moved = true;
                media.currentTime = targetTime;
                if (!(partial != null && partial.gap)) {
                  var error = new Error("fragment loaded with buffer holes, seeking from " + currentTime + " to " + targetTime);
                  this.hls.trigger(Events.ERROR, {
                    type: ErrorTypes.MEDIA_ERROR,
                    details: ErrorDetails.BUFFER_SEEK_OVER_HOLE,
                    fatal: false,
                    error,
                    reason: error.message,
                    frag: partial || void 0,
                    buffer: bufferInfo.len,
                    bufferInfo
                  });
                }
                return targetTime;
              }
            }
            return 0;
          };
          _proto._tryNudgeBuffer = function _tryNudgeBuffer(bufferInfo) {
            var hls = this.hls, media = this.media, nudgeRetry = this.nudgeRetry;
            var config = hls == null ? void 0 : hls.config;
            if (!media || !config) {
              return 0;
            }
            var currentTime = media.currentTime;
            this.nudgeRetry++;
            if (nudgeRetry < config.nudgeMaxRetry) {
              var targetTime = currentTime + (nudgeRetry + 1) * config.nudgeOffset;
              var error = new Error("Nudging 'currentTime' from " + currentTime + " to " + targetTime);
              this.warn(error.message);
              media.currentTime = targetTime;
              hls.trigger(Events.ERROR, {
                type: ErrorTypes.MEDIA_ERROR,
                details: ErrorDetails.BUFFER_NUDGE_ON_STALL,
                error,
                fatal: false,
                buffer: bufferInfo.len,
                bufferInfo
              });
            } else {
              var _error = new Error("Playhead still not moving while enough data buffered @" + currentTime + " after " + config.nudgeMaxRetry + " nudges");
              this.error(_error.message);
              hls.trigger(Events.ERROR, {
                type: ErrorTypes.MEDIA_ERROR,
                details: ErrorDetails.BUFFER_STALLED_ERROR,
                error: _error,
                fatal: true,
                buffer: bufferInfo.len,
                bufferInfo
              });
            }
          };
          return _createClass4(GapController2, [{
            key: "hasBuffered",
            get: function get() {
              return Object.keys(this.buffered).length > 0;
            }
          }]);
        }(TaskLoop);
        function getInFlightDependency(inFlightFragments, currentTime) {
          var main = inFlight(inFlightFragments.main);
          if (main && main.start <= currentTime) {
            return main;
          }
          var audio = inFlight(inFlightFragments.audio);
          if (audio && audio.start <= currentTime) {
            return audio;
          }
          return null;
        }
        function inFlight(inFlightData) {
          if (!inFlightData) {
            return null;
          }
          switch (inFlightData.state) {
            case State.IDLE:
            case State.STOPPED:
            case State.ENDED:
            case State.ERROR:
              return null;
          }
          return inFlightData.frag;
        }
        function sendAddTrackEvent(track, videoEl) {
          var event;
          try {
            event = new Event("addtrack");
          } catch (err) {
            event = document.createEvent("Event");
            event.initEvent("addtrack", false, false);
          }
          event.track = track;
          videoEl.dispatchEvent(event);
        }
        function clearCurrentCues(track, enterHandler) {
          var mode = track.mode;
          if (mode === "disabled") {
            track.mode = "hidden";
          }
          if (track.cues) {
            for (var i = track.cues.length; i--; ) {
              if (enterHandler) {
                track.cues[i].removeEventListener("enter", enterHandler);
              }
              track.removeCue(track.cues[i]);
            }
          }
          if (mode === "disabled") {
            track.mode = mode;
          }
        }
        function removeCuesInRange(track, start, end, predicate) {
          var mode = track.mode;
          if (mode === "disabled") {
            track.mode = "hidden";
          }
          if (track.cues && track.cues.length > 0) {
            var cues = getCuesInRange(track.cues, start, end);
            for (var i = 0; i < cues.length; i++) {
              if (!predicate || predicate(cues[i])) {
                track.removeCue(cues[i]);
              }
            }
          }
          if (mode === "disabled") {
            track.mode = mode;
          }
        }
        function getFirstCueIndexFromTime(cues, time) {
          if (time <= cues[0].startTime) {
            return 0;
          }
          var len = cues.length - 1;
          if (time > cues[len].endTime) {
            return -1;
          }
          var left = 0;
          var right = len;
          var mid;
          while (left <= right) {
            mid = Math.floor((right + left) / 2);
            if (time < cues[mid].startTime) {
              right = mid - 1;
            } else if (time > cues[mid].startTime && left < len) {
              left = mid + 1;
            } else {
              return mid;
            }
          }
          return cues[left].startTime - time < time - cues[right].startTime ? left : right;
        }
        function getCuesInRange(cues, start, end) {
          var cuesFound = [];
          var firstCueInRange = getFirstCueIndexFromTime(cues, start);
          if (firstCueInRange > -1) {
            for (var i = firstCueInRange, len = cues.length; i < len; i++) {
              var cue = cues[i];
              if (cue.startTime >= start && cue.endTime <= end) {
                cuesFound.push(cue);
              } else if (cue.startTime > end) {
                return cuesFound;
              }
            }
          }
          return cuesFound;
        }
        var MIN_CUE_DURATION = 0.25;
        function getCueClass() {
          if (typeof self === "undefined") return void 0;
          return self.VTTCue || self.TextTrackCue;
        }
        function createCueWithDataFields(Cue, startTime, endTime, data, type) {
          var cue = new Cue(startTime, endTime, "");
          try {
            cue.value = data;
            if (type) {
              cue.type = type;
            }
          } catch (e) {
            cue = new Cue(startTime, endTime, stringify2(type ? _objectSpread23({
              type
            }, data) : data));
          }
          return cue;
        }
        var MAX_CUE_ENDTIME = function() {
          var Cue = getCueClass();
          try {
            Cue && new Cue(0, Number.POSITIVE_INFINITY, "");
          } catch (e) {
            return Number.MAX_VALUE;
          }
          return Number.POSITIVE_INFINITY;
        }();
        function hexToArrayBuffer(str) {
          return Uint8Array.from(str.replace(/^0x/, "").replace(/([\da-fA-F]{2}) ?/g, "0x$1 ").replace(/ +$/, "").split(" ")).buffer;
        }
        var ID3TrackController = /* @__PURE__ */ function() {
          function ID3TrackController2(hls) {
            var _this = this;
            this.hls = void 0;
            this.id3Track = null;
            this.media = null;
            this.dateRangeCuesAppended = {};
            this.removeCues = true;
            this.onEventCueEnter = function() {
              if (!_this.hls) {
                return;
              }
              _this.hls.trigger(Events.EVENT_CUE_ENTER, {});
            };
            this.hls = hls;
            this._registerListeners();
          }
          var _proto = ID3TrackController2.prototype;
          _proto.destroy = function destroy() {
            this._unregisterListeners();
            this.id3Track = null;
            this.media = null;
            this.dateRangeCuesAppended = {};
            this.hls = this.onEventCueEnter = null;
          };
          _proto._registerListeners = function _registerListeners() {
            var hls = this.hls;
            hls.on(Events.MEDIA_ATTACHING, this.onMediaAttaching, this);
            hls.on(Events.MEDIA_ATTACHED, this.onMediaAttached, this);
            hls.on(Events.MEDIA_DETACHING, this.onMediaDetaching, this);
            hls.on(Events.MANIFEST_LOADING, this.onManifestLoading, this);
            hls.on(Events.FRAG_PARSING_METADATA, this.onFragParsingMetadata, this);
            hls.on(Events.BUFFER_FLUSHING, this.onBufferFlushing, this);
            hls.on(Events.LEVEL_UPDATED, this.onLevelUpdated, this);
            hls.on(Events.LEVEL_PTS_UPDATED, this.onLevelPtsUpdated, this);
          };
          _proto._unregisterListeners = function _unregisterListeners() {
            var hls = this.hls;
            hls.off(Events.MEDIA_ATTACHING, this.onMediaAttaching, this);
            hls.off(Events.MEDIA_ATTACHED, this.onMediaAttached, this);
            hls.off(Events.MEDIA_DETACHING, this.onMediaDetaching, this);
            hls.off(Events.MANIFEST_LOADING, this.onManifestLoading, this);
            hls.off(Events.FRAG_PARSING_METADATA, this.onFragParsingMetadata, this);
            hls.off(Events.BUFFER_FLUSHING, this.onBufferFlushing, this);
            hls.off(Events.LEVEL_UPDATED, this.onLevelUpdated, this);
            hls.off(Events.LEVEL_PTS_UPDATED, this.onLevelPtsUpdated, this);
          };
          _proto.onMediaAttaching = function onMediaAttaching(event, data) {
            var _data$overrides;
            this.media = data.media;
            if (((_data$overrides = data.overrides) == null ? void 0 : _data$overrides.cueRemoval) === false) {
              this.removeCues = false;
            }
          };
          _proto.onMediaAttached = function onMediaAttached() {
            var details = this.hls.latestLevelDetails;
            if (details) {
              this.updateDateRangeCues(details);
            }
          };
          _proto.onMediaDetaching = function onMediaDetaching(event, data) {
            this.media = null;
            var transferringMedia = !!data.transferMedia;
            if (transferringMedia) {
              return;
            }
            if (this.id3Track) {
              if (this.removeCues) {
                clearCurrentCues(this.id3Track, this.onEventCueEnter);
              }
              this.id3Track = null;
            }
            this.dateRangeCuesAppended = {};
          };
          _proto.onManifestLoading = function onManifestLoading() {
            this.dateRangeCuesAppended = {};
          };
          _proto.createTrack = function createTrack(media) {
            var track = this.getID3Track(media.textTracks);
            track.mode = "hidden";
            return track;
          };
          _proto.getID3Track = function getID3Track(textTracks) {
            if (!this.media) {
              return;
            }
            for (var i = 0; i < textTracks.length; i++) {
              var textTrack = textTracks[i];
              if (textTrack.kind === "metadata" && textTrack.label === "id3") {
                sendAddTrackEvent(textTrack, this.media);
                return textTrack;
              }
            }
            return this.media.addTextTrack("metadata", "id3");
          };
          _proto.onFragParsingMetadata = function onFragParsingMetadata(event, data) {
            if (!this.media) {
              return;
            }
            var _this$hls$config = this.hls.config, enableEmsgMetadataCues = _this$hls$config.enableEmsgMetadataCues, enableID3MetadataCues = _this$hls$config.enableID3MetadataCues;
            if (!enableEmsgMetadataCues && !enableID3MetadataCues) {
              return;
            }
            var samples = data.samples;
            if (!this.id3Track) {
              this.id3Track = this.createTrack(this.media);
            }
            var Cue = getCueClass();
            if (!Cue) {
              return;
            }
            for (var i = 0; i < samples.length; i++) {
              var type = samples[i].type;
              if (type === MetadataSchema.emsg && !enableEmsgMetadataCues || !enableID3MetadataCues) {
                continue;
              }
              var frames = getId3Frames(samples[i].data);
              if (frames) {
                var startTime = samples[i].pts;
                var endTime = startTime + samples[i].duration;
                if (endTime > MAX_CUE_ENDTIME) {
                  endTime = MAX_CUE_ENDTIME;
                }
                var timeDiff = endTime - startTime;
                if (timeDiff <= 0) {
                  endTime = startTime + MIN_CUE_DURATION;
                }
                for (var j = 0; j < frames.length; j++) {
                  var frame = frames[j];
                  if (!isId3TimestampFrame(frame)) {
                    this.updateId3CueEnds(startTime, type);
                    var cue = createCueWithDataFields(Cue, startTime, endTime, frame, type);
                    if (cue) {
                      this.id3Track.addCue(cue);
                    }
                  }
                }
              }
            }
          };
          _proto.updateId3CueEnds = function updateId3CueEnds(startTime, type) {
            var _this$id3Track;
            var cues = (_this$id3Track = this.id3Track) == null ? void 0 : _this$id3Track.cues;
            if (cues) {
              for (var i = cues.length; i--; ) {
                var cue = cues[i];
                if (cue.type === type && cue.startTime < startTime && cue.endTime === MAX_CUE_ENDTIME) {
                  cue.endTime = startTime;
                }
              }
            }
          };
          _proto.onBufferFlushing = function onBufferFlushing(event, _ref) {
            var startOffset = _ref.startOffset, endOffset = _ref.endOffset, type = _ref.type;
            var id3Track = this.id3Track, hls = this.hls;
            if (!hls) {
              return;
            }
            var _hls$config = hls.config, enableEmsgMetadataCues = _hls$config.enableEmsgMetadataCues, enableID3MetadataCues = _hls$config.enableID3MetadataCues;
            if (id3Track && (enableEmsgMetadataCues || enableID3MetadataCues)) {
              var predicate;
              if (type === "audio") {
                predicate = function predicate2(cue) {
                  return cue.type === MetadataSchema.audioId3 && enableID3MetadataCues;
                };
              } else if (type === "video") {
                predicate = function predicate2(cue) {
                  return cue.type === MetadataSchema.emsg && enableEmsgMetadataCues;
                };
              } else {
                predicate = function predicate2(cue) {
                  return cue.type === MetadataSchema.audioId3 && enableID3MetadataCues || cue.type === MetadataSchema.emsg && enableEmsgMetadataCues;
                };
              }
              removeCuesInRange(id3Track, startOffset, endOffset, predicate);
            }
          };
          _proto.onLevelUpdated = function onLevelUpdated(event, _ref2) {
            var details = _ref2.details;
            this.updateDateRangeCues(details, true);
          };
          _proto.onLevelPtsUpdated = function onLevelPtsUpdated(event, data) {
            if (Math.abs(data.drift) > 0.01) {
              this.updateDateRangeCues(data.details);
            }
          };
          _proto.updateDateRangeCues = function updateDateRangeCues(details, removeOldCues) {
            var _this2 = this;
            if (!this.media || !details.hasProgramDateTime || !this.hls.config.enableDateRangeMetadataCues) {
              return;
            }
            var id3Track = this.id3Track;
            var dateRanges = details.dateRanges;
            var ids = Object.keys(dateRanges);
            var dateRangeCuesAppended = this.dateRangeCuesAppended;
            if (id3Track && removeOldCues) {
              var _id3Track$cues;
              if ((_id3Track$cues = id3Track.cues) != null && _id3Track$cues.length) {
                var idsToRemove = Object.keys(dateRangeCuesAppended).filter(function(id) {
                  return !ids.includes(id);
                });
                var _loop = function _loop3() {
                  var id = idsToRemove[i];
                  var cues = dateRangeCuesAppended[id].cues;
                  delete dateRangeCuesAppended[id];
                  Object.keys(cues).forEach(function(key) {
                    try {
                      var cue = cues[key];
                      cue.removeEventListener("enter", _this2.onEventCueEnter);
                      id3Track.removeCue(cue);
                    } catch (e) {
                    }
                  });
                };
                for (var i = idsToRemove.length; i--; ) {
                  _loop();
                }
              } else {
                dateRangeCuesAppended = this.dateRangeCuesAppended = {};
              }
            }
            var lastFragment = details.fragments[details.fragments.length - 1];
            if (ids.length === 0 || !isFiniteNumber(lastFragment == null ? void 0 : lastFragment.programDateTime)) {
              return;
            }
            if (!this.id3Track) {
              this.id3Track = this.createTrack(this.media);
            }
            var Cue = getCueClass();
            var _loop2 = function _loop22() {
              var id = ids[_i];
              var dateRange = dateRanges[id];
              var startTime = dateRange.startTime;
              var appendedDateRangeCues = dateRangeCuesAppended[id];
              var cues = (appendedDateRangeCues == null ? void 0 : appendedDateRangeCues.cues) || {};
              var durationKnown = (appendedDateRangeCues == null ? void 0 : appendedDateRangeCues.durationKnown) || false;
              var endTime = MAX_CUE_ENDTIME;
              var duration = dateRange.duration, endDate = dateRange.endDate;
              if (endDate && duration !== null) {
                endTime = startTime + duration;
                durationKnown = true;
              } else if (dateRange.endOnNext && !durationKnown) {
                var nextDateRangeWithSameClass = ids.reduce(function(candidateDateRange, id2) {
                  if (id2 !== dateRange.id) {
                    var otherDateRange = dateRanges[id2];
                    if (otherDateRange.class === dateRange.class && otherDateRange.startDate > dateRange.startDate && (!candidateDateRange || dateRange.startDate < candidateDateRange.startDate)) {
                      return otherDateRange;
                    }
                  }
                  return candidateDateRange;
                }, null);
                if (nextDateRangeWithSameClass) {
                  endTime = nextDateRangeWithSameClass.startTime;
                  durationKnown = true;
                }
              }
              var attributes = Object.keys(dateRange.attr);
              for (var j = 0; j < attributes.length; j++) {
                var key = attributes[j];
                if (!isDateRangeCueAttribute(key)) {
                  continue;
                }
                var cue = cues[key];
                if (cue) {
                  if (durationKnown && !appendedDateRangeCues.durationKnown) {
                    cue.endTime = endTime;
                  } else if (Math.abs(cue.startTime - startTime) > 0.01) {
                    cue.startTime = startTime;
                    cue.endTime = endTime;
                  }
                } else if (Cue) {
                  var data = dateRange.attr[key];
                  if (isSCTE35Attribute(key)) {
                    data = hexToArrayBuffer(data);
                  }
                  var payload = {
                    key,
                    data
                  };
                  var _cue = createCueWithDataFields(Cue, startTime, endTime, payload, MetadataSchema.dateRange);
                  if (_cue) {
                    _cue.id = id;
                    _this2.id3Track.addCue(_cue);
                    cues[key] = _cue;
                  }
                }
              }
              dateRangeCuesAppended[id] = {
                cues,
                dateRange,
                durationKnown
              };
            };
            for (var _i = 0; _i < ids.length; _i++) {
              _loop2();
            }
          };
          return ID3TrackController2;
        }();
        var LatencyController = /* @__PURE__ */ function() {
          function LatencyController2(hls) {
            var _this = this;
            this.hls = void 0;
            this.config = void 0;
            this.media = null;
            this.currentTime = 0;
            this.stallCount = 0;
            this._latency = null;
            this._targetLatencyUpdated = false;
            this.onTimeupdate = function() {
              var media = _this.media;
              var levelDetails = _this.levelDetails;
              if (!media || !levelDetails) {
                return;
              }
              _this.currentTime = media.currentTime;
              var latency = _this.computeLatency();
              if (latency === null) {
                return;
              }
              _this._latency = latency;
              var _this$config = _this.config, lowLatencyMode = _this$config.lowLatencyMode, maxLiveSyncPlaybackRate = _this$config.maxLiveSyncPlaybackRate;
              if (!lowLatencyMode || maxLiveSyncPlaybackRate === 1 || !levelDetails.live) {
                return;
              }
              var targetLatency = _this.targetLatency;
              if (targetLatency === null) {
                return;
              }
              var distanceFromTarget = latency - targetLatency;
              var liveMinLatencyDuration = Math.min(_this.maxLatency, targetLatency + levelDetails.targetduration);
              var inLiveRange = distanceFromTarget < liveMinLatencyDuration;
              if (inLiveRange && distanceFromTarget > 0.05 && _this.forwardBufferLength > 1) {
                var max = Math.min(2, Math.max(1, maxLiveSyncPlaybackRate));
                var rate = Math.round(2 / (1 + Math.exp(-0.75 * distanceFromTarget - _this.edgeStalled)) * 20) / 20;
                var playbackRate = Math.min(max, Math.max(1, rate));
                _this.changeMediaPlaybackRate(media, playbackRate);
              } else if (media.playbackRate !== 1 && media.playbackRate !== 0) {
                _this.changeMediaPlaybackRate(media, 1);
              }
            };
            this.hls = hls;
            this.config = hls.config;
            this.registerListeners();
          }
          var _proto = LatencyController2.prototype;
          _proto.destroy = function destroy() {
            this.unregisterListeners();
            this.onMediaDetaching();
            this.hls = null;
          };
          _proto.registerListeners = function registerListeners() {
            var hls = this.hls;
            if (!hls) {
              return;
            }
            hls.on(Events.MEDIA_ATTACHED, this.onMediaAttached, this);
            hls.on(Events.MEDIA_DETACHING, this.onMediaDetaching, this);
            hls.on(Events.MANIFEST_LOADING, this.onManifestLoading, this);
            hls.on(Events.LEVEL_UPDATED, this.onLevelUpdated, this);
            hls.on(Events.ERROR, this.onError, this);
          };
          _proto.unregisterListeners = function unregisterListeners() {
            var hls = this.hls;
            if (!hls) {
              return;
            }
            hls.off(Events.MEDIA_ATTACHED, this.onMediaAttached, this);
            hls.off(Events.MEDIA_DETACHING, this.onMediaDetaching, this);
            hls.off(Events.MANIFEST_LOADING, this.onManifestLoading, this);
            hls.off(Events.LEVEL_UPDATED, this.onLevelUpdated, this);
            hls.off(Events.ERROR, this.onError, this);
          };
          _proto.onMediaAttached = function onMediaAttached(event, data) {
            this.media = data.media;
            this.media.addEventListener("timeupdate", this.onTimeupdate);
          };
          _proto.onMediaDetaching = function onMediaDetaching() {
            if (this.media) {
              this.media.removeEventListener("timeupdate", this.onTimeupdate);
              this.media = null;
            }
          };
          _proto.onManifestLoading = function onManifestLoading() {
            this._latency = null;
            this.stallCount = 0;
          };
          _proto.onLevelUpdated = function onLevelUpdated(event, _ref) {
            var details = _ref.details;
            if (details.advanced) {
              this.onTimeupdate();
            }
            if (!details.live && this.media) {
              this.media.removeEventListener("timeupdate", this.onTimeupdate);
            }
          };
          _proto.onError = function onError(event, data) {
            var _this$levelDetails;
            if (data.details !== ErrorDetails.BUFFER_STALLED_ERROR) {
              return;
            }
            this.stallCount++;
            if (this.hls && (_this$levelDetails = this.levelDetails) != null && _this$levelDetails.live) {
              this.hls.logger.warn("[latency-controller]: Stall detected, adjusting target latency");
            }
          };
          _proto.changeMediaPlaybackRate = function changeMediaPlaybackRate(media, playbackRate) {
            var _this$hls, _this$targetLatency;
            if (media.playbackRate === playbackRate) {
              return;
            }
            (_this$hls = this.hls) == null ? void 0 : _this$hls.logger.debug("[latency-controller]: latency=" + this.latency.toFixed(3) + ", targetLatency=" + ((_this$targetLatency = this.targetLatency) == null ? void 0 : _this$targetLatency.toFixed(3)) + ", forwardBufferLength=" + this.forwardBufferLength.toFixed(3) + ": adjusting playback rate from " + media.playbackRate + " to " + playbackRate);
            media.playbackRate = playbackRate;
          };
          _proto.estimateLiveEdge = function estimateLiveEdge() {
            var levelDetails = this.levelDetails;
            if (levelDetails === null) {
              return null;
            }
            return levelDetails.edge + levelDetails.age;
          };
          _proto.computeLatency = function computeLatency() {
            var liveEdge = this.estimateLiveEdge();
            if (liveEdge === null) {
              return null;
            }
            return liveEdge - this.currentTime;
          };
          return _createClass4(LatencyController2, [{
            key: "levelDetails",
            get: function get() {
              var _this$hls2;
              return ((_this$hls2 = this.hls) == null ? void 0 : _this$hls2.latestLevelDetails) || null;
            }
          }, {
            key: "latency",
            get: function get() {
              return this._latency || 0;
            }
          }, {
            key: "maxLatency",
            get: function get() {
              var config = this.config;
              if (config.liveMaxLatencyDuration !== void 0) {
                return config.liveMaxLatencyDuration;
              }
              var levelDetails = this.levelDetails;
              return levelDetails ? config.liveMaxLatencyDurationCount * levelDetails.targetduration : 0;
            }
          }, {
            key: "targetLatency",
            get: function get() {
              var levelDetails = this.levelDetails;
              if (levelDetails === null || this.hls === null) {
                return null;
              }
              var holdBack = levelDetails.holdBack, partHoldBack = levelDetails.partHoldBack, targetduration = levelDetails.targetduration;
              var _this$config2 = this.config, liveSyncDuration = _this$config2.liveSyncDuration, liveSyncDurationCount = _this$config2.liveSyncDurationCount, lowLatencyMode = _this$config2.lowLatencyMode;
              var userConfig = this.hls.userConfig;
              var targetLatency = lowLatencyMode ? partHoldBack || holdBack : holdBack;
              if (this._targetLatencyUpdated || userConfig.liveSyncDuration || userConfig.liveSyncDurationCount || targetLatency === 0) {
                targetLatency = liveSyncDuration !== void 0 ? liveSyncDuration : liveSyncDurationCount * targetduration;
              }
              var maxLiveSyncOnStallIncrease = targetduration;
              return targetLatency + Math.min(this.stallCount * this.config.liveSyncOnStallIncrease, maxLiveSyncOnStallIncrease);
            },
            set: function set(latency) {
              this.stallCount = 0;
              this.config.liveSyncDuration = latency;
              this._targetLatencyUpdated = true;
            }
          }, {
            key: "liveSyncPosition",
            get: function get() {
              var liveEdge = this.estimateLiveEdge();
              var targetLatency = this.targetLatency;
              if (liveEdge === null || targetLatency === null) {
                return null;
              }
              var levelDetails = this.levelDetails;
              if (levelDetails === null) {
                return null;
              }
              var edge = levelDetails.edge;
              var syncPosition = liveEdge - targetLatency - this.edgeStalled;
              var min = edge - levelDetails.totalduration;
              var max = edge - (this.config.lowLatencyMode && levelDetails.partTarget || levelDetails.targetduration);
              return Math.min(Math.max(min, syncPosition), max);
            }
          }, {
            key: "drift",
            get: function get() {
              var levelDetails = this.levelDetails;
              if (levelDetails === null) {
                return 1;
              }
              return levelDetails.drift;
            }
          }, {
            key: "edgeStalled",
            get: function get() {
              var levelDetails = this.levelDetails;
              if (levelDetails === null) {
                return 0;
              }
              var maxLevelUpdateAge = (this.config.lowLatencyMode && levelDetails.partTarget || levelDetails.targetduration) * 3;
              return Math.max(levelDetails.age - maxLevelUpdateAge, 0);
            }
          }, {
            key: "forwardBufferLength",
            get: function get() {
              var media = this.media;
              var levelDetails = this.levelDetails;
              if (!media || !levelDetails) {
                return 0;
              }
              var bufferedRanges = media.buffered.length;
              return (bufferedRanges ? media.buffered.end(bufferedRanges - 1) : levelDetails.edge) - this.currentTime;
            }
          }]);
        }();
        var BasePlaylistController = /* @__PURE__ */ function(_Logger) {
          function BasePlaylistController2(hls, logPrefix) {
            var _this;
            _this = _Logger.call(this, logPrefix, hls.logger) || this;
            _this.hls = void 0;
            _this.canLoad = false;
            _this.timer = -1;
            _this.hls = hls;
            return _this;
          }
          _inheritsLoose(BasePlaylistController2, _Logger);
          var _proto = BasePlaylistController2.prototype;
          _proto.destroy = function destroy() {
            this.clearTimer();
            this.hls = this.log = this.warn = null;
          };
          _proto.clearTimer = function clearTimer() {
            if (this.timer !== -1) {
              self.clearTimeout(this.timer);
              this.timer = -1;
            }
          };
          _proto.startLoad = function startLoad() {
            this.canLoad = true;
            this.loadPlaylist();
          };
          _proto.stopLoad = function stopLoad() {
            this.canLoad = false;
            this.clearTimer();
          };
          _proto.switchParams = function switchParams(playlistUri, previous, current) {
            var renditionReports = previous == null ? void 0 : previous.renditionReports;
            if (renditionReports) {
              var foundIndex = -1;
              for (var i = 0; i < renditionReports.length; i++) {
                var attr = renditionReports[i];
                var uri = void 0;
                try {
                  uri = new self.URL(attr.URI, previous.url).href;
                } catch (error) {
                  this.warn("Could not construct new URL for Rendition Report: " + error);
                  uri = attr.URI || "";
                }
                if (uri === playlistUri) {
                  foundIndex = i;
                  break;
                } else if (uri === playlistUri.substring(0, uri.length)) {
                  foundIndex = i;
                }
              }
              if (foundIndex !== -1) {
                var _attr = renditionReports[foundIndex];
                var msn = parseInt(_attr["LAST-MSN"]) || (previous == null ? void 0 : previous.lastPartSn);
                var part = parseInt(_attr["LAST-PART"]) || (previous == null ? void 0 : previous.lastPartIndex);
                if (this.hls.config.lowLatencyMode) {
                  var currentGoal = Math.min(previous.age - previous.partTarget, previous.targetduration);
                  if (part >= 0 && currentGoal > previous.partTarget) {
                    part += 1;
                  }
                }
                var skip = current && getSkipValue(current);
                return new HlsUrlParameters(msn, part >= 0 ? part : void 0, skip);
              }
            }
          };
          _proto.loadPlaylist = function loadPlaylist(hlsUrlParameters) {
            this.clearTimer();
          };
          _proto.loadingPlaylist = function loadingPlaylist(playlist, hlsUrlParameters) {
            this.clearTimer();
          };
          _proto.shouldLoadPlaylist = function shouldLoadPlaylist(playlist) {
            return this.canLoad && !!playlist && !!playlist.url && (!playlist.details || playlist.details.live);
          };
          _proto.getUrlWithDirectives = function getUrlWithDirectives(uri, hlsUrlParameters) {
            if (hlsUrlParameters) {
              try {
                return hlsUrlParameters.addDirectives(uri);
              } catch (error) {
                this.warn("Could not construct new URL with HLS Delivery Directives: " + error);
              }
            }
            return uri;
          };
          _proto.playlistLoaded = function playlistLoaded(index, data, previousDetails) {
            var details = data.details, stats = data.stats;
            var now2 = self.performance.now();
            var elapsed = stats.loading.first ? Math.max(0, now2 - stats.loading.first) : 0;
            details.advancedDateTime = Date.now() - elapsed;
            var timelineOffset = this.hls.config.timelineOffset;
            if (timelineOffset !== details.appliedTimelineOffset) {
              var offset = Math.max(timelineOffset || 0, 0);
              details.appliedTimelineOffset = offset;
              details.fragments.forEach(function(frag) {
                frag.start = frag.playlistOffset + offset;
              });
            }
            if (details.live || previousDetails != null && previousDetails.live) {
              var levelOrTrack = "levelInfo" in data ? data.levelInfo : data.track;
              details.reloaded(previousDetails);
              if (previousDetails && details.fragments.length > 0) {
                mergeDetails(previousDetails, details);
                var error = details.playlistParsingError;
                if (error) {
                  this.warn(error);
                  var hls = this.hls;
                  if (!hls.config.ignorePlaylistParsingErrors) {
                    var _details$fragments$;
                    var networkDetails = data.networkDetails;
                    hls.trigger(Events.ERROR, {
                      type: ErrorTypes.NETWORK_ERROR,
                      details: ErrorDetails.LEVEL_PARSING_ERROR,
                      fatal: false,
                      url: details.url,
                      error,
                      reason: error.message,
                      level: data.level || void 0,
                      parent: (_details$fragments$ = details.fragments[0]) == null ? void 0 : _details$fragments$.type,
                      networkDetails,
                      stats
                    });
                    return;
                  }
                  details.playlistParsingError = null;
                }
              }
              if (details.requestScheduled === -1) {
                details.requestScheduled = stats.loading.start;
              }
              var bufferInfo = this.hls.mainForwardBufferInfo;
              var position = bufferInfo ? bufferInfo.end - bufferInfo.len : 0;
              var distanceToLiveEdgeMs = (details.edge - position) * 1e3;
              var reloadInterval = computeReloadInterval(details, distanceToLiveEdgeMs);
              if (details.requestScheduled + reloadInterval < now2) {
                details.requestScheduled = now2;
              } else {
                details.requestScheduled += reloadInterval;
              }
              this.log("live playlist " + index + " " + (details.advanced ? "REFRESHED " + details.lastPartSn + "-" + details.lastPartIndex : details.updated ? "UPDATED" : "MISSED"));
              if (!this.canLoad || !details.live) {
                return;
              }
              var deliveryDirectives;
              var msn = void 0;
              var part = void 0;
              if (details.canBlockReload && details.endSN && details.advanced) {
                var lowLatencyMode = this.hls.config.lowLatencyMode;
                var lastPartSn = details.lastPartSn;
                var endSn = details.endSN;
                var lastPartIndex = details.lastPartIndex;
                var hasParts = lastPartIndex !== -1;
                var atLastPartOfSegment = lastPartSn === endSn;
                if (hasParts) {
                  if (atLastPartOfSegment) {
                    msn = endSn + 1;
                    part = lowLatencyMode ? 0 : lastPartIndex;
                  } else {
                    msn = lastPartSn;
                    part = lowLatencyMode ? lastPartIndex + 1 : details.maxPartIndex;
                  }
                } else {
                  msn = endSn + 1;
                }
                var lastAdvanced = details.age;
                var cdnAge = lastAdvanced + details.ageHeader;
                var currentGoal = Math.min(cdnAge - details.partTarget, details.targetduration * 1.5);
                if (currentGoal > 0) {
                  if (cdnAge > details.targetduration * 3) {
                    this.log("Playlist last advanced " + lastAdvanced.toFixed(2) + "s ago. Omitting segment and part directives.");
                    msn = void 0;
                    part = void 0;
                  } else if (previousDetails != null && previousDetails.tuneInGoal && cdnAge - details.partTarget > previousDetails.tuneInGoal) {
                    this.warn("CDN Tune-in goal increased from: " + previousDetails.tuneInGoal + " to: " + currentGoal + " with playlist age: " + details.age);
                    currentGoal = 0;
                  } else {
                    var segments = Math.floor(currentGoal / details.targetduration);
                    msn += segments;
                    if (part !== void 0) {
                      var parts = Math.round(currentGoal % details.targetduration / details.partTarget);
                      part += parts;
                    }
                    this.log("CDN Tune-in age: " + details.ageHeader + "s last advanced " + lastAdvanced.toFixed(2) + "s goal: " + currentGoal + " skip sn " + segments + " to part " + part);
                  }
                  details.tuneInGoal = currentGoal;
                }
                deliveryDirectives = this.getDeliveryDirectives(details, data.deliveryDirectives, msn, part);
                if (lowLatencyMode || !atLastPartOfSegment) {
                  details.requestScheduled = now2;
                  this.loadingPlaylist(levelOrTrack, deliveryDirectives);
                  return;
                }
              } else if (details.canBlockReload || details.canSkipUntil) {
                deliveryDirectives = this.getDeliveryDirectives(details, data.deliveryDirectives, msn, part);
              }
              if (deliveryDirectives && msn !== void 0 && details.canBlockReload) {
                details.requestScheduled = stats.loading.first + Math.max(reloadInterval - elapsed * 2, reloadInterval / 2);
              }
              this.scheduleLoading(levelOrTrack, deliveryDirectives, details);
            } else {
              this.clearTimer();
            }
          };
          _proto.scheduleLoading = function scheduleLoading(levelOrTrack, deliveryDirectives, updatedDetails) {
            var _this2 = this;
            var details = updatedDetails || levelOrTrack.details;
            if (!details) {
              this.loadingPlaylist(levelOrTrack, deliveryDirectives);
              return;
            }
            var now2 = self.performance.now();
            var requestScheduled = details.requestScheduled;
            if (now2 >= requestScheduled) {
              this.loadingPlaylist(levelOrTrack, deliveryDirectives);
              return;
            }
            var estimatedTimeUntilUpdate = requestScheduled - now2;
            this.log("reload live playlist " + (levelOrTrack.name || levelOrTrack.bitrate + "bps") + " in " + Math.round(estimatedTimeUntilUpdate) + " ms");
            this.clearTimer();
            this.timer = self.setTimeout(function() {
              return _this2.loadingPlaylist(levelOrTrack, deliveryDirectives);
            }, estimatedTimeUntilUpdate);
          };
          _proto.getDeliveryDirectives = function getDeliveryDirectives(details, previousDeliveryDirectives, msn, part) {
            var skip = getSkipValue(details);
            if (previousDeliveryDirectives != null && previousDeliveryDirectives.skip && details.deltaUpdateFailed) {
              msn = previousDeliveryDirectives.msn;
              part = previousDeliveryDirectives.part;
              skip = HlsSkip.No;
            }
            return new HlsUrlParameters(msn, part, skip);
          };
          _proto.checkRetry = function checkRetry(errorEvent) {
            var _this3 = this;
            var errorDetails = errorEvent.details;
            var isTimeout = isTimeoutError(errorEvent);
            var errorAction = errorEvent.errorAction;
            var _ref = errorAction || {}, action = _ref.action, _ref$retryCount = _ref.retryCount, retryCount = _ref$retryCount === void 0 ? 0 : _ref$retryCount, retryConfig = _ref.retryConfig;
            var retry = !!errorAction && !!retryConfig && (action === NetworkErrorAction.RetryRequest || !errorAction.resolved && action === NetworkErrorAction.SendAlternateToPenaltyBox);
            if (retry) {
              var _errorEvent$context;
              if (retryCount >= retryConfig.maxNumRetry) {
                return false;
              }
              if (isTimeout && (_errorEvent$context = errorEvent.context) != null && _errorEvent$context.deliveryDirectives) {
                this.warn("Retrying playlist loading " + (retryCount + 1) + "/" + retryConfig.maxNumRetry + ' after "' + errorDetails + '" without delivery-directives');
                this.loadPlaylist();
              } else {
                var delay = getRetryDelay(retryConfig, retryCount);
                this.clearTimer();
                this.timer = self.setTimeout(function() {
                  return _this3.loadPlaylist();
                }, delay);
                this.warn("Retrying playlist loading " + (retryCount + 1) + "/" + retryConfig.maxNumRetry + ' after "' + errorDetails + '" in ' + delay + "ms");
              }
              errorEvent.levelRetry = true;
              errorAction.resolved = true;
            }
            return retry;
          };
          return BasePlaylistController2;
        }(Logger4);
        var LevelController = /* @__PURE__ */ function(_BasePlaylistControll) {
          function LevelController2(hls, contentSteeringController) {
            var _this;
            _this = _BasePlaylistControll.call(this, hls, "level-controller") || this;
            _this._levels = [];
            _this._firstLevel = -1;
            _this._maxAutoLevel = -1;
            _this._startLevel = void 0;
            _this.currentLevel = null;
            _this.currentLevelIndex = -1;
            _this.manualLevelIndex = -1;
            _this.steering = void 0;
            _this.onParsedComplete = void 0;
            _this.steering = contentSteeringController;
            _this._registerListeners();
            return _this;
          }
          _inheritsLoose(LevelController2, _BasePlaylistControll);
          var _proto = LevelController2.prototype;
          _proto._registerListeners = function _registerListeners() {
            var hls = this.hls;
            hls.on(Events.MANIFEST_LOADING, this.onManifestLoading, this);
            hls.on(Events.MANIFEST_LOADED, this.onManifestLoaded, this);
            hls.on(Events.LEVEL_LOADED, this.onLevelLoaded, this);
            hls.on(Events.LEVELS_UPDATED, this.onLevelsUpdated, this);
            hls.on(Events.FRAG_BUFFERED, this.onFragBuffered, this);
            hls.on(Events.ERROR, this.onError, this);
          };
          _proto._unregisterListeners = function _unregisterListeners() {
            var hls = this.hls;
            hls.off(Events.MANIFEST_LOADING, this.onManifestLoading, this);
            hls.off(Events.MANIFEST_LOADED, this.onManifestLoaded, this);
            hls.off(Events.LEVEL_LOADED, this.onLevelLoaded, this);
            hls.off(Events.LEVELS_UPDATED, this.onLevelsUpdated, this);
            hls.off(Events.FRAG_BUFFERED, this.onFragBuffered, this);
            hls.off(Events.ERROR, this.onError, this);
          };
          _proto.destroy = function destroy() {
            this._unregisterListeners();
            this.steering = null;
            this.resetLevels();
            _BasePlaylistControll.prototype.destroy.call(this);
          };
          _proto.stopLoad = function stopLoad() {
            var levels = this._levels;
            levels.forEach(function(level) {
              level.loadError = 0;
              level.fragmentError = 0;
            });
            _BasePlaylistControll.prototype.stopLoad.call(this);
          };
          _proto.resetLevels = function resetLevels() {
            this._startLevel = void 0;
            this.manualLevelIndex = -1;
            this.currentLevelIndex = -1;
            this.currentLevel = null;
            this._levels = [];
            this._maxAutoLevel = -1;
          };
          _proto.onManifestLoading = function onManifestLoading(event, data) {
            this.resetLevels();
          };
          _proto.onManifestLoaded = function onManifestLoaded(event, data) {
            var _this2 = this;
            var preferManagedMediaSource = this.hls.config.preferManagedMediaSource;
            var levels = [];
            var redundantSet = {};
            var generatePathwaySet = {};
            var resolutionFound = false;
            var videoCodecFound = false;
            var audioCodecFound = false;
            data.levels.forEach(function(levelParsed) {
              var _videoCodec;
              var attributes = levelParsed.attrs;
              var audioCodec = levelParsed.audioCodec, videoCodec = levelParsed.videoCodec;
              if (audioCodec) {
                levelParsed.audioCodec = audioCodec = getCodecCompatibleName(audioCodec, preferManagedMediaSource) || void 0;
              }
              if (((_videoCodec = videoCodec) == null ? void 0 : _videoCodec.indexOf("avc1")) === 0) {
                videoCodec = levelParsed.videoCodec = convertAVC1ToAVCOTI(videoCodec);
              }
              var width = levelParsed.width, height = levelParsed.height, unknownCodecs = levelParsed.unknownCodecs;
              var unknownUnsupportedCodecCount = unknownCodecs ? unknownCodecs.length : 0;
              if (unknownCodecs) {
                for (var i = unknownUnsupportedCodecCount; i--; ) {
                  var unknownCodec = unknownCodecs[i];
                  if (_this2.isAudioSupported(unknownCodec)) {
                    levelParsed.audioCodec = audioCodec = audioCodec ? audioCodec + "," + unknownCodec : unknownCodec;
                    unknownUnsupportedCodecCount--;
                    sampleEntryCodesISO.audio[audioCodec.substring(0, 4)] = 2;
                  } else if (_this2.isVideoSupported(unknownCodec)) {
                    levelParsed.videoCodec = videoCodec = videoCodec ? videoCodec + "," + unknownCodec : unknownCodec;
                    unknownUnsupportedCodecCount--;
                    sampleEntryCodesISO.video[videoCodec.substring(0, 4)] = 2;
                  }
                }
              }
              resolutionFound || (resolutionFound = !!(width && height));
              videoCodecFound || (videoCodecFound = !!videoCodec);
              audioCodecFound || (audioCodecFound = !!audioCodec);
              if (unknownUnsupportedCodecCount || audioCodec && !_this2.isAudioSupported(audioCodec) || videoCodec && !_this2.isVideoSupported(videoCodec)) {
                _this2.log('Some or all CODECS not supported "' + attributes.CODECS + '"');
                return;
              }
              var CODECS = attributes.CODECS, FRAMERATE = attributes["FRAME-RATE"], HDCP = attributes["HDCP-LEVEL"], PATHWAY = attributes["PATHWAY-ID"], RESOLUTION = attributes.RESOLUTION, VIDEO_RANGE = attributes["VIDEO-RANGE"];
              var contentSteeringPrefix = (PATHWAY || ".") + "-";
              var levelKey = "" + contentSteeringPrefix + levelParsed.bitrate + "-" + RESOLUTION + "-" + FRAMERATE + "-" + CODECS + "-" + VIDEO_RANGE + "-" + HDCP;
              if (!redundantSet[levelKey]) {
                var level = _this2.createLevel(levelParsed);
                redundantSet[levelKey] = level;
                generatePathwaySet[levelKey] = 1;
                levels.push(level);
              } else if (redundantSet[levelKey].uri !== levelParsed.url && !levelParsed.attrs["PATHWAY-ID"]) {
                var pathwayCount = generatePathwaySet[levelKey] += 1;
                levelParsed.attrs["PATHWAY-ID"] = new Array(pathwayCount + 1).join(".");
                var _level = _this2.createLevel(levelParsed);
                redundantSet[levelKey] = _level;
                levels.push(_level);
              } else {
                redundantSet[levelKey].addGroupId("audio", attributes.AUDIO);
                redundantSet[levelKey].addGroupId("text", attributes.SUBTITLES);
              }
            });
            this.filterAndSortMediaOptions(levels, data, resolutionFound, videoCodecFound, audioCodecFound);
          };
          _proto.createLevel = function createLevel(levelParsed) {
            var level = new Level(levelParsed);
            var supplemental = levelParsed.supplemental;
            if (supplemental != null && supplemental.videoCodec && !this.isVideoSupported(supplemental.videoCodec)) {
              var error = new Error('SUPPLEMENTAL-CODECS not supported "' + supplemental.videoCodec + '"');
              this.log(error.message);
              level.supportedResult = emptyExports.getUnsupportedResult(error, []);
            }
            return level;
          };
          _proto.isAudioSupported = function isAudioSupported(codec) {
            return areCodecsMediaSourceSupported(codec, "audio", this.hls.config.preferManagedMediaSource);
          };
          _proto.isVideoSupported = function isVideoSupported(codec) {
            return areCodecsMediaSourceSupported(codec, "video", this.hls.config.preferManagedMediaSource);
          };
          _proto.filterAndSortMediaOptions = function filterAndSortMediaOptions(filteredLevels, data, resolutionFound, videoCodecFound, audioCodecFound) {
            var _this3 = this;
            var audioTracks = [];
            var subtitleTracks = [];
            var levels = filteredLevels;
            if ((resolutionFound || videoCodecFound) && audioCodecFound) {
              levels = levels.filter(function(_ref) {
                var videoCodec = _ref.videoCodec, videoRange = _ref.videoRange, width = _ref.width, height = _ref.height;
                return (!!videoCodec || !!(width && height)) && isVideoRange(videoRange);
              });
            }
            if (levels.length === 0) {
              Promise.resolve().then(function() {
                if (_this3.hls) {
                  var message = "no level with compatible codecs found in manifest";
                  var reason = message;
                  if (data.levels.length) {
                    reason = "one or more CODECS in variant not supported: " + stringify2(data.levels.map(function(level) {
                      return level.attrs.CODECS;
                    }).filter(function(value, index, array) {
                      return array.indexOf(value) === index;
                    }));
                    _this3.warn(reason);
                    message += " (" + reason + ")";
                  }
                  var error = new Error(message);
                  _this3.hls.trigger(Events.ERROR, {
                    type: ErrorTypes.MEDIA_ERROR,
                    details: ErrorDetails.MANIFEST_INCOMPATIBLE_CODECS_ERROR,
                    fatal: true,
                    url: data.url,
                    error,
                    reason
                  });
                }
              });
              return;
            }
            if (data.audioTracks) {
              audioTracks = data.audioTracks.filter(function(track) {
                return !track.audioCodec || _this3.isAudioSupported(track.audioCodec);
              });
              assignTrackIdsByGroup(audioTracks);
            }
            if (data.subtitles) {
              subtitleTracks = data.subtitles;
              assignTrackIdsByGroup(subtitleTracks);
            }
            var unsortedLevels = levels.slice(0);
            levels.sort(function(a, b) {
              if (a.attrs["HDCP-LEVEL"] !== b.attrs["HDCP-LEVEL"]) {
                return (a.attrs["HDCP-LEVEL"] || "") > (b.attrs["HDCP-LEVEL"] || "") ? 1 : -1;
              }
              if (resolutionFound && a.height !== b.height) {
                return a.height - b.height;
              }
              if (a.frameRate !== b.frameRate) {
                return a.frameRate - b.frameRate;
              }
              if (a.videoRange !== b.videoRange) {
                return VideoRangeValues.indexOf(a.videoRange) - VideoRangeValues.indexOf(b.videoRange);
              }
              if (a.videoCodec !== b.videoCodec) {
                var valueA = videoCodecPreferenceValue(a.videoCodec);
                var valueB = videoCodecPreferenceValue(b.videoCodec);
                if (valueA !== valueB) {
                  return valueB - valueA;
                }
              }
              if (a.uri === b.uri && a.codecSet !== b.codecSet) {
                var _valueA = codecsSetSelectionPreferenceValue(a.codecSet);
                var _valueB = codecsSetSelectionPreferenceValue(b.codecSet);
                if (_valueA !== _valueB) {
                  return _valueB - _valueA;
                }
              }
              if (a.averageBitrate !== b.averageBitrate) {
                return a.averageBitrate - b.averageBitrate;
              }
              return 0;
            });
            var firstLevelInPlaylist = unsortedLevels[0];
            if (this.steering) {
              levels = this.steering.filterParsedLevels(levels);
              if (levels.length !== unsortedLevels.length) {
                for (var i = 0; i < unsortedLevels.length; i++) {
                  if (unsortedLevels[i].pathwayId === levels[0].pathwayId) {
                    firstLevelInPlaylist = unsortedLevels[i];
                    break;
                  }
                }
              }
            }
            this._levels = levels;
            for (var _i = 0; _i < levels.length; _i++) {
              if (levels[_i] === firstLevelInPlaylist) {
                var _this$hls$userConfig;
                this._firstLevel = _i;
                var firstLevelBitrate = firstLevelInPlaylist.bitrate;
                var bandwidthEstimate = this.hls.bandwidthEstimate;
                this.log("manifest loaded, " + levels.length + " level(s) found, first bitrate: " + firstLevelBitrate);
                if (((_this$hls$userConfig = this.hls.userConfig) == null ? void 0 : _this$hls$userConfig.abrEwmaDefaultEstimate) === void 0) {
                  var startingBwEstimate = Math.min(firstLevelBitrate, this.hls.config.abrEwmaDefaultEstimateMax);
                  if (startingBwEstimate > bandwidthEstimate && bandwidthEstimate === this.hls.abrEwmaDefaultEstimate) {
                    this.hls.bandwidthEstimate = startingBwEstimate;
                  }
                }
                break;
              }
            }
            var audioOnly = audioCodecFound && !videoCodecFound;
            var edata = {
              levels,
              audioTracks,
              subtitleTracks,
              sessionData: data.sessionData,
              sessionKeys: data.sessionKeys,
              firstLevel: this._firstLevel,
              stats: data.stats,
              audio: audioCodecFound,
              video: videoCodecFound,
              altAudio: !audioOnly && audioTracks.some(function(t) {
                return !!t.url;
              })
            };
            this.hls.trigger(Events.MANIFEST_PARSED, edata);
          };
          _proto.onError = function onError(event, data) {
            if (data.fatal || !data.context) {
              return;
            }
            if (data.context.type === PlaylistContextType.LEVEL && data.context.level === this.level) {
              this.checkRetry(data);
            }
          };
          _proto.onFragBuffered = function onFragBuffered(event, _ref2) {
            var frag = _ref2.frag;
            if (frag !== void 0 && frag.type === PlaylistLevelType.MAIN) {
              var el = frag.elementaryStreams;
              if (!Object.keys(el).some(function(type) {
                return !!el[type];
              })) {
                return;
              }
              var level = this._levels[frag.level];
              if (level != null && level.loadError) {
                this.log("Resetting level error count of " + level.loadError + " on frag buffered");
                level.loadError = 0;
              }
            }
          };
          _proto.onLevelLoaded = function onLevelLoaded(event, data) {
            var _data$deliveryDirecti2;
            var level = data.level, details = data.details;
            var curLevel = data.levelInfo;
            if (!curLevel) {
              var _data$deliveryDirecti;
              this.warn("Invalid level index " + level);
              if ((_data$deliveryDirecti = data.deliveryDirectives) != null && _data$deliveryDirecti.skip) {
                details.deltaUpdateFailed = true;
              }
              return;
            }
            if (curLevel === this.currentLevel || data.withoutMultiVariant) {
              if (curLevel.fragmentError === 0) {
                curLevel.loadError = 0;
              }
              var previousDetails = curLevel.details;
              if (previousDetails === data.details && previousDetails.advanced) {
                previousDetails = void 0;
              }
              this.playlistLoaded(level, data, previousDetails);
            } else if ((_data$deliveryDirecti2 = data.deliveryDirectives) != null && _data$deliveryDirecti2.skip) {
              details.deltaUpdateFailed = true;
            }
          };
          _proto.loadPlaylist = function loadPlaylist(hlsUrlParameters) {
            _BasePlaylistControll.prototype.loadPlaylist.call(this);
            if (this.shouldLoadPlaylist(this.currentLevel)) {
              this.scheduleLoading(this.currentLevel, hlsUrlParameters);
            }
          };
          _proto.loadingPlaylist = function loadingPlaylist(currentLevel, hlsUrlParameters) {
            _BasePlaylistControll.prototype.loadingPlaylist.call(this, currentLevel, hlsUrlParameters);
            var url = this.getUrlWithDirectives(currentLevel.uri, hlsUrlParameters);
            var currentLevelIndex = this.currentLevelIndex;
            var pathwayId = currentLevel.attrs["PATHWAY-ID"];
            var details = currentLevel.details;
            var age = details == null ? void 0 : details.age;
            this.log("Loading level index " + currentLevelIndex + ((hlsUrlParameters == null ? void 0 : hlsUrlParameters.msn) !== void 0 ? " at sn " + hlsUrlParameters.msn + " part " + hlsUrlParameters.part : "") + (pathwayId ? " Pathway " + pathwayId : "") + (age && details.live ? " age " + age.toFixed(1) + (details.type ? " " + details.type || "" : "") : "") + " " + url);
            this.hls.trigger(Events.LEVEL_LOADING, {
              url,
              level: currentLevelIndex,
              levelInfo: currentLevel,
              pathwayId: currentLevel.attrs["PATHWAY-ID"],
              id: 0,
              // Deprecated Level urlId
              deliveryDirectives: hlsUrlParameters || null
            });
          };
          _proto.removeLevel = function removeLevel(levelIndex) {
            var _this4 = this, _this$currentLevel;
            if (this._levels.length === 1) {
              return;
            }
            var levels = this._levels.filter(function(level, index) {
              if (index !== levelIndex) {
                return true;
              }
              if (_this4.steering) {
                _this4.steering.removeLevel(level);
              }
              if (level === _this4.currentLevel) {
                _this4.currentLevel = null;
                _this4.currentLevelIndex = -1;
                if (level.details) {
                  level.details.fragments.forEach(function(f) {
                    return f.level = -1;
                  });
                }
              }
              return false;
            });
            reassignFragmentLevelIndexes(levels);
            this._levels = levels;
            if (this.currentLevelIndex > -1 && (_this$currentLevel = this.currentLevel) != null && _this$currentLevel.details) {
              this.currentLevelIndex = this.currentLevel.details.fragments[0].level;
            }
            if (this.manualLevelIndex > -1) {
              this.manualLevelIndex = this.currentLevelIndex;
            }
            var maxLevel = levels.length - 1;
            this._firstLevel = Math.min(this._firstLevel, maxLevel);
            if (this._startLevel) {
              this._startLevel = Math.min(this._startLevel, maxLevel);
            }
            this.hls.trigger(Events.LEVELS_UPDATED, {
              levels
            });
          };
          _proto.onLevelsUpdated = function onLevelsUpdated(event, _ref3) {
            var levels = _ref3.levels;
            this._levels = levels;
          };
          _proto.checkMaxAutoUpdated = function checkMaxAutoUpdated() {
            var _this$hls = this.hls, autoLevelCapping = _this$hls.autoLevelCapping, maxAutoLevel = _this$hls.maxAutoLevel, maxHdcpLevel = _this$hls.maxHdcpLevel;
            if (this._maxAutoLevel !== maxAutoLevel) {
              this._maxAutoLevel = maxAutoLevel;
              this.hls.trigger(Events.MAX_AUTO_LEVEL_UPDATED, {
                autoLevelCapping,
                levels: this.levels,
                maxAutoLevel,
                minAutoLevel: this.hls.minAutoLevel,
                maxHdcpLevel
              });
            }
          };
          return _createClass4(LevelController2, [{
            key: "levels",
            get: function get() {
              if (this._levels.length === 0) {
                return null;
              }
              return this._levels;
            }
          }, {
            key: "loadLevelObj",
            get: function get() {
              return this.currentLevel;
            }
          }, {
            key: "level",
            get: function get() {
              return this.currentLevelIndex;
            },
            set: function set(newLevel) {
              var levels = this._levels;
              if (levels.length === 0) {
                return;
              }
              if (newLevel < 0 || newLevel >= levels.length) {
                var error = new Error("invalid level idx");
                var fatal = newLevel < 0;
                this.hls.trigger(Events.ERROR, {
                  type: ErrorTypes.OTHER_ERROR,
                  details: ErrorDetails.LEVEL_SWITCH_ERROR,
                  level: newLevel,
                  fatal,
                  error,
                  reason: error.message
                });
                if (fatal) {
                  return;
                }
                newLevel = Math.min(newLevel, levels.length - 1);
              }
              var lastLevelIndex = this.currentLevelIndex;
              var lastLevel = this.currentLevel;
              var lastPathwayId = lastLevel ? lastLevel.attrs["PATHWAY-ID"] : void 0;
              var level = levels[newLevel];
              var pathwayId = level.attrs["PATHWAY-ID"];
              this.currentLevelIndex = newLevel;
              this.currentLevel = level;
              if (lastLevelIndex === newLevel && lastLevel && lastPathwayId === pathwayId) {
                return;
              }
              this.log("Switching to level " + newLevel + " (" + (level.height ? level.height + "p " : "") + (level.videoRange ? level.videoRange + " " : "") + (level.codecSet ? level.codecSet + " " : "") + "@" + level.bitrate + ")" + (pathwayId ? " with Pathway " + pathwayId : "") + " from level " + lastLevelIndex + (lastPathwayId ? " with Pathway " + lastPathwayId : ""));
              var levelSwitchingData = {
                level: newLevel,
                attrs: level.attrs,
                details: level.details,
                bitrate: level.bitrate,
                averageBitrate: level.averageBitrate,
                maxBitrate: level.maxBitrate,
                realBitrate: level.realBitrate,
                width: level.width,
                height: level.height,
                codecSet: level.codecSet,
                audioCodec: level.audioCodec,
                videoCodec: level.videoCodec,
                audioGroups: level.audioGroups,
                subtitleGroups: level.subtitleGroups,
                loaded: level.loaded,
                loadError: level.loadError,
                fragmentError: level.fragmentError,
                name: level.name,
                id: level.id,
                uri: level.uri,
                url: level.url,
                urlId: 0,
                audioGroupIds: level.audioGroupIds,
                textGroupIds: level.textGroupIds
              };
              this.hls.trigger(Events.LEVEL_SWITCHING, levelSwitchingData);
              var levelDetails = level.details;
              if (!levelDetails || levelDetails.live) {
                var hlsUrlParameters = this.switchParams(level.uri, lastLevel == null ? void 0 : lastLevel.details, levelDetails);
                this.loadPlaylist(hlsUrlParameters);
              }
            }
          }, {
            key: "manualLevel",
            get: function get() {
              return this.manualLevelIndex;
            },
            set: function set(newLevel) {
              this.manualLevelIndex = newLevel;
              if (this._startLevel === void 0) {
                this._startLevel = newLevel;
              }
              if (newLevel !== -1) {
                this.level = newLevel;
              }
            }
          }, {
            key: "firstLevel",
            get: function get() {
              return this._firstLevel;
            },
            set: function set(newLevel) {
              this._firstLevel = newLevel;
            }
          }, {
            key: "startLevel",
            get: function get() {
              if (this._startLevel === void 0) {
                var configStartLevel = this.hls.config.startLevel;
                if (configStartLevel !== void 0) {
                  return configStartLevel;
                }
                return this.hls.firstAutoLevel;
              }
              return this._startLevel;
            },
            set: function set(newLevel) {
              this._startLevel = newLevel;
            }
          }, {
            key: "pathways",
            get: function get() {
              if (this.steering) {
                return this.steering.pathways();
              }
              return [];
            }
          }, {
            key: "pathwayPriority",
            get: function get() {
              if (this.steering) {
                return this.steering.pathwayPriority;
              }
              return null;
            },
            set: function set(pathwayPriority) {
              if (this.steering) {
                var pathwaysList = this.steering.pathways();
                var filteredPathwayPriority = pathwayPriority.filter(function(pathwayId) {
                  return pathwaysList.indexOf(pathwayId) !== -1;
                });
                if (pathwayPriority.length < 1) {
                  this.warn("pathwayPriority " + pathwayPriority + " should contain at least one pathway from list: " + pathwaysList);
                  return;
                }
                this.steering.pathwayPriority = filteredPathwayPriority;
              }
            }
          }, {
            key: "nextLoadLevel",
            get: function get() {
              if (this.manualLevelIndex !== -1) {
                return this.manualLevelIndex;
              } else {
                return this.hls.nextAutoLevel;
              }
            },
            set: function set(nextLevel) {
              this.level = nextLevel;
              if (this.manualLevelIndex === -1) {
                this.hls.nextAutoLevel = nextLevel;
              }
            }
          }]);
        }(BasePlaylistController);
        function assignTrackIdsByGroup(tracks) {
          var groups = {};
          tracks.forEach(function(track) {
            var groupId = track.groupId || "";
            track.id = groups[groupId] = groups[groupId] || 0;
            groups[groupId]++;
          });
        }
        var transmuxers = [];
        if (typeof __IN_WORKER__ !== "undefined" && __IN_WORKER__) {
          startWorker();
        }
        function startWorker() {
          self.addEventListener("message", function(ev) {
            var data = ev.data;
            var instanceNo = data.instanceNo;
            if (instanceNo === void 0) {
              return;
            }
            var transmuxer = transmuxers[instanceNo];
            if (data.cmd === "reset") {
              delete transmuxers[data.resetNo];
              if (transmuxer) {
                transmuxer.destroy();
              }
              data.cmd = "init";
            }
            if (data.cmd === "init") {
              var config = JSON.parse(data.config);
              var observer = new EventEmitter5();
              observer.on(Events.FRAG_DECRYPTED, forwardMessage);
              observer.on(Events.ERROR, forwardMessage);
              var logger5 = enableLogs(config.debug, data.id);
              forwardWorkerLogs(logger5, instanceNo);
              transmuxers[instanceNo] = new Transmuxer(observer, data.typeSupported, config, "", data.id, logger5);
              forwardMessage("init", null, instanceNo);
              return;
            }
            if (!transmuxer) {
              return;
            }
            switch (data.cmd) {
              case "configure": {
                transmuxer.configure(data.config);
                break;
              }
              case "demux": {
                var transmuxResult = transmuxer.push(data.data, data.decryptdata, data.chunkMeta, data.state);
                if (isPromise(transmuxResult)) {
                  transmuxResult.then(function(data2) {
                    emitTransmuxComplete(self, data2, instanceNo);
                  }).catch(function(error) {
                    forwardMessage(Events.ERROR, {
                      instanceNo,
                      type: ErrorTypes.MEDIA_ERROR,
                      details: ErrorDetails.FRAG_PARSING_ERROR,
                      chunkMeta: data.chunkMeta,
                      fatal: false,
                      error,
                      err: error,
                      reason: "transmuxer-worker push error"
                    }, instanceNo);
                  });
                } else {
                  emitTransmuxComplete(self, transmuxResult, instanceNo);
                }
                break;
              }
              case "flush": {
                var chunkMeta = data.chunkMeta;
                var _transmuxResult = transmuxer.flush(chunkMeta);
                if (isPromise(_transmuxResult)) {
                  _transmuxResult.then(function(results) {
                    handleFlushResult(self, results, chunkMeta, instanceNo);
                  }).catch(function(error) {
                    forwardMessage(Events.ERROR, {
                      type: ErrorTypes.MEDIA_ERROR,
                      details: ErrorDetails.FRAG_PARSING_ERROR,
                      chunkMeta: data.chunkMeta,
                      fatal: false,
                      error,
                      err: error,
                      reason: "transmuxer-worker flush error"
                    }, instanceNo);
                  });
                } else {
                  handleFlushResult(self, _transmuxResult, chunkMeta, instanceNo);
                }
                break;
              }
            }
          });
        }
        function emitTransmuxComplete(self2, transmuxResult, instanceNo) {
          if (isEmptyResult(transmuxResult.remuxResult)) {
            return false;
          }
          var transferable = [];
          var _transmuxResult$remux = transmuxResult.remuxResult, audio = _transmuxResult$remux.audio, video = _transmuxResult$remux.video;
          if (audio) {
            addToTransferable(transferable, audio);
          }
          if (video) {
            addToTransferable(transferable, video);
          }
          self2.postMessage({
            event: "transmuxComplete",
            data: transmuxResult,
            instanceNo
          }, transferable);
          return true;
        }
        function addToTransferable(transferable, track) {
          if (track.data1) {
            transferable.push(track.data1.buffer);
          }
          if (track.data2) {
            transferable.push(track.data2.buffer);
          }
        }
        function handleFlushResult(self2, results, chunkMeta, instanceNo) {
          var parsed = results.reduce(function(parsed2, result) {
            return emitTransmuxComplete(self2, result, instanceNo) || parsed2;
          }, false);
          if (!parsed) {
            self2.postMessage({
              event: "transmuxComplete",
              data: results[0],
              instanceNo
            });
          }
          self2.postMessage({
            event: "flush",
            data: chunkMeta,
            instanceNo
          });
        }
        function forwardMessage(event, data, instanceNo) {
          self.postMessage({
            event,
            data,
            instanceNo
          });
        }
        function forwardWorkerLogs(logger5, instanceNo) {
          var _loop = function _loop2(logFn2) {
            var func = function func2(message) {
              forwardMessage("workerLog", {
                logType: logFn2,
                message
              }, instanceNo);
            };
            logger5[logFn2] = func;
          };
          for (var logFn in logger5) {
            _loop(logFn);
          }
        }
        function isEmptyResult(remuxResult) {
          return !remuxResult.audio && !remuxResult.video && !remuxResult.text && !remuxResult.id3 && !remuxResult.initSegment;
        }
        var version = "1.6.0";
        var workerStore = {};
        function hasUMDWorker() {
          return typeof __HLS_WORKER_BUNDLE__ === "function";
        }
        function injectWorker() {
          var workerContext = workerStore[version];
          if (workerContext) {
            workerContext.clientCount++;
            return workerContext;
          }
          var blob = new self.Blob(["var exports={};var module={exports:exports};function define(f){f()};define.amd=true;(" + __HLS_WORKER_BUNDLE__.toString() + ")(true);"], {
            type: "text/javascript"
          });
          var objectURL = self.URL.createObjectURL(blob);
          var worker = new self.Worker(objectURL);
          var result = {
            worker,
            objectURL,
            clientCount: 1
          };
          workerStore[version] = result;
          return result;
        }
        function loadWorker(path) {
          var workerContext = workerStore[path];
          if (workerContext) {
            workerContext.clientCount++;
            return workerContext;
          }
          var scriptURL = new self.URL(path, self.location.href).href;
          var worker = new self.Worker(scriptURL);
          var result = {
            worker,
            scriptURL,
            clientCount: 1
          };
          workerStore[path] = result;
          return result;
        }
        function removeWorkerFromStore(path) {
          var workerContext = workerStore[path || version];
          if (workerContext) {
            var clientCount = workerContext.clientCount--;
            if (clientCount === 1) {
              var worker = workerContext.worker, objectURL = workerContext.objectURL;
              delete workerStore[path || version];
              if (objectURL) {
                self.URL.revokeObjectURL(objectURL);
              }
              worker.terminate();
            }
          }
        }
        var transmuxerInstanceCount = 0;
        var TransmuxerInterface = /* @__PURE__ */ function() {
          function TransmuxerInterface2(_hls, id, onTransmuxComplete, onFlush) {
            var _this = this;
            this.error = null;
            this.hls = void 0;
            this.id = void 0;
            this.instanceNo = transmuxerInstanceCount++;
            this.observer = void 0;
            this.frag = null;
            this.part = null;
            this.useWorker = void 0;
            this.workerContext = null;
            this.transmuxer = null;
            this.onTransmuxComplete = void 0;
            this.onFlush = void 0;
            this.onWorkerMessage = function(event) {
              var data = event.data;
              var hls = _this.hls;
              if (!hls || !(data != null && data.event) || data.instanceNo !== _this.instanceNo) {
                return;
              }
              switch (data.event) {
                case "init": {
                  var _this$workerContext;
                  var objectURL = (_this$workerContext = _this.workerContext) == null ? void 0 : _this$workerContext.objectURL;
                  if (objectURL) {
                    self.URL.revokeObjectURL(objectURL);
                  }
                  break;
                }
                case "transmuxComplete": {
                  _this.handleTransmuxComplete(data.data);
                  break;
                }
                case "flush": {
                  _this.onFlush(data.data);
                  break;
                }
                // pass logs from the worker thread to the main logger
                case "workerLog": {
                  if (hls.logger[data.data.logType]) {
                    hls.logger[data.data.logType](data.data.message);
                  }
                  break;
                }
                default: {
                  data.data = data.data || {};
                  data.data.frag = _this.frag;
                  data.data.part = _this.part;
                  data.data.id = _this.id;
                  hls.trigger(data.event, data.data);
                  break;
                }
              }
            };
            this.onWorkerError = function(event) {
              if (!_this.hls) {
                return;
              }
              var error = new Error(event.message + "  (" + event.filename + ":" + event.lineno + ")");
              _this.hls.config.enableWorker = false;
              _this.hls.logger.warn('Error in "' + _this.id + '" Web Worker, fallback to inline');
              _this.hls.trigger(Events.ERROR, {
                type: ErrorTypes.OTHER_ERROR,
                details: ErrorDetails.INTERNAL_EXCEPTION,
                fatal: false,
                event: "demuxerWorker",
                error
              });
            };
            var config = _hls.config;
            this.hls = _hls;
            this.id = id;
            this.useWorker = !!config.enableWorker;
            this.onTransmuxComplete = onTransmuxComplete;
            this.onFlush = onFlush;
            var forwardMessage2 = function forwardMessage3(ev, data) {
              data = data || {};
              data.frag = _this.frag || void 0;
              if (ev === Events.ERROR) {
                data = data;
                data.parent = _this.id;
                data.part = _this.part;
                _this.error = data.error;
              }
              _this.hls.trigger(ev, data);
            };
            this.observer = new EventEmitter5();
            this.observer.on(Events.FRAG_DECRYPTED, forwardMessage2);
            this.observer.on(Events.ERROR, forwardMessage2);
            var m2tsTypeSupported = getM2TSSupportedAudioTypes(config.preferManagedMediaSource);
            if (this.useWorker && typeof Worker !== "undefined") {
              var logger5 = this.hls.logger;
              var canCreateWorker = config.workerPath || hasUMDWorker();
              if (canCreateWorker) {
                try {
                  if (config.workerPath) {
                    logger5.log("loading Web Worker " + config.workerPath + ' for "' + id + '"');
                    this.workerContext = loadWorker(config.workerPath);
                  } else {
                    logger5.log('injecting Web Worker for "' + id + '"');
                    this.workerContext = injectWorker();
                  }
                  var worker = this.workerContext.worker;
                  worker.addEventListener("message", this.onWorkerMessage);
                  worker.addEventListener("error", this.onWorkerError);
                  worker.postMessage({
                    instanceNo: this.instanceNo,
                    cmd: "init",
                    typeSupported: m2tsTypeSupported,
                    id,
                    config: stringify2(config)
                  });
                } catch (err) {
                  logger5.warn('Error setting up "' + id + '" Web Worker, fallback to inline', err);
                  this.terminateWorker();
                  this.error = null;
                  this.transmuxer = new Transmuxer(this.observer, m2tsTypeSupported, config, "", id, _hls.logger);
                }
                return;
              }
            }
            this.transmuxer = new Transmuxer(this.observer, m2tsTypeSupported, config, "", id, _hls.logger);
          }
          var _proto = TransmuxerInterface2.prototype;
          _proto.reset = function reset() {
            this.frag = null;
            this.part = null;
            if (this.workerContext) {
              var instanceNo = this.instanceNo;
              this.instanceNo = transmuxerInstanceCount++;
              var config = this.hls.config;
              var m2tsTypeSupported = getM2TSSupportedAudioTypes(config.preferManagedMediaSource);
              this.workerContext.worker.postMessage({
                instanceNo: this.instanceNo,
                cmd: "reset",
                resetNo: instanceNo,
                typeSupported: m2tsTypeSupported,
                id: this.id,
                config: stringify2(config)
              });
            }
          };
          _proto.terminateWorker = function terminateWorker() {
            if (this.workerContext) {
              var worker = this.workerContext.worker;
              this.workerContext = null;
              worker.removeEventListener("message", this.onWorkerMessage);
              worker.removeEventListener("error", this.onWorkerError);
              removeWorkerFromStore(this.hls.config.workerPath);
            }
          };
          _proto.destroy = function destroy() {
            if (this.workerContext) {
              this.terminateWorker();
              this.onWorkerMessage = this.onWorkerError = null;
            } else {
              var transmuxer = this.transmuxer;
              if (transmuxer) {
                transmuxer.destroy();
                this.transmuxer = null;
              }
            }
            var observer = this.observer;
            if (observer) {
              observer.removeAllListeners();
            }
            this.frag = null;
            this.part = null;
            this.observer = null;
            this.hls = null;
          };
          _proto.push = function push2(data, initSegmentData, audioCodec, videoCodec, frag, part, duration, accurateTimeOffset, chunkMeta, defaultInitPTS) {
            var _frag$initSegment, _lastFrag$initSegment, _this2 = this;
            chunkMeta.transmuxing.start = self.performance.now();
            var instanceNo = this.instanceNo, transmuxer = this.transmuxer;
            var timeOffset = part ? part.start : frag.start;
            var decryptdata = frag.decryptdata;
            var lastFrag = this.frag;
            var discontinuity = !(lastFrag && frag.cc === lastFrag.cc);
            var trackSwitch = !(lastFrag && chunkMeta.level === lastFrag.level);
            var snDiff = lastFrag ? chunkMeta.sn - lastFrag.sn : -1;
            var partDiff = this.part ? chunkMeta.part - this.part.index : -1;
            var progressive = snDiff === 0 && chunkMeta.id > 1 && chunkMeta.id === (lastFrag == null ? void 0 : lastFrag.stats.chunkCount);
            var contiguous = !trackSwitch && (snDiff === 1 || snDiff === 0 && (partDiff === 1 || progressive && partDiff <= 0));
            var now2 = self.performance.now();
            if (trackSwitch || snDiff || frag.stats.parsing.start === 0) {
              frag.stats.parsing.start = now2;
            }
            if (part && (partDiff || !contiguous)) {
              part.stats.parsing.start = now2;
            }
            var initSegmentChange = !(lastFrag && ((_frag$initSegment = frag.initSegment) == null ? void 0 : _frag$initSegment.url) === ((_lastFrag$initSegment = lastFrag.initSegment) == null ? void 0 : _lastFrag$initSegment.url));
            var state = new TransmuxState(discontinuity, contiguous, accurateTimeOffset, trackSwitch, timeOffset, initSegmentChange);
            if (!contiguous || discontinuity || initSegmentChange) {
              this.hls.logger.log("[transmuxer-interface]: Starting new transmux session for " + frag.type + " sn: " + chunkMeta.sn + (chunkMeta.part > -1 ? " part: " + chunkMeta.part : "") + " " + (this.id === PlaylistLevelType.MAIN ? "level" : "track") + ": " + chunkMeta.level + " id: " + chunkMeta.id + "\n        discontinuity: " + discontinuity + "\n        trackSwitch: " + trackSwitch + "\n        contiguous: " + contiguous + "\n        accurateTimeOffset: " + accurateTimeOffset + "\n        timeOffset: " + timeOffset + "\n        initSegmentChange: " + initSegmentChange);
              var config = new TransmuxConfig(audioCodec, videoCodec, initSegmentData, duration, defaultInitPTS);
              this.configureTransmuxer(config);
            }
            this.frag = frag;
            this.part = part;
            if (this.workerContext) {
              this.workerContext.worker.postMessage({
                instanceNo,
                cmd: "demux",
                data,
                decryptdata,
                chunkMeta,
                state
              }, data instanceof ArrayBuffer ? [data] : []);
            } else if (transmuxer) {
              var transmuxResult = transmuxer.push(data, decryptdata, chunkMeta, state);
              if (isPromise(transmuxResult)) {
                transmuxResult.then(function(data2) {
                  _this2.handleTransmuxComplete(data2);
                }).catch(function(error) {
                  _this2.transmuxerError(error, chunkMeta, "transmuxer-interface push error");
                });
              } else {
                this.handleTransmuxComplete(transmuxResult);
              }
            }
          };
          _proto.flush = function flush(chunkMeta) {
            var _this3 = this;
            chunkMeta.transmuxing.start = self.performance.now();
            var instanceNo = this.instanceNo, transmuxer = this.transmuxer;
            if (this.workerContext) {
              this.workerContext.worker.postMessage({
                instanceNo,
                cmd: "flush",
                chunkMeta
              });
            } else if (transmuxer) {
              var transmuxResult = transmuxer.flush(chunkMeta);
              if (isPromise(transmuxResult)) {
                transmuxResult.then(function(data) {
                  _this3.handleFlushResult(data, chunkMeta);
                }).catch(function(error) {
                  _this3.transmuxerError(error, chunkMeta, "transmuxer-interface flush error");
                });
              } else {
                this.handleFlushResult(transmuxResult, chunkMeta);
              }
            }
          };
          _proto.transmuxerError = function transmuxerError(error, chunkMeta, reason) {
            if (!this.hls) {
              return;
            }
            this.error = error;
            this.hls.trigger(Events.ERROR, {
              type: ErrorTypes.MEDIA_ERROR,
              details: ErrorDetails.FRAG_PARSING_ERROR,
              chunkMeta,
              frag: this.frag || void 0,
              part: this.part || void 0,
              fatal: false,
              error,
              err: error,
              reason
            });
          };
          _proto.handleFlushResult = function handleFlushResult2(results, chunkMeta) {
            var _this4 = this;
            results.forEach(function(result) {
              _this4.handleTransmuxComplete(result);
            });
            this.onFlush(chunkMeta);
          };
          _proto.configureTransmuxer = function configureTransmuxer(config) {
            var instanceNo = this.instanceNo, transmuxer = this.transmuxer;
            if (this.workerContext) {
              this.workerContext.worker.postMessage({
                instanceNo,
                cmd: "configure",
                config
              });
            } else if (transmuxer) {
              transmuxer.configure(config);
            }
          };
          _proto.handleTransmuxComplete = function handleTransmuxComplete(result) {
            result.chunkMeta.transmuxing.end = self.performance.now();
            this.onTransmuxComplete(result);
          };
          return TransmuxerInterface2;
        }();
        function getSourceBuffer() {
          return self.SourceBuffer || self.WebKitSourceBuffer;
        }
        function isMSESupported() {
          var mediaSource = getMediaSource2();
          if (!mediaSource) {
            return false;
          }
          var sourceBuffer = getSourceBuffer();
          return !sourceBuffer || sourceBuffer.prototype && typeof sourceBuffer.prototype.appendBuffer === "function" && typeof sourceBuffer.prototype.remove === "function";
        }
        function isSupported() {
          if (!isMSESupported()) {
            return false;
          }
          var mediaSource = getMediaSource2();
          return typeof (mediaSource == null ? void 0 : mediaSource.isTypeSupported) === "function" && (["avc1.42E01E,mp4a.40.2", "av01.0.01M.08", "vp09.00.50.08"].some(function(codecsForVideoContainer) {
            return mediaSource.isTypeSupported(mimeTypeForCodec(codecsForVideoContainer, "video"));
          }) || ["mp4a.40.2", "fLaC"].some(function(codecForAudioContainer) {
            return mediaSource.isTypeSupported(mimeTypeForCodec(codecForAudioContainer, "audio"));
          }));
        }
        function changeTypeSupported() {
          var _sourceBuffer$prototy;
          var sourceBuffer = getSourceBuffer();
          return typeof (sourceBuffer == null ? void 0 : (_sourceBuffer$prototy = sourceBuffer.prototype) == null ? void 0 : _sourceBuffer$prototy.changeType) === "function";
        }
        var TICK_INTERVAL = 100;
        var StreamController = /* @__PURE__ */ function(_BaseStreamController) {
          function StreamController2(hls, fragmentTracker, keyLoader) {
            var _this;
            _this = _BaseStreamController.call(this, hls, fragmentTracker, keyLoader, "stream-controller", PlaylistLevelType.MAIN) || this;
            _this.audioCodecSwap = false;
            _this.level = -1;
            _this._forceStartLoad = false;
            _this._hasEnoughToStart = false;
            _this.altAudio = 0;
            _this.audioOnly = false;
            _this.fragPlaying = null;
            _this.fragLastKbps = 0;
            _this.couldBacktrack = false;
            _this.backtrackFragment = null;
            _this.audioCodecSwitch = false;
            _this.videoBuffer = null;
            _this.onMediaPlaying = function() {
              _this.tick();
            };
            _this.onMediaSeeked = function() {
              var media = _this.media;
              var currentTime = media ? media.currentTime : null;
              if (currentTime === null || !isFiniteNumber(currentTime)) {
                return;
              }
              _this.log("Media seeked to " + currentTime.toFixed(3));
              if (!_this.getBufferedFrag(currentTime)) {
                return;
              }
              var bufferInfo = _this.getFwdBufferInfoAtPos(media, currentTime, PlaylistLevelType.MAIN, 0);
              if (bufferInfo === null || bufferInfo.len === 0) {
                _this.warn("Main forward buffer length at " + currentTime + ' on "seeked" event ' + (bufferInfo ? bufferInfo.len : "empty") + ")");
                return;
              }
              _this.tick();
            };
            _this.registerListeners();
            return _this;
          }
          _inheritsLoose(StreamController2, _BaseStreamController);
          var _proto = StreamController2.prototype;
          _proto.registerListeners = function registerListeners() {
            _BaseStreamController.prototype.registerListeners.call(this);
            var hls = this.hls;
            hls.on(Events.MANIFEST_PARSED, this.onManifestParsed, this);
            hls.on(Events.LEVEL_LOADING, this.onLevelLoading, this);
            hls.on(Events.LEVEL_LOADED, this.onLevelLoaded, this);
            hls.on(Events.FRAG_LOAD_EMERGENCY_ABORTED, this.onFragLoadEmergencyAborted, this);
            hls.on(Events.AUDIO_TRACK_SWITCHING, this.onAudioTrackSwitching, this);
            hls.on(Events.AUDIO_TRACK_SWITCHED, this.onAudioTrackSwitched, this);
            hls.on(Events.BUFFER_CREATED, this.onBufferCreated, this);
            hls.on(Events.BUFFER_FLUSHED, this.onBufferFlushed, this);
            hls.on(Events.LEVELS_UPDATED, this.onLevelsUpdated, this);
            hls.on(Events.FRAG_BUFFERED, this.onFragBuffered, this);
          };
          _proto.unregisterListeners = function unregisterListeners() {
            _BaseStreamController.prototype.unregisterListeners.call(this);
            var hls = this.hls;
            hls.off(Events.MANIFEST_PARSED, this.onManifestParsed, this);
            hls.off(Events.LEVEL_LOADED, this.onLevelLoaded, this);
            hls.off(Events.FRAG_LOAD_EMERGENCY_ABORTED, this.onFragLoadEmergencyAborted, this);
            hls.off(Events.AUDIO_TRACK_SWITCHING, this.onAudioTrackSwitching, this);
            hls.off(Events.AUDIO_TRACK_SWITCHED, this.onAudioTrackSwitched, this);
            hls.off(Events.BUFFER_CREATED, this.onBufferCreated, this);
            hls.off(Events.BUFFER_FLUSHED, this.onBufferFlushed, this);
            hls.off(Events.LEVELS_UPDATED, this.onLevelsUpdated, this);
            hls.off(Events.FRAG_BUFFERED, this.onFragBuffered, this);
          };
          _proto.onHandlerDestroying = function onHandlerDestroying() {
            this.onMediaPlaying = this.onMediaSeeked = null;
            this.unregisterListeners();
            _BaseStreamController.prototype.onHandlerDestroying.call(this);
          };
          _proto.startLoad = function startLoad(startPosition, skipSeekToStartPosition) {
            if (this.levels) {
              var lastCurrentTime = this.lastCurrentTime, hls = this.hls;
              this.stopLoad();
              this.setInterval(TICK_INTERVAL);
              this.level = -1;
              if (!this.startFragRequested) {
                var startLevel = hls.startLevel;
                if (startLevel === -1) {
                  if (hls.config.testBandwidth && this.levels.length > 1) {
                    startLevel = 0;
                    this.bitrateTest = true;
                  } else {
                    startLevel = hls.firstAutoLevel;
                  }
                }
                hls.nextLoadLevel = startLevel;
                this.level = hls.loadLevel;
                this._hasEnoughToStart = !!skipSeekToStartPosition;
              }
              if (lastCurrentTime > 0 && startPosition === -1 && !skipSeekToStartPosition) {
                this.log("Override startPosition with lastCurrentTime @" + lastCurrentTime.toFixed(3));
                startPosition = lastCurrentTime;
              }
              this.state = State.IDLE;
              this.nextLoadPosition = this.lastCurrentTime = startPosition + this.timelineOffset;
              this.startPosition = skipSeekToStartPosition ? -1 : startPosition;
              this.tick();
            } else {
              this._forceStartLoad = true;
              this.state = State.STOPPED;
            }
          };
          _proto.stopLoad = function stopLoad() {
            this._forceStartLoad = false;
            _BaseStreamController.prototype.stopLoad.call(this);
          };
          _proto.doTick = function doTick() {
            switch (this.state) {
              case State.WAITING_LEVEL: {
                var levels = this.levels, level = this.level;
                var currentLevel = levels == null ? void 0 : levels[level];
                var details = currentLevel == null ? void 0 : currentLevel.details;
                if (details && (!details.live || this.levelLastLoaded === currentLevel && !this.waitForLive(currentLevel))) {
                  if (this.waitForCdnTuneIn(details)) {
                    break;
                  }
                  this.state = State.IDLE;
                  break;
                } else if (this.hls.nextLoadLevel !== this.level) {
                  this.state = State.IDLE;
                  break;
                }
                break;
              }
              case State.FRAG_LOADING_WAITING_RETRY:
                {
                  var _this$media;
                  var now2 = self.performance.now();
                  var retryDate = this.retryDate;
                  if (!retryDate || now2 >= retryDate || (_this$media = this.media) != null && _this$media.seeking) {
                    var _levels = this.levels, _level = this.level;
                    var _currentLevel = _levels == null ? void 0 : _levels[_level];
                    this.resetStartWhenNotLoaded(_currentLevel || null);
                    this.state = State.IDLE;
                  }
                }
                break;
            }
            if (this.state === State.IDLE) {
              this.doTickIdle();
            }
            this.onTickEnd();
          };
          _proto.onTickEnd = function onTickEnd() {
            var _this$media2;
            _BaseStreamController.prototype.onTickEnd.call(this);
            if ((_this$media2 = this.media) != null && _this$media2.readyState && this.media.seeking === false) {
              this.lastCurrentTime = this.media.currentTime;
            }
            this.checkFragmentChanged();
          };
          _proto.doTickIdle = function doTickIdle() {
            var hls = this.hls, levelLastLoaded = this.levelLastLoaded, levels = this.levels, media = this.media;
            if (levelLastLoaded === null || !media && !this.primaryPrefetch && (this.startFragRequested || !hls.config.startFragPrefetch)) {
              return;
            }
            if (this.altAudio && this.audioOnly) {
              return;
            }
            var level = this.buffering ? hls.nextLoadLevel : hls.loadLevel;
            if (!(levels != null && levels[level])) {
              return;
            }
            var levelInfo = levels[level];
            var bufferInfo = this.getMainFwdBufferInfo();
            if (bufferInfo === null) {
              return;
            }
            var lastDetails = this.getLevelDetails();
            if (lastDetails && this._streamEnded(bufferInfo, lastDetails)) {
              var data = {};
              if (this.altAudio === 2) {
                data.type = "video";
              }
              this.hls.trigger(Events.BUFFER_EOS, data);
              this.state = State.ENDED;
              return;
            }
            if (!this.buffering) {
              return;
            }
            if (hls.loadLevel !== level && hls.manualLevel === -1) {
              this.log("Adapting to level " + level + " from level " + this.level);
            }
            this.level = hls.nextLoadLevel = level;
            var levelDetails = levelInfo.details;
            if (!levelDetails || this.state === State.WAITING_LEVEL || this.waitForLive(levelInfo)) {
              this.level = level;
              this.state = State.WAITING_LEVEL;
              this.startFragRequested = false;
              return;
            }
            var bufferLen = bufferInfo.len;
            var maxBufLen = this.getMaxBufferLength(levelInfo.maxBitrate);
            if (bufferLen >= maxBufLen) {
              return;
            }
            if (this.backtrackFragment && this.backtrackFragment.start > bufferInfo.end) {
              this.backtrackFragment = null;
            }
            var targetBufferTime = this.backtrackFragment ? this.backtrackFragment.start : bufferInfo.end;
            var frag = this.getNextFragment(targetBufferTime, levelDetails);
            if (this.couldBacktrack && !this.fragPrevious && frag && isMediaFragment(frag) && this.fragmentTracker.getState(frag) !== FragmentState.OK) {
              var _this$backtrackFragme;
              var backtrackSn = ((_this$backtrackFragme = this.backtrackFragment) != null ? _this$backtrackFragme : frag).sn;
              var fragIdx = backtrackSn - levelDetails.startSN;
              var backtrackFrag = levelDetails.fragments[fragIdx - 1];
              if (backtrackFrag && frag.cc === backtrackFrag.cc) {
                frag = backtrackFrag;
                this.fragmentTracker.removeFragment(backtrackFrag);
              }
            } else if (this.backtrackFragment && bufferInfo.len) {
              this.backtrackFragment = null;
            }
            if (frag && this.isLoopLoading(frag, targetBufferTime)) {
              var gapStart = frag.gap;
              if (!gapStart) {
                var type = this.audioOnly && !this.altAudio ? ElementaryStreamTypes.AUDIO : ElementaryStreamTypes.VIDEO;
                var mediaBuffer = (type === ElementaryStreamTypes.VIDEO ? this.videoBuffer : this.mediaBuffer) || this.media;
                if (mediaBuffer) {
                  this.afterBufferFlushed(mediaBuffer, type, PlaylistLevelType.MAIN);
                }
              }
              frag = this.getNextFragmentLoopLoading(frag, levelDetails, bufferInfo, PlaylistLevelType.MAIN, maxBufLen);
            }
            if (!frag) {
              return;
            }
            if (frag.initSegment && !frag.initSegment.data && !this.bitrateTest) {
              frag = frag.initSegment;
            }
            this.loadFragment(frag, levelInfo, targetBufferTime);
          };
          _proto.loadFragment = function loadFragment(frag, level, targetBufferTime) {
            var fragState = this.fragmentTracker.getState(frag);
            if (fragState === FragmentState.NOT_LOADED || fragState === FragmentState.PARTIAL) {
              if (!isMediaFragment(frag)) {
                this._loadInitSegment(frag, level);
              } else if (this.bitrateTest) {
                this.log("Fragment " + frag.sn + " of level " + frag.level + " is being downloaded to test bitrate and will not be buffered");
                this._loadBitrateTestFrag(frag, level);
              } else {
                _BaseStreamController.prototype.loadFragment.call(this, frag, level, targetBufferTime);
              }
            } else {
              this.clearTrackerIfNeeded(frag);
            }
          };
          _proto.getBufferedFrag = function getBufferedFrag(position) {
            return this.fragmentTracker.getBufferedFrag(position, PlaylistLevelType.MAIN);
          };
          _proto.followingBufferedFrag = function followingBufferedFrag(frag) {
            if (frag) {
              return this.getBufferedFrag(frag.end + 0.5);
            }
            return null;
          };
          _proto.immediateLevelSwitch = function immediateLevelSwitch() {
            this.abortCurrentFrag();
            this.flushMainBuffer(0, Number.POSITIVE_INFINITY);
          };
          _proto.nextLevelSwitch = function nextLevelSwitch() {
            var levels = this.levels, media = this.media;
            if (media != null && media.readyState) {
              var fetchdelay;
              var fragPlayingCurrent = this.getAppendedFrag(media.currentTime);
              if (fragPlayingCurrent && fragPlayingCurrent.start > 1) {
                this.flushMainBuffer(0, fragPlayingCurrent.start - 1);
              }
              var levelDetails = this.getLevelDetails();
              if (levelDetails != null && levelDetails.live) {
                var bufferInfo = this.getMainFwdBufferInfo();
                if (!bufferInfo || bufferInfo.len < levelDetails.targetduration * 2) {
                  return;
                }
              }
              if (!media.paused && levels) {
                var nextLevelId = this.hls.nextLoadLevel;
                var nextLevel = levels[nextLevelId];
                var fragLastKbps = this.fragLastKbps;
                if (fragLastKbps && this.fragCurrent) {
                  fetchdelay = this.fragCurrent.duration * nextLevel.maxBitrate / (1e3 * fragLastKbps) + 1;
                } else {
                  fetchdelay = 0;
                }
              } else {
                fetchdelay = 0;
              }
              var bufferedFrag = this.getBufferedFrag(media.currentTime + fetchdelay);
              if (bufferedFrag) {
                var nextBufferedFrag = this.followingBufferedFrag(bufferedFrag);
                if (nextBufferedFrag) {
                  this.abortCurrentFrag();
                  var maxStart = nextBufferedFrag.maxStartPTS ? nextBufferedFrag.maxStartPTS : nextBufferedFrag.start;
                  var fragDuration = nextBufferedFrag.duration;
                  var startPts = Math.max(bufferedFrag.end, maxStart + Math.min(Math.max(fragDuration - this.config.maxFragLookUpTolerance, fragDuration * (this.couldBacktrack ? 0.5 : 0.125)), fragDuration * (this.couldBacktrack ? 0.75 : 0.25)));
                  this.flushMainBuffer(startPts, Number.POSITIVE_INFINITY);
                }
              }
            }
          };
          _proto.abortCurrentFrag = function abortCurrentFrag() {
            var fragCurrent = this.fragCurrent;
            this.fragCurrent = null;
            this.backtrackFragment = null;
            if (fragCurrent) {
              fragCurrent.abortRequests();
              this.fragmentTracker.removeFragment(fragCurrent);
            }
            switch (this.state) {
              case State.KEY_LOADING:
              case State.FRAG_LOADING:
              case State.FRAG_LOADING_WAITING_RETRY:
              case State.PARSING:
              case State.PARSED:
                this.state = State.IDLE;
                break;
            }
            this.nextLoadPosition = this.getLoadPosition();
          };
          _proto.flushMainBuffer = function flushMainBuffer(startOffset, endOffset) {
            _BaseStreamController.prototype.flushMainBuffer.call(this, startOffset, endOffset, this.altAudio === 2 ? "video" : null);
          };
          _proto.onMediaAttached = function onMediaAttached(event, data) {
            _BaseStreamController.prototype.onMediaAttached.call(this, event, data);
            var media = data.media;
            addEventListener(media, "playing", this.onMediaPlaying);
            addEventListener(media, "seeked", this.onMediaSeeked);
          };
          _proto.onMediaDetaching = function onMediaDetaching(event, data) {
            var media = this.media;
            if (media) {
              removeEventListener(media, "playing", this.onMediaPlaying);
              removeEventListener(media, "seeked", this.onMediaSeeked);
            }
            this.videoBuffer = null;
            this.fragPlaying = null;
            _BaseStreamController.prototype.onMediaDetaching.call(this, event, data);
            var transferringMedia = !!data.transferMedia;
            if (transferringMedia) {
              return;
            }
            this._hasEnoughToStart = false;
          };
          _proto.onManifestLoading = function onManifestLoading() {
            _BaseStreamController.prototype.onManifestLoading.call(this);
            this.log("Trigger BUFFER_RESET");
            this.hls.trigger(Events.BUFFER_RESET, void 0);
            this.couldBacktrack = false;
            this.fragLastKbps = 0;
            this.fragPlaying = this.backtrackFragment = null;
            this.altAudio = 0;
            this.audioOnly = false;
          };
          _proto.onManifestParsed = function onManifestParsed(event, data) {
            var aac = false;
            var heaac = false;
            data.levels.forEach(function(level) {
              var codec = level.audioCodec;
              if (codec) {
                aac = aac || codec.indexOf("mp4a.40.2") !== -1;
                heaac = heaac || codec.indexOf("mp4a.40.5") !== -1;
              }
            });
            this.audioCodecSwitch = aac && heaac && !changeTypeSupported();
            if (this.audioCodecSwitch) {
              this.log("Both AAC/HE-AAC audio found in levels; declaring level codec as HE-AAC");
            }
            this.levels = data.levels;
            this.startFragRequested = false;
          };
          _proto.onLevelLoading = function onLevelLoading(event, data) {
            var levels = this.levels;
            if (!levels || this.state !== State.IDLE) {
              return;
            }
            var level = data.levelInfo;
            if (!level.details || level.details.live && (this.levelLastLoaded !== level || level.details.expired) || this.waitForCdnTuneIn(level.details)) {
              this.state = State.WAITING_LEVEL;
            }
          };
          _proto.onLevelLoaded = function onLevelLoaded(event, data) {
            var _curLevel$details;
            var levels = this.levels, startFragRequested = this.startFragRequested;
            var newLevelId = data.level;
            var newDetails = data.details;
            var duration = newDetails.totalduration;
            if (!levels) {
              this.warn("Levels were reset while loading level " + newLevelId);
              return;
            }
            this.log("Level " + newLevelId + " loaded [" + newDetails.startSN + "," + newDetails.endSN + "]" + (newDetails.lastPartSn ? "[part-" + newDetails.lastPartSn + "-" + newDetails.lastPartIndex + "]" : "") + ", cc [" + newDetails.startCC + ", " + newDetails.endCC + "] duration:" + duration);
            var curLevel = data.levelInfo;
            var fragCurrent = this.fragCurrent;
            if (fragCurrent && (this.state === State.FRAG_LOADING || this.state === State.FRAG_LOADING_WAITING_RETRY)) {
              if (fragCurrent.level !== data.level && fragCurrent.loader) {
                this.abortCurrentFrag();
              }
            }
            var sliding = 0;
            if (newDetails.live || (_curLevel$details = curLevel.details) != null && _curLevel$details.live) {
              var _this$levelLastLoaded;
              this.checkLiveUpdate(newDetails);
              if (newDetails.deltaUpdateFailed) {
                return;
              }
              sliding = this.alignPlaylists(newDetails, curLevel.details, (_this$levelLastLoaded = this.levelLastLoaded) == null ? void 0 : _this$levelLastLoaded.details);
            }
            curLevel.details = newDetails;
            this.levelLastLoaded = curLevel;
            if (!startFragRequested) {
              this.setStartPosition(newDetails, sliding);
            }
            this.hls.trigger(Events.LEVEL_UPDATED, {
              details: newDetails,
              level: newLevelId
            });
            if (this.state === State.WAITING_LEVEL) {
              if (this.waitForCdnTuneIn(newDetails)) {
                return;
              }
              this.state = State.IDLE;
            }
            if (startFragRequested && newDetails.live) {
              this.synchronizeToLiveEdge(newDetails);
            }
            this.tick();
          };
          _proto.synchronizeToLiveEdge = function synchronizeToLiveEdge(levelDetails) {
            var config = this.config, media = this.media;
            if (!media) {
              return;
            }
            var liveSyncPosition = this.hls.liveSyncPosition;
            var currentTime = this.getLoadPosition();
            var start = levelDetails.fragmentStart;
            var end = levelDetails.edge;
            var withinSlidingWindow = currentTime >= start - config.maxFragLookUpTolerance && currentTime <= end;
            if (liveSyncPosition !== null && media.duration > liveSyncPosition && (currentTime < liveSyncPosition || !withinSlidingWindow)) {
              var maxLatency = config.liveMaxLatencyDuration !== void 0 ? config.liveMaxLatencyDuration : config.liveMaxLatencyDurationCount * levelDetails.targetduration;
              if (!withinSlidingWindow && media.readyState < 4 || currentTime < end - maxLatency) {
                if (!this._hasEnoughToStart) {
                  this.nextLoadPosition = liveSyncPosition;
                }
                if (media.readyState) {
                  this.warn("Playback: " + currentTime.toFixed(3) + " is located too far from the end of live sliding playlist: " + end + ", reset currentTime to : " + liveSyncPosition.toFixed(3));
                  media.currentTime = liveSyncPosition;
                }
              }
            }
          };
          _proto._handleFragmentLoadProgress = function _handleFragmentLoadProgress(data) {
            var _frag$initSegment;
            var frag = data.frag;
            var part = data.part, payload = data.payload;
            var levels = this.levels;
            if (!levels) {
              this.warn("Levels were reset while fragment load was in progress. Fragment " + frag.sn + " of level " + frag.level + " will not be buffered");
              return;
            }
            var currentLevel = levels[frag.level];
            if (!currentLevel) {
              this.warn("Level " + frag.level + " not found on progress");
              return;
            }
            var details = currentLevel.details;
            if (!details) {
              this.warn("Dropping fragment " + frag.sn + " of level " + frag.level + " after level details were reset");
              this.fragmentTracker.removeFragment(frag);
              return;
            }
            var videoCodec = currentLevel.videoCodec;
            var accurateTimeOffset = details.PTSKnown || !details.live;
            var initSegmentData = (_frag$initSegment = frag.initSegment) == null ? void 0 : _frag$initSegment.data;
            var audioCodec = this._getAudioCodec(currentLevel);
            var transmuxer = this.transmuxer = this.transmuxer || new TransmuxerInterface(this.hls, PlaylistLevelType.MAIN, this._handleTransmuxComplete.bind(this), this._handleTransmuxerFlush.bind(this));
            var partIndex = part ? part.index : -1;
            var partial = partIndex !== -1;
            var chunkMeta = new ChunkMetadata(frag.level, frag.sn, frag.stats.chunkCount, payload.byteLength, partIndex, partial);
            var initPTS = this.initPTS[frag.cc];
            transmuxer.push(payload, initSegmentData, audioCodec, videoCodec, frag, part, details.totalduration, accurateTimeOffset, chunkMeta, initPTS);
          };
          _proto.onAudioTrackSwitching = function onAudioTrackSwitching(event, data) {
            var _this2 = this;
            var hls = this.hls;
            var fromAltAudio = this.altAudio === 2;
            var altAudio = useAlternateAudio(data.url, hls);
            if (!altAudio) {
              if (this.mediaBuffer !== this.media) {
                this.log("Switching on main audio, use media.buffered to schedule main fragment loading");
                this.mediaBuffer = this.media;
                var fragCurrent = this.fragCurrent;
                if (fragCurrent) {
                  this.log("Switching to main audio track, cancel main fragment load");
                  fragCurrent.abortRequests();
                  this.fragmentTracker.removeFragment(fragCurrent);
                }
                this.resetTransmuxer();
                this.resetLoadingState();
              } else if (this.audioOnly) {
                this.resetTransmuxer();
              }
              if (fromAltAudio) {
                this.fragmentTracker.removeAllFragments();
                hls.once(Events.BUFFER_FLUSHED, function() {
                  var _this2$hls;
                  (_this2$hls = _this2.hls) == null ? void 0 : _this2$hls.trigger(Events.AUDIO_TRACK_SWITCHED, data);
                });
                hls.trigger(Events.BUFFER_FLUSHING, {
                  startOffset: 0,
                  endOffset: Number.POSITIVE_INFINITY,
                  type: null
                });
                return;
              }
              hls.trigger(Events.AUDIO_TRACK_SWITCHED, data);
            } else {
              this.altAudio = 1;
            }
          };
          _proto.onAudioTrackSwitched = function onAudioTrackSwitched(event, data) {
            var altAudio = useAlternateAudio(data.url, this.hls);
            if (altAudio) {
              var videoBuffer = this.videoBuffer;
              if (videoBuffer && this.mediaBuffer !== videoBuffer) {
                this.log("Switching on alternate audio, use video.buffered to schedule main fragment loading");
                this.mediaBuffer = videoBuffer;
              }
            }
            this.altAudio = altAudio ? 2 : 0;
            this.tick();
          };
          _proto.onBufferCreated = function onBufferCreated(event, data) {
            var tracks = data.tracks;
            var mediaTrack;
            var name;
            var alternate = false;
            for (var type in tracks) {
              var track = tracks[type];
              if (track.id === "main") {
                name = type;
                mediaTrack = track;
                if (type === "video") {
                  var videoTrack = tracks[type];
                  if (videoTrack) {
                    this.videoBuffer = videoTrack.buffer;
                  }
                }
              } else {
                alternate = true;
              }
            }
            if (alternate && mediaTrack) {
              this.log("Alternate track found, use " + name + ".buffered to schedule main fragment loading");
              this.mediaBuffer = mediaTrack.buffer;
            } else {
              this.mediaBuffer = this.media;
            }
          };
          _proto.onFragBuffered = function onFragBuffered(event, data) {
            var frag = data.frag, part = data.part;
            var bufferedMainFragment = frag.type === PlaylistLevelType.MAIN;
            if (bufferedMainFragment) {
              if (this.fragContextChanged(frag)) {
                this.warn("Fragment " + frag.sn + (part ? " p: " + part.index : "") + " of level " + frag.level + " finished buffering, but was aborted. state: " + this.state);
                if (this.state === State.PARSED) {
                  this.state = State.IDLE;
                }
                return;
              }
              var stats = part ? part.stats : frag.stats;
              this.fragLastKbps = Math.round(8 * stats.total / (stats.buffering.end - stats.loading.first));
              if (isMediaFragment(frag)) {
                this.fragPrevious = frag;
              }
              this.fragBufferedComplete(frag, part);
            }
            var media = this.media;
            if (!media) {
              return;
            }
            if (!this._hasEnoughToStart && BufferHelper.getBuffered(media).length) {
              this._hasEnoughToStart = true;
              this.seekToStartPos();
            }
            if (bufferedMainFragment) {
              this.tick();
            }
          };
          _proto.onError = function onError(event, data) {
            var _data$context;
            if (data.fatal) {
              this.state = State.ERROR;
              return;
            }
            switch (data.details) {
              case ErrorDetails.FRAG_GAP:
              case ErrorDetails.FRAG_PARSING_ERROR:
              case ErrorDetails.FRAG_DECRYPT_ERROR:
              case ErrorDetails.FRAG_LOAD_ERROR:
              case ErrorDetails.FRAG_LOAD_TIMEOUT:
              case ErrorDetails.KEY_LOAD_ERROR:
              case ErrorDetails.KEY_LOAD_TIMEOUT:
                this.onFragmentOrKeyLoadError(PlaylistLevelType.MAIN, data);
                break;
              case ErrorDetails.LEVEL_LOAD_ERROR:
              case ErrorDetails.LEVEL_LOAD_TIMEOUT:
              case ErrorDetails.LEVEL_PARSING_ERROR:
                if (!data.levelRetry && this.state === State.WAITING_LEVEL && ((_data$context = data.context) == null ? void 0 : _data$context.type) === PlaylistContextType.LEVEL) {
                  this.state = State.IDLE;
                }
                break;
              case ErrorDetails.BUFFER_ADD_CODEC_ERROR:
              case ErrorDetails.BUFFER_APPEND_ERROR:
                if (data.parent !== "main") {
                  return;
                }
                this.resetLoadingState();
                break;
              case ErrorDetails.BUFFER_FULL_ERROR:
                if (data.parent !== "main") {
                  return;
                }
                if (this.reduceLengthAndFlushBuffer(data)) {
                  this.flushMainBuffer(0, Number.POSITIVE_INFINITY);
                }
                break;
              case ErrorDetails.INTERNAL_EXCEPTION:
                this.recoverWorkerError(data);
                break;
            }
          };
          _proto.onFragLoadEmergencyAborted = function onFragLoadEmergencyAborted() {
            this.state = State.IDLE;
            if (!this._hasEnoughToStart) {
              this.startFragRequested = false;
              this.nextLoadPosition = this.lastCurrentTime;
            }
            this.tickImmediate();
          };
          _proto.onBufferFlushed = function onBufferFlushed(event, _ref) {
            var type = _ref.type;
            if (type !== ElementaryStreamTypes.AUDIO || !this.altAudio) {
              var mediaBuffer = (type === ElementaryStreamTypes.VIDEO ? this.videoBuffer : this.mediaBuffer) || this.media;
              if (mediaBuffer) {
                this.afterBufferFlushed(mediaBuffer, type, PlaylistLevelType.MAIN);
                this.tick();
              }
            }
          };
          _proto.onLevelsUpdated = function onLevelsUpdated(event, data) {
            if (this.level > -1 && this.fragCurrent) {
              this.level = this.fragCurrent.level;
              if (this.level === -1) {
                this.resetWhenMissingContext(this.fragCurrent);
              }
            }
            this.levels = data.levels;
          };
          _proto.swapAudioCodec = function swapAudioCodec() {
            this.audioCodecSwap = !this.audioCodecSwap;
          };
          _proto.seekToStartPos = function seekToStartPos() {
            var media = this.media;
            if (!media) {
              return;
            }
            var currentTime = media.currentTime;
            var startPosition = this.startPosition;
            if (startPosition >= 0 && currentTime < startPosition) {
              if (media.seeking) {
                this.log("could not seek to " + startPosition + ", already seeking at " + currentTime);
                return;
              }
              var timelineOffset = this.timelineOffset;
              if (timelineOffset && startPosition) {
                startPosition += timelineOffset;
              }
              var details = this.getLevelDetails();
              var buffered = BufferHelper.getBuffered(media);
              var bufferStart = buffered.length ? buffered.start(0) : 0;
              var delta = bufferStart - startPosition;
              var skipTolerance = Math.max(this.config.maxBufferHole, this.config.maxFragLookUpTolerance);
              if (delta > 0 && (delta < skipTolerance || this.loadingParts && delta < 2 * ((details == null ? void 0 : details.partTarget) || 0))) {
                this.log("adjusting start position by " + delta + " to match buffer start");
                startPosition += delta;
                this.startPosition = startPosition;
              }
              if (currentTime < startPosition) {
                this.log("seek to target start position " + startPosition + " from current time " + currentTime + " buffer start " + bufferStart);
                media.currentTime = startPosition;
              }
            }
          };
          _proto._getAudioCodec = function _getAudioCodec(currentLevel) {
            var audioCodec = this.config.defaultAudioCodec || currentLevel.audioCodec;
            if (this.audioCodecSwap && audioCodec) {
              this.log("Swapping audio codec");
              if (audioCodec.indexOf("mp4a.40.5") !== -1) {
                audioCodec = "mp4a.40.2";
              } else {
                audioCodec = "mp4a.40.5";
              }
            }
            return audioCodec;
          };
          _proto._loadBitrateTestFrag = function _loadBitrateTestFrag(fragment, level) {
            var _this3 = this;
            fragment.bitrateTest = true;
            this._doFragLoad(fragment, level).then(function(data) {
              var hls = _this3.hls;
              var frag = data == null ? void 0 : data.frag;
              if (!frag || _this3.fragContextChanged(frag)) {
                return;
              }
              level.fragmentError = 0;
              _this3.state = State.IDLE;
              _this3.startFragRequested = false;
              _this3.bitrateTest = false;
              var stats = frag.stats;
              stats.parsing.start = stats.parsing.end = stats.buffering.start = stats.buffering.end = self.performance.now();
              hls.trigger(Events.FRAG_LOADED, data);
              frag.bitrateTest = false;
            });
          };
          _proto._handleTransmuxComplete = function _handleTransmuxComplete(transmuxResult) {
            var _id3$samples;
            var id = this.playlistType;
            var hls = this.hls;
            var remuxResult = transmuxResult.remuxResult, chunkMeta = transmuxResult.chunkMeta;
            var context = this.getCurrentContext(chunkMeta);
            if (!context) {
              this.resetWhenMissingContext(chunkMeta);
              return;
            }
            var frag = context.frag, part = context.part, level = context.level;
            var video = remuxResult.video, text = remuxResult.text, id3 = remuxResult.id3, initSegment = remuxResult.initSegment;
            var details = level.details;
            var audio = this.altAudio ? void 0 : remuxResult.audio;
            if (this.fragContextChanged(frag)) {
              this.fragmentTracker.removeFragment(frag);
              return;
            }
            this.state = State.PARSING;
            if (initSegment) {
              if (initSegment != null && initSegment.tracks) {
                var mapFragment = frag.initSegment || frag;
                this._bufferInitSegment(level, initSegment.tracks, mapFragment, chunkMeta);
                hls.trigger(Events.FRAG_PARSING_INIT_SEGMENT, {
                  frag: mapFragment,
                  id,
                  tracks: initSegment.tracks
                });
              }
              var initPTS = initSegment.initPTS;
              var timescale = initSegment.timescale;
              if (isFiniteNumber(initPTS)) {
                this.initPTS[frag.cc] = {
                  baseTime: initPTS,
                  timescale
                };
                hls.trigger(Events.INIT_PTS_FOUND, {
                  frag,
                  id,
                  initPTS,
                  timescale
                });
              }
            }
            if (video && details) {
              var prevFrag = details.fragments[frag.sn - 1 - details.startSN];
              var isFirstFragment = frag.sn === details.startSN;
              var isFirstInDiscontinuity = !prevFrag || frag.cc > prevFrag.cc;
              if (remuxResult.independent !== false) {
                var startPTS = video.startPTS, endPTS = video.endPTS, startDTS = video.startDTS, endDTS = video.endDTS;
                if (part) {
                  part.elementaryStreams[video.type] = {
                    startPTS,
                    endPTS,
                    startDTS,
                    endDTS
                  };
                } else {
                  if (video.firstKeyFrame && video.independent && chunkMeta.id === 1 && !isFirstInDiscontinuity) {
                    this.couldBacktrack = true;
                  }
                  if (video.dropped && video.independent) {
                    var bufferInfo = this.getMainFwdBufferInfo();
                    var targetBufferTime = (bufferInfo ? bufferInfo.end : this.getLoadPosition()) + this.config.maxBufferHole;
                    var startTime = video.firstKeyFramePTS ? video.firstKeyFramePTS : startPTS;
                    if (!isFirstFragment && targetBufferTime < startTime - this.config.maxBufferHole && !isFirstInDiscontinuity) {
                      this.backtrack(frag);
                      return;
                    } else if (isFirstInDiscontinuity) {
                      frag.gap = true;
                    }
                    frag.setElementaryStreamInfo(video.type, frag.start, endPTS, frag.start, endDTS, true);
                  } else if (isFirstFragment && startPTS - (details.appliedTimelineOffset || 0) > MAX_START_GAP_JUMP) {
                    frag.gap = true;
                  }
                }
                frag.setElementaryStreamInfo(video.type, startPTS, endPTS, startDTS, endDTS);
                if (this.backtrackFragment) {
                  this.backtrackFragment = frag;
                }
                this.bufferFragmentData(video, frag, part, chunkMeta, isFirstFragment || isFirstInDiscontinuity);
              } else if (isFirstFragment || isFirstInDiscontinuity) {
                frag.gap = true;
              } else {
                this.backtrack(frag);
                return;
              }
            }
            if (audio) {
              var _startPTS = audio.startPTS, _endPTS = audio.endPTS, _startDTS = audio.startDTS, _endDTS = audio.endDTS;
              if (part) {
                part.elementaryStreams[ElementaryStreamTypes.AUDIO] = {
                  startPTS: _startPTS,
                  endPTS: _endPTS,
                  startDTS: _startDTS,
                  endDTS: _endDTS
                };
              }
              frag.setElementaryStreamInfo(ElementaryStreamTypes.AUDIO, _startPTS, _endPTS, _startDTS, _endDTS);
              this.bufferFragmentData(audio, frag, part, chunkMeta);
            }
            if (details && id3 != null && (_id3$samples = id3.samples) != null && _id3$samples.length) {
              var emittedID3 = {
                id,
                frag,
                details,
                samples: id3.samples
              };
              hls.trigger(Events.FRAG_PARSING_METADATA, emittedID3);
            }
            if (details && text) {
              var emittedText = {
                id,
                frag,
                details,
                samples: text.samples
              };
              hls.trigger(Events.FRAG_PARSING_USERDATA, emittedText);
            }
          };
          _proto._bufferInitSegment = function _bufferInitSegment(currentLevel, tracks, frag, chunkMeta) {
            var _this4 = this;
            if (this.state !== State.PARSING) {
              return;
            }
            this.audioOnly = !!tracks.audio && !tracks.video;
            if (this.altAudio && !this.audioOnly) {
              delete tracks.audio;
            }
            var audio = tracks.audio, video = tracks.video, audiovideo = tracks.audiovideo;
            if (audio) {
              var audioCodec = pickMostCompleteCodecName(audio.codec, currentLevel.audioCodec);
              if (audioCodec === "mp4a") {
                audioCodec = "mp4a.40.5";
              }
              var ua2 = navigator.userAgent.toLowerCase();
              if (this.audioCodecSwitch) {
                if (audioCodec) {
                  if (audioCodec.indexOf("mp4a.40.5") !== -1) {
                    audioCodec = "mp4a.40.2";
                  } else {
                    audioCodec = "mp4a.40.5";
                  }
                }
                var audioMetadata = audio.metadata;
                if (audioMetadata && "channelCount" in audioMetadata && (audioMetadata.channelCount || 1) !== 1 && ua2.indexOf("firefox") === -1) {
                  audioCodec = "mp4a.40.5";
                }
              }
              if (audioCodec && audioCodec.indexOf("mp4a.40.5") !== -1 && ua2.indexOf("android") !== -1 && audio.container !== "audio/mpeg") {
                audioCodec = "mp4a.40.2";
                this.log("Android: force audio codec to " + audioCodec);
              }
              if (currentLevel.audioCodec && currentLevel.audioCodec !== audioCodec) {
                this.log('Swapping manifest audio codec "' + currentLevel.audioCodec + '" for "' + audioCodec + '"');
              }
              audio.levelCodec = audioCodec;
              audio.id = PlaylistLevelType.MAIN;
              this.log("Init audio buffer, container:" + audio.container + ", codecs[selected/level/parsed]=[" + (audioCodec || "") + "/" + (currentLevel.audioCodec || "") + "/" + audio.codec + "]");
              delete tracks.audiovideo;
            }
            if (video) {
              video.levelCodec = currentLevel.videoCodec;
              video.id = PlaylistLevelType.MAIN;
              var parsedVideoCodec = video.codec;
              if ((parsedVideoCodec == null ? void 0 : parsedVideoCodec.length) === 4) {
                switch (parsedVideoCodec) {
                  case "hvc1":
                  case "hev1":
                    video.codec = "hvc1.1.6.L120.90";
                    break;
                  case "av01":
                    video.codec = "av01.0.04M.08";
                    break;
                  case "avc1":
                    video.codec = "avc1.42e01e";
                    break;
                }
              }
              this.log("Init video buffer, container:" + video.container + ", codecs[level/parsed]=[" + (currentLevel.videoCodec || "") + "/" + parsedVideoCodec + "]" + (video.codec !== parsedVideoCodec ? " parsed-corrected=" + video.codec : "") + (video.supplemental ? " supplemental=" + video.supplemental : ""));
              delete tracks.audiovideo;
            }
            if (audiovideo) {
              this.log("Init audiovideo buffer, container:" + audiovideo.container + ", codecs[level/parsed]=[" + currentLevel.codecs + "/" + audiovideo.codec + "]");
              delete tracks.video;
              delete tracks.audio;
            }
            var trackTypes = Object.keys(tracks);
            if (trackTypes.length) {
              this.hls.trigger(Events.BUFFER_CODECS, tracks);
              if (!this.hls) {
                return;
              }
              trackTypes.forEach(function(trackName) {
                var track = tracks[trackName];
                var initSegment = track.initSegment;
                if (initSegment != null && initSegment.byteLength) {
                  _this4.hls.trigger(Events.BUFFER_APPENDING, {
                    type: trackName,
                    data: initSegment,
                    frag,
                    part: null,
                    chunkMeta,
                    parent: frag.type
                  });
                }
              });
            }
            this.tickImmediate();
          };
          _proto.getMainFwdBufferInfo = function getMainFwdBufferInfo() {
            var bufferOutput = this.mediaBuffer && this.altAudio === 2 ? this.mediaBuffer : this.media;
            return this.getFwdBufferInfo(bufferOutput, PlaylistLevelType.MAIN);
          };
          _proto.backtrack = function backtrack(frag) {
            this.couldBacktrack = true;
            this.backtrackFragment = frag;
            this.resetTransmuxer();
            this.flushBufferGap(frag);
            this.fragmentTracker.removeFragment(frag);
            this.fragPrevious = null;
            this.nextLoadPosition = frag.start;
            this.state = State.IDLE;
          };
          _proto.checkFragmentChanged = function checkFragmentChanged() {
            var video = this.media;
            var fragPlayingCurrent = null;
            if (video && video.readyState > 1 && video.seeking === false) {
              var currentTime = video.currentTime;
              if (BufferHelper.isBuffered(video, currentTime)) {
                fragPlayingCurrent = this.getAppendedFrag(currentTime);
              } else if (BufferHelper.isBuffered(video, currentTime + 0.1)) {
                fragPlayingCurrent = this.getAppendedFrag(currentTime + 0.1);
              }
              if (fragPlayingCurrent) {
                this.backtrackFragment = null;
                var fragPlaying = this.fragPlaying;
                var fragCurrentLevel = fragPlayingCurrent.level;
                if (!fragPlaying || fragPlayingCurrent.sn !== fragPlaying.sn || fragPlaying.level !== fragCurrentLevel) {
                  this.fragPlaying = fragPlayingCurrent;
                  this.hls.trigger(Events.FRAG_CHANGED, {
                    frag: fragPlayingCurrent
                  });
                  if (!fragPlaying || fragPlaying.level !== fragCurrentLevel) {
                    this.hls.trigger(Events.LEVEL_SWITCHED, {
                      level: fragCurrentLevel
                    });
                  }
                }
              }
            }
          };
          return _createClass4(StreamController2, [{
            key: "hasEnoughToStart",
            get: function get() {
              return this._hasEnoughToStart;
            }
          }, {
            key: "maxBufferLength",
            get: function get() {
              var levels = this.levels, level = this.level;
              var levelInfo = levels == null ? void 0 : levels[level];
              if (!levelInfo) {
                return this.config.maxBufferLength;
              }
              return this.getMaxBufferLength(levelInfo.maxBitrate);
            }
          }, {
            key: "nextLevel",
            get: function get() {
              var frag = this.nextBufferedFrag;
              if (frag) {
                return frag.level;
              }
              return -1;
            }
          }, {
            key: "currentFrag",
            get: function get() {
              var _this$media3;
              if (this.fragPlaying) {
                return this.fragPlaying;
              }
              var currentTime = ((_this$media3 = this.media) == null ? void 0 : _this$media3.currentTime) || this.lastCurrentTime;
              if (isFiniteNumber(currentTime)) {
                return this.getAppendedFrag(currentTime);
              }
              return null;
            }
          }, {
            key: "currentProgramDateTime",
            get: function get() {
              var _this$media4;
              var currentTime = ((_this$media4 = this.media) == null ? void 0 : _this$media4.currentTime) || this.lastCurrentTime;
              if (isFiniteNumber(currentTime)) {
                var details = this.getLevelDetails();
                var frag = this.currentFrag || (details ? findFragmentByPTS(null, details.fragments, currentTime) : null);
                if (frag) {
                  var programDateTime = frag.programDateTime;
                  if (programDateTime !== null) {
                    var epocMs = programDateTime + (currentTime - frag.start) * 1e3;
                    return new Date(epocMs);
                  }
                }
              }
              return null;
            }
          }, {
            key: "currentLevel",
            get: function get() {
              var frag = this.currentFrag;
              if (frag) {
                return frag.level;
              }
              return -1;
            }
          }, {
            key: "nextBufferedFrag",
            get: function get() {
              var frag = this.currentFrag;
              if (frag) {
                return this.followingBufferedFrag(frag);
              }
              return null;
            }
          }, {
            key: "forceStartLoad",
            get: function get() {
              return this._forceStartLoad;
            }
          }]);
        }(BaseStreamController);
        var KeyLoader = /* @__PURE__ */ function() {
          function KeyLoader2(config) {
            this.config = void 0;
            this.keyUriToKeyInfo = {};
            this.emeController = null;
            this.config = config;
          }
          var _proto = KeyLoader2.prototype;
          _proto.abort = function abort(type) {
            for (var uri in this.keyUriToKeyInfo) {
              var loader = this.keyUriToKeyInfo[uri].loader;
              if (loader) {
                var _loader$context;
                if (type && type !== ((_loader$context = loader.context) == null ? void 0 : _loader$context.frag.type)) {
                  return;
                }
                loader.abort();
              }
            }
          };
          _proto.detach = function detach() {
            for (var uri in this.keyUriToKeyInfo) {
              var keyInfo = this.keyUriToKeyInfo[uri];
              if (keyInfo.mediaKeySessionContext || keyInfo.decryptdata.isCommonEncryption) {
                delete this.keyUriToKeyInfo[uri];
              }
            }
          };
          _proto.destroy = function destroy() {
            this.detach();
            for (var uri in this.keyUriToKeyInfo) {
              var loader = this.keyUriToKeyInfo[uri].loader;
              if (loader) {
                loader.destroy();
              }
            }
            this.keyUriToKeyInfo = {};
          };
          _proto.createKeyLoadError = function createKeyLoadError(frag, details, error, networkDetails, response) {
            if (details === void 0) {
              details = ErrorDetails.KEY_LOAD_ERROR;
            }
            return new LoadError({
              type: ErrorTypes.NETWORK_ERROR,
              details,
              fatal: false,
              frag,
              response,
              error,
              networkDetails
            });
          };
          _proto.loadClear = function loadClear(loadingFrag, encryptedFragments) {
            var _this = this;
            if (this.emeController && this.config.emeEnabled) {
              var sn = loadingFrag.sn, cc = loadingFrag.cc;
              var _loop = function _loop2() {
                var frag = encryptedFragments[i];
                if (cc <= frag.cc && (sn === "initSegment" || frag.sn === "initSegment" || sn < frag.sn)) {
                  _this.emeController.selectKeySystemFormat(frag).then(function(keySystemFormat) {
                    frag.setKeyFormat(keySystemFormat);
                  });
                  return 1;
                }
              };
              for (var i = 0; i < encryptedFragments.length; i++) {
                if (_loop()) break;
              }
            }
          };
          _proto.load = function load(frag) {
            var _this2 = this;
            if (!frag.decryptdata && frag.encrypted && this.emeController && this.config.emeEnabled) {
              return this.emeController.selectKeySystemFormat(frag).then(function(keySystemFormat) {
                return _this2.loadInternal(frag, keySystemFormat);
              });
            }
            return this.loadInternal(frag);
          };
          _proto.loadInternal = function loadInternal(frag, keySystemFormat) {
            var _keyInfo, _keyInfo2;
            if (keySystemFormat) {
              frag.setKeyFormat(keySystemFormat);
            }
            var decryptdata = frag.decryptdata;
            if (!decryptdata) {
              var error = new Error(keySystemFormat ? "Expected frag.decryptdata to be defined after setting format " + keySystemFormat : "Missing decryption data on fragment in onKeyLoading");
              return Promise.reject(this.createKeyLoadError(frag, ErrorDetails.KEY_LOAD_ERROR, error));
            }
            var uri = decryptdata.uri;
            if (!uri) {
              return Promise.reject(this.createKeyLoadError(frag, ErrorDetails.KEY_LOAD_ERROR, new Error('Invalid key URI: "' + uri + '"')));
            }
            var keyInfo = this.keyUriToKeyInfo[uri];
            if ((_keyInfo = keyInfo) != null && _keyInfo.decryptdata.key) {
              decryptdata.key = keyInfo.decryptdata.key;
              return Promise.resolve({
                frag,
                keyInfo
              });
            }
            if ((_keyInfo2 = keyInfo) != null && _keyInfo2.keyLoadPromise) {
              var _keyInfo$mediaKeySess;
              switch ((_keyInfo$mediaKeySess = keyInfo.mediaKeySessionContext) == null ? void 0 : _keyInfo$mediaKeySess.keyStatus) {
                case void 0:
                case "status-pending":
                case "usable":
                case "usable-in-future":
                  return keyInfo.keyLoadPromise.then(function(keyLoadedData) {
                    decryptdata.key = keyLoadedData.keyInfo.decryptdata.key;
                    return {
                      frag,
                      keyInfo
                    };
                  });
              }
            }
            keyInfo = this.keyUriToKeyInfo[uri] = {
              decryptdata,
              keyLoadPromise: null,
              loader: null,
              mediaKeySessionContext: null
            };
            switch (decryptdata.method) {
              case "ISO-23001-7":
              case "SAMPLE-AES":
              case "SAMPLE-AES-CENC":
              case "SAMPLE-AES-CTR":
                if (decryptdata.keyFormat === "identity") {
                  return this.loadKeyHTTP(keyInfo, frag);
                }
                return this.loadKeyEME(keyInfo, frag);
              case "AES-128":
              case "AES-256":
              case "AES-256-CTR":
                return this.loadKeyHTTP(keyInfo, frag);
              default:
                return Promise.reject(this.createKeyLoadError(frag, ErrorDetails.KEY_LOAD_ERROR, new Error('Key supplied with unsupported METHOD: "' + decryptdata.method + '"')));
            }
          };
          _proto.loadKeyEME = function loadKeyEME(keyInfo, frag) {
            var keyLoadedData = {
              frag,
              keyInfo
            };
            if (this.emeController && this.config.emeEnabled) {
              var keySessionContextPromise = this.emeController.loadKey(keyLoadedData);
              if (keySessionContextPromise) {
                return (keyInfo.keyLoadPromise = keySessionContextPromise.then(function(keySessionContext) {
                  keyInfo.mediaKeySessionContext = keySessionContext;
                  return keyLoadedData;
                })).catch(function(error) {
                  keyInfo.keyLoadPromise = null;
                  throw error;
                });
              }
            }
            return Promise.resolve(keyLoadedData);
          };
          _proto.loadKeyHTTP = function loadKeyHTTP(keyInfo, frag) {
            var _this3 = this;
            var config = this.config;
            var Loader = config.loader;
            var keyLoader = new Loader(config);
            frag.keyLoader = keyInfo.loader = keyLoader;
            return keyInfo.keyLoadPromise = new Promise(function(resolve, reject) {
              var loaderContext = {
                keyInfo,
                frag,
                responseType: "arraybuffer",
                url: keyInfo.decryptdata.uri
              };
              var loadPolicy = config.keyLoadPolicy.default;
              var loaderConfig = {
                loadPolicy,
                timeout: loadPolicy.maxLoadTimeMs,
                maxRetry: 0,
                retryDelay: 0,
                maxRetryDelay: 0
              };
              var loaderCallbacks = {
                onSuccess: function onSuccess(response, stats, context, networkDetails) {
                  var frag2 = context.frag, keyInfo2 = context.keyInfo, uri = context.url;
                  if (!frag2.decryptdata || keyInfo2 !== _this3.keyUriToKeyInfo[uri]) {
                    return reject(_this3.createKeyLoadError(frag2, ErrorDetails.KEY_LOAD_ERROR, new Error("after key load, decryptdata unset or changed"), networkDetails));
                  }
                  keyInfo2.decryptdata.key = frag2.decryptdata.key = new Uint8Array(response.data);
                  frag2.keyLoader = null;
                  keyInfo2.loader = null;
                  resolve({
                    frag: frag2,
                    keyInfo: keyInfo2
                  });
                },
                onError: function onError(response, context, networkDetails, stats) {
                  _this3.resetLoader(context);
                  reject(_this3.createKeyLoadError(frag, ErrorDetails.KEY_LOAD_ERROR, new Error("HTTP Error " + response.code + " loading key " + response.text), networkDetails, _objectSpread23({
                    url: loaderContext.url,
                    data: void 0
                  }, response)));
                },
                onTimeout: function onTimeout(stats, context, networkDetails) {
                  _this3.resetLoader(context);
                  reject(_this3.createKeyLoadError(frag, ErrorDetails.KEY_LOAD_TIMEOUT, new Error("key loading timed out"), networkDetails));
                },
                onAbort: function onAbort(stats, context, networkDetails) {
                  _this3.resetLoader(context);
                  reject(_this3.createKeyLoadError(frag, ErrorDetails.INTERNAL_ABORTED, new Error("key loading aborted"), networkDetails));
                }
              };
              keyLoader.load(loaderContext, loaderConfig, loaderCallbacks);
            });
          };
          _proto.resetLoader = function resetLoader(context) {
            var frag = context.frag, keyInfo = context.keyInfo, uri = context.url;
            var loader = keyInfo.loader;
            if (frag.keyLoader === loader) {
              frag.keyLoader = null;
              keyInfo.loader = null;
            }
            delete this.keyUriToKeyInfo[uri];
            if (loader) {
              loader.destroy();
            }
          };
          return KeyLoader2;
        }();
        function mapContextToLevelType(context) {
          var type = context.type;
          switch (type) {
            case PlaylistContextType.AUDIO_TRACK:
              return PlaylistLevelType.AUDIO;
            case PlaylistContextType.SUBTITLE_TRACK:
              return PlaylistLevelType.SUBTITLE;
            default:
              return PlaylistLevelType.MAIN;
          }
        }
        function getResponseUrl(response, context) {
          var url = response.url;
          if (url === void 0 || url.indexOf("data:") === 0) {
            url = context.url;
          }
          return url;
        }
        var PlaylistLoader = /* @__PURE__ */ function() {
          function PlaylistLoader2(hls) {
            this.hls = void 0;
            this.loaders = /* @__PURE__ */ Object.create(null);
            this.variableList = null;
            this.onManifestLoaded = this.checkAutostartLoad;
            this.hls = hls;
            this.registerListeners();
          }
          var _proto = PlaylistLoader2.prototype;
          _proto.startLoad = function startLoad(startPosition) {
          };
          _proto.stopLoad = function stopLoad() {
            this.destroyInternalLoaders();
          };
          _proto.registerListeners = function registerListeners() {
            var hls = this.hls;
            hls.on(Events.MANIFEST_LOADING, this.onManifestLoading, this);
            hls.on(Events.LEVEL_LOADING, this.onLevelLoading, this);
            hls.on(Events.AUDIO_TRACK_LOADING, this.onAudioTrackLoading, this);
            hls.on(Events.SUBTITLE_TRACK_LOADING, this.onSubtitleTrackLoading, this);
            hls.on(Events.LEVELS_UPDATED, this.onLevelsUpdated, this);
          };
          _proto.unregisterListeners = function unregisterListeners() {
            var hls = this.hls;
            hls.off(Events.MANIFEST_LOADING, this.onManifestLoading, this);
            hls.off(Events.LEVEL_LOADING, this.onLevelLoading, this);
            hls.off(Events.AUDIO_TRACK_LOADING, this.onAudioTrackLoading, this);
            hls.off(Events.SUBTITLE_TRACK_LOADING, this.onSubtitleTrackLoading, this);
            hls.off(Events.LEVELS_UPDATED, this.onLevelsUpdated, this);
          };
          _proto.createInternalLoader = function createInternalLoader(context) {
            var config = this.hls.config;
            var PLoader = config.pLoader;
            var Loader = config.loader;
            var InternalLoader = PLoader || Loader;
            var loader = new InternalLoader(config);
            this.loaders[context.type] = loader;
            return loader;
          };
          _proto.getInternalLoader = function getInternalLoader(context) {
            return this.loaders[context.type];
          };
          _proto.resetInternalLoader = function resetInternalLoader(contextType) {
            if (this.loaders[contextType]) {
              delete this.loaders[contextType];
            }
          };
          _proto.destroyInternalLoaders = function destroyInternalLoaders() {
            for (var contextType in this.loaders) {
              var loader = this.loaders[contextType];
              if (loader) {
                loader.destroy();
              }
              this.resetInternalLoader(contextType);
            }
          };
          _proto.destroy = function destroy() {
            this.variableList = null;
            this.unregisterListeners();
            this.destroyInternalLoaders();
          };
          _proto.onManifestLoading = function onManifestLoading(event, data) {
            var url = data.url;
            this.variableList = null;
            this.load({
              id: null,
              level: 0,
              responseType: "text",
              type: PlaylistContextType.MANIFEST,
              url,
              deliveryDirectives: null,
              levelOrTrack: null
            });
          };
          _proto.onLevelLoading = function onLevelLoading(event, data) {
            var id = data.id, level = data.level, pathwayId = data.pathwayId, url = data.url, deliveryDirectives = data.deliveryDirectives, levelInfo = data.levelInfo;
            this.load({
              id,
              level,
              pathwayId,
              responseType: "text",
              type: PlaylistContextType.LEVEL,
              url,
              deliveryDirectives,
              levelOrTrack: levelInfo
            });
          };
          _proto.onAudioTrackLoading = function onAudioTrackLoading(event, data) {
            var id = data.id, groupId = data.groupId, url = data.url, deliveryDirectives = data.deliveryDirectives, track = data.track;
            this.load({
              id,
              groupId,
              level: null,
              responseType: "text",
              type: PlaylistContextType.AUDIO_TRACK,
              url,
              deliveryDirectives,
              levelOrTrack: track
            });
          };
          _proto.onSubtitleTrackLoading = function onSubtitleTrackLoading(event, data) {
            var id = data.id, groupId = data.groupId, url = data.url, deliveryDirectives = data.deliveryDirectives, track = data.track;
            this.load({
              id,
              groupId,
              level: null,
              responseType: "text",
              type: PlaylistContextType.SUBTITLE_TRACK,
              url,
              deliveryDirectives,
              levelOrTrack: track
            });
          };
          _proto.onLevelsUpdated = function onLevelsUpdated(event, data) {
            var loader = this.loaders[PlaylistContextType.LEVEL];
            if (loader) {
              var context = loader.context;
              if (context && !data.levels.some(function(lvl) {
                return lvl === context.levelOrTrack;
              })) {
                loader.abort();
                delete this.loaders[PlaylistContextType.LEVEL];
              }
            }
          };
          _proto.load = function load(context) {
            var _context$deliveryDire, _this = this;
            var config = this.hls.config;
            var loader = this.getInternalLoader(context);
            if (loader) {
              var logger5 = this.hls.logger;
              var loaderContext = loader.context;
              if (loaderContext && loaderContext.levelOrTrack === context.levelOrTrack && (loaderContext.url === context.url || loaderContext.deliveryDirectives && !context.deliveryDirectives)) {
                if (loaderContext.url === context.url) {
                  logger5.log("[playlist-loader]: ignore " + context.url + " ongoing request");
                } else {
                  logger5.log("[playlist-loader]: ignore " + context.url + " in favor of " + loaderContext.url);
                }
                return;
              }
              logger5.log("[playlist-loader]: aborting previous loader for type: " + context.type);
              loader.abort();
            }
            var loadPolicy;
            if (context.type === PlaylistContextType.MANIFEST) {
              loadPolicy = config.manifestLoadPolicy.default;
            } else {
              loadPolicy = _extends({}, config.playlistLoadPolicy.default, {
                timeoutRetry: null,
                errorRetry: null
              });
            }
            loader = this.createInternalLoader(context);
            if (isFiniteNumber((_context$deliveryDire = context.deliveryDirectives) == null ? void 0 : _context$deliveryDire.part)) {
              var levelDetails;
              if (context.type === PlaylistContextType.LEVEL && context.level !== null) {
                levelDetails = this.hls.levels[context.level].details;
              } else if (context.type === PlaylistContextType.AUDIO_TRACK && context.id !== null) {
                levelDetails = this.hls.audioTracks[context.id].details;
              } else if (context.type === PlaylistContextType.SUBTITLE_TRACK && context.id !== null) {
                levelDetails = this.hls.subtitleTracks[context.id].details;
              }
              if (levelDetails) {
                var partTarget = levelDetails.partTarget;
                var targetDuration = levelDetails.targetduration;
                if (partTarget && targetDuration) {
                  var maxLowLatencyPlaylistRefresh = Math.max(partTarget * 3, targetDuration * 0.8) * 1e3;
                  loadPolicy = _extends({}, loadPolicy, {
                    maxTimeToFirstByteMs: Math.min(maxLowLatencyPlaylistRefresh, loadPolicy.maxTimeToFirstByteMs),
                    maxLoadTimeMs: Math.min(maxLowLatencyPlaylistRefresh, loadPolicy.maxTimeToFirstByteMs)
                  });
                }
              }
            }
            var legacyRetryCompatibility = loadPolicy.errorRetry || loadPolicy.timeoutRetry || {};
            var loaderConfig = {
              loadPolicy,
              timeout: loadPolicy.maxLoadTimeMs,
              maxRetry: legacyRetryCompatibility.maxNumRetry || 0,
              retryDelay: legacyRetryCompatibility.retryDelayMs || 0,
              maxRetryDelay: legacyRetryCompatibility.maxRetryDelayMs || 0
            };
            var loaderCallbacks = {
              onSuccess: function onSuccess(response, stats, context2, networkDetails) {
                var loader2 = _this.getInternalLoader(context2);
                _this.resetInternalLoader(context2.type);
                var string = response.data;
                if (string.indexOf("#EXTM3U") !== 0) {
                  _this.handleManifestParsingError(response, context2, new Error("no EXTM3U delimiter"), networkDetails || null, stats);
                  return;
                }
                stats.parsing.start = performance.now();
                if (M3U8Parser.isMediaPlaylist(string) || context2.type !== PlaylistContextType.MANIFEST) {
                  _this.handleTrackOrLevelPlaylist(response, stats, context2, networkDetails || null, loader2);
                } else {
                  _this.handleMasterPlaylist(response, stats, context2, networkDetails);
                }
              },
              onError: function onError(response, context2, networkDetails, stats) {
                _this.handleNetworkError(context2, networkDetails, false, response, stats);
              },
              onTimeout: function onTimeout(stats, context2, networkDetails) {
                _this.handleNetworkError(context2, networkDetails, true, void 0, stats);
              }
            };
            loader.load(context, loaderConfig, loaderCallbacks);
          };
          _proto.checkAutostartLoad = function checkAutostartLoad() {
            if (!this.hls) {
              return;
            }
            var _this$hls = this.hls, _this$hls$config = _this$hls.config, autoStartLoad = _this$hls$config.autoStartLoad, startPosition = _this$hls$config.startPosition, forceStartLoad = _this$hls.forceStartLoad;
            if (autoStartLoad || forceStartLoad) {
              this.hls.logger.log((autoStartLoad ? "auto" : "force") + " startLoad with configured startPosition " + startPosition);
              this.hls.startLoad(startPosition);
            }
          };
          _proto.handleMasterPlaylist = function handleMasterPlaylist(response, stats, context, networkDetails) {
            var hls = this.hls;
            var string = response.data;
            var url = getResponseUrl(response, context);
            var parsedResult = M3U8Parser.parseMasterPlaylist(string, url);
            if (parsedResult.playlistParsingError) {
              this.handleManifestParsingError(response, context, parsedResult.playlistParsingError, networkDetails, stats);
              return;
            }
            var contentSteering = parsedResult.contentSteering, levels = parsedResult.levels, sessionData = parsedResult.sessionData, sessionKeys = parsedResult.sessionKeys, startTimeOffset = parsedResult.startTimeOffset, variableList = parsedResult.variableList;
            this.variableList = variableList;
            var _M3U8Parser$parseMast = M3U8Parser.parseMasterPlaylistMedia(string, url, parsedResult), _M3U8Parser$parseMast2 = _M3U8Parser$parseMast.AUDIO, audioTracks = _M3U8Parser$parseMast2 === void 0 ? [] : _M3U8Parser$parseMast2, subtitles = _M3U8Parser$parseMast.SUBTITLES, captions = _M3U8Parser$parseMast["CLOSED-CAPTIONS"];
            if (audioTracks.length) {
              var embeddedAudioFound = audioTracks.some(function(audioTrack) {
                return !audioTrack.url;
              });
              if (!embeddedAudioFound && levels[0].audioCodec && !levels[0].attrs.AUDIO) {
                this.hls.logger.log("[playlist-loader]: audio codec signaled in quality level, but no embedded audio track signaled, create one");
                audioTracks.unshift({
                  type: "main",
                  name: "main",
                  groupId: "main",
                  default: false,
                  autoselect: false,
                  forced: false,
                  id: -1,
                  attrs: new AttrList({}),
                  bitrate: 0,
                  url: ""
                });
              }
            }
            hls.trigger(Events.MANIFEST_LOADED, {
              levels,
              audioTracks,
              subtitles,
              captions,
              contentSteering,
              url,
              stats,
              networkDetails,
              sessionData,
              sessionKeys,
              startTimeOffset,
              variableList
            });
          };
          _proto.handleTrackOrLevelPlaylist = function handleTrackOrLevelPlaylist(response, stats, context, networkDetails, loader) {
            var hls = this.hls;
            var id = context.id, level = context.level, type = context.type;
            var url = getResponseUrl(response, context);
            var levelId = isFiniteNumber(level) ? level : isFiniteNumber(id) ? id : 0;
            var levelType = mapContextToLevelType(context);
            var levelDetails = M3U8Parser.parseLevelPlaylist(response.data, url, levelId, levelType, 0, this.variableList);
            if (type === PlaylistContextType.MANIFEST) {
              var singleLevel = {
                attrs: new AttrList({}),
                bitrate: 0,
                details: levelDetails,
                name: "",
                url
              };
              levelDetails.requestScheduled = stats.loading.start + computeReloadInterval(levelDetails, 0);
              hls.trigger(Events.MANIFEST_LOADED, {
                levels: [singleLevel],
                audioTracks: [],
                url,
                stats,
                networkDetails,
                sessionData: null,
                sessionKeys: null,
                contentSteering: null,
                startTimeOffset: null,
                variableList: null
              });
            }
            stats.parsing.end = performance.now();
            context.levelDetails = levelDetails;
            this.handlePlaylistLoaded(levelDetails, response, stats, context, networkDetails, loader);
          };
          _proto.handleManifestParsingError = function handleManifestParsingError(response, context, error, networkDetails, stats) {
            this.hls.trigger(Events.ERROR, {
              type: ErrorTypes.NETWORK_ERROR,
              details: ErrorDetails.MANIFEST_PARSING_ERROR,
              fatal: context.type === PlaylistContextType.MANIFEST,
              url: response.url,
              err: error,
              error,
              reason: error.message,
              response,
              context,
              networkDetails,
              stats
            });
          };
          _proto.handleNetworkError = function handleNetworkError(context, networkDetails, timeout, response, stats) {
            if (timeout === void 0) {
              timeout = false;
            }
            var message = "A network " + (timeout ? "timeout" : "error" + (response ? " (status " + response.code + ")" : "")) + " occurred while loading " + context.type;
            if (context.type === PlaylistContextType.LEVEL) {
              message += ": " + context.level + " id: " + context.id;
            } else if (context.type === PlaylistContextType.AUDIO_TRACK || context.type === PlaylistContextType.SUBTITLE_TRACK) {
              message += " id: " + context.id + ' group-id: "' + context.groupId + '"';
            }
            var error = new Error(message);
            this.hls.logger.warn("[playlist-loader]: " + message);
            var details = ErrorDetails.UNKNOWN;
            var fatal = false;
            var loader = this.getInternalLoader(context);
            switch (context.type) {
              case PlaylistContextType.MANIFEST:
                details = timeout ? ErrorDetails.MANIFEST_LOAD_TIMEOUT : ErrorDetails.MANIFEST_LOAD_ERROR;
                fatal = true;
                break;
              case PlaylistContextType.LEVEL:
                details = timeout ? ErrorDetails.LEVEL_LOAD_TIMEOUT : ErrorDetails.LEVEL_LOAD_ERROR;
                fatal = false;
                break;
              case PlaylistContextType.AUDIO_TRACK:
                details = timeout ? ErrorDetails.AUDIO_TRACK_LOAD_TIMEOUT : ErrorDetails.AUDIO_TRACK_LOAD_ERROR;
                fatal = false;
                break;
              case PlaylistContextType.SUBTITLE_TRACK:
                details = timeout ? ErrorDetails.SUBTITLE_TRACK_LOAD_TIMEOUT : ErrorDetails.SUBTITLE_LOAD_ERROR;
                fatal = false;
                break;
            }
            if (loader) {
              this.resetInternalLoader(context.type);
            }
            var errorData = {
              type: ErrorTypes.NETWORK_ERROR,
              details,
              fatal,
              url: context.url,
              loader,
              context,
              error,
              networkDetails,
              stats
            };
            if (response) {
              var url = (networkDetails == null ? void 0 : networkDetails.url) || context.url;
              errorData.response = _objectSpread23({
                url,
                data: void 0
              }, response);
            }
            this.hls.trigger(Events.ERROR, errorData);
          };
          _proto.handlePlaylistLoaded = function handlePlaylistLoaded(levelDetails, response, stats, context, networkDetails, loader) {
            var hls = this.hls;
            var type = context.type, level = context.level, id = context.id, groupId = context.groupId, deliveryDirectives = context.deliveryDirectives;
            var url = getResponseUrl(response, context);
            var parent = mapContextToLevelType(context);
            var levelIndex = typeof context.level === "number" && parent === PlaylistLevelType.MAIN ? level : void 0;
            if (!levelDetails.fragments.length) {
              var _error = levelDetails.playlistParsingError = new Error("No Segments found in Playlist");
              hls.trigger(Events.ERROR, {
                type: ErrorTypes.NETWORK_ERROR,
                details: ErrorDetails.LEVEL_EMPTY_ERROR,
                fatal: false,
                url,
                error: _error,
                reason: _error.message,
                response,
                context,
                level: levelIndex,
                parent,
                networkDetails,
                stats
              });
              return;
            }
            if (!levelDetails.targetduration) {
              levelDetails.playlistParsingError = new Error("Missing Target Duration");
            }
            var error = levelDetails.playlistParsingError;
            if (error) {
              this.hls.logger.warn(error);
              if (!hls.config.ignorePlaylistParsingErrors) {
                hls.trigger(Events.ERROR, {
                  type: ErrorTypes.NETWORK_ERROR,
                  details: ErrorDetails.LEVEL_PARSING_ERROR,
                  fatal: false,
                  url,
                  error,
                  reason: error.message,
                  response,
                  context,
                  level: levelIndex,
                  parent,
                  networkDetails,
                  stats
                });
                return;
              }
              levelDetails.playlistParsingError = null;
            }
            if (levelDetails.live && loader) {
              if (loader.getCacheAge) {
                levelDetails.ageHeader = loader.getCacheAge() || 0;
              }
              if (!loader.getCacheAge || isNaN(levelDetails.ageHeader)) {
                levelDetails.ageHeader = 0;
              }
            }
            switch (type) {
              case PlaylistContextType.MANIFEST:
              case PlaylistContextType.LEVEL:
                hls.trigger(Events.LEVEL_LOADED, {
                  details: levelDetails,
                  levelInfo: context.levelOrTrack || hls.levels[0],
                  level: levelIndex || 0,
                  id: id || 0,
                  stats,
                  networkDetails,
                  deliveryDirectives,
                  withoutMultiVariant: type === PlaylistContextType.MANIFEST
                });
                break;
              case PlaylistContextType.AUDIO_TRACK:
                hls.trigger(Events.AUDIO_TRACK_LOADED, {
                  details: levelDetails,
                  track: context.levelOrTrack,
                  id: id || 0,
                  groupId: groupId || "",
                  stats,
                  networkDetails,
                  deliveryDirectives
                });
                break;
              case PlaylistContextType.SUBTITLE_TRACK:
                hls.trigger(Events.SUBTITLE_TRACK_LOADED, {
                  details: levelDetails,
                  track: context.levelOrTrack,
                  id: id || 0,
                  groupId: groupId || "",
                  stats,
                  networkDetails,
                  deliveryDirectives
                });
                break;
            }
          };
          return PlaylistLoader2;
        }();
        var SUPPORTED_INFO_DEFAULT = {
          supported: true,
          configurations: [],
          decodingInfoResults: [{
            supported: true,
            powerEfficient: true,
            smooth: true
          }]
        };
        function getUnsupportedResult(error, configurations) {
          return {
            supported: false,
            configurations,
            decodingInfoResults: [{
              supported: false,
              smooth: false,
              powerEfficient: false
            }],
            error
          };
        }
        var SUPPORTED_INFO_CACHE = {};
        function getMediaDecodingInfoPromise(level, audioTracksByGroup, mediaCapabilities) {
          var videoCodecs = level.videoCodec;
          var audioCodecs = level.audioCodec;
          if (!videoCodecs && !audioCodecs || !mediaCapabilities) {
            return Promise.resolve(SUPPORTED_INFO_DEFAULT);
          }
          var configurations = [];
          if (videoCodecs) {
            var baseVideoConfiguration = {
              width: level.width,
              height: level.height,
              bitrate: Math.ceil(Math.max(level.bitrate * 0.9, level.averageBitrate)),
              // Assume a framerate of 30fps since MediaCapabilities will not accept Level default of 0.
              framerate: level.frameRate || 30
            };
            var videoRange = level.videoRange;
            if (videoRange !== "SDR") {
              baseVideoConfiguration.transferFunction = videoRange.toLowerCase();
            }
            var videoCodecsArray = videoCodecs.split(",");
            var ua2 = navigator.userAgent;
            if (videoCodecsArray.some(function(videoCodec) {
              return isHEVC(videoCodec);
            }) && userAgentHevcSupportIsInaccurate()) {
              return Promise.resolve(getUnsupportedResult(new Error("Overriding Windows Firefox HEVC MediaCapabilities result based on user-agent sting: (" + ua2 + ")"), configurations));
            }
            configurations.push.apply(configurations, videoCodecsArray.map(function(videoCodec) {
              return {
                type: "media-source",
                video: _objectSpread23(_objectSpread23({}, baseVideoConfiguration), {}, {
                  contentType: mimeTypeForCodec(fillInMissingAV01Params(videoCodec), "video")
                })
              };
            }));
          }
          if (audioCodecs && level.audioGroups) {
            level.audioGroups.forEach(function(audioGroupId) {
              var _audioTracksByGroup$g;
              if (!audioGroupId) {
                return;
              }
              (_audioTracksByGroup$g = audioTracksByGroup.groups[audioGroupId]) == null ? void 0 : _audioTracksByGroup$g.tracks.forEach(function(audioTrack) {
                if (audioTrack.groupId === audioGroupId) {
                  var channels = audioTrack.channels || "";
                  var channelsNumber = parseFloat(channels);
                  if (isFiniteNumber(channelsNumber) && channelsNumber > 2) {
                    configurations.push.apply(configurations, audioCodecs.split(",").map(function(audioCodec) {
                      return {
                        type: "media-source",
                        audio: {
                          contentType: mimeTypeForCodec(audioCodec, "audio"),
                          channels: "" + channelsNumber
                          // spatialRendering:
                          //   audioCodec === 'ec-3' && channels.indexOf('JOC'),
                        }
                      };
                    }));
                  }
                }
              });
            });
          }
          return Promise.all(configurations.map(function(configuration) {
            var decodingInfoKey = getMediaDecodingInfoKey(configuration);
            return SUPPORTED_INFO_CACHE[decodingInfoKey] || (SUPPORTED_INFO_CACHE[decodingInfoKey] = mediaCapabilities.decodingInfo(configuration));
          })).then(function(decodingInfoResults) {
            return {
              supported: !decodingInfoResults.some(function(info) {
                return !info.supported;
              }),
              configurations,
              decodingInfoResults
            };
          }).catch(function(error) {
            return {
              supported: false,
              configurations,
              decodingInfoResults: [],
              error
            };
          });
        }
        function getMediaDecodingInfoKey(config) {
          var audio = config.audio, video = config.video;
          var mediaConfig = video || audio;
          if (mediaConfig) {
            var codec = getCodecsForMimeType(mediaConfig.contentType);
            if (video) {
              return "r" + video.height + "x" + video.width + "f" + Math.ceil(video.framerate) + (video.transferFunction || "sd") + "_" + codec + "_" + Math.ceil(video.bitrate / 1e5);
            }
            if (audio) {
              return "c" + audio.channels + (audio.spatialRendering ? "s" : "n") + "_" + codec;
            }
          }
          return "";
        }
        var Hls2 = /* @__PURE__ */ function() {
          function Hls3(userConfig) {
            if (userConfig === void 0) {
              userConfig = {};
            }
            this.config = void 0;
            this.userConfig = void 0;
            this.logger = void 0;
            this.coreComponents = void 0;
            this.networkControllers = void 0;
            this._emitter = new EventEmitter5();
            this._autoLevelCapping = -1;
            this._maxHdcpLevel = null;
            this.abrController = void 0;
            this.bufferController = void 0;
            this.capLevelController = void 0;
            this.latencyController = void 0;
            this.levelController = void 0;
            this.streamController = void 0;
            this.audioStreamController = void 0;
            this.subtititleStreamController = void 0;
            this.audioTrackController = void 0;
            this.subtitleTrackController = void 0;
            this.interstitialsController = void 0;
            this.gapController = void 0;
            this.emeController = void 0;
            this.cmcdController = void 0;
            this._media = null;
            this._url = null;
            this._sessionId = void 0;
            this.triggeringException = void 0;
            this.started = false;
            var logger5 = this.logger = enableLogs(userConfig.debug || false, "Hls instance", userConfig.assetPlayerId);
            var config = this.config = mergeConfig(Hls3.DefaultConfig, userConfig, logger5);
            this.userConfig = userConfig;
            if (config.progressive) {
              enableStreamingMode(config, logger5);
            }
            var _AbrController = config.abrController, _BufferController = config.bufferController, _CapLevelController = config.capLevelController, _ErrorController = config.errorController, _FpsController = config.fpsController;
            var errorController = new _ErrorController(this);
            var abrController = this.abrController = new _AbrController(this);
            var fragmentTracker = new FragmentTracker(this);
            var _InterstitialsController = config.interstitialsController;
            var interstitialsController = _InterstitialsController ? this.interstitialsController = new _InterstitialsController(this, Hls3) : null;
            var bufferController = this.bufferController = new _BufferController(this, fragmentTracker);
            var capLevelController = this.capLevelController = new _CapLevelController(this);
            var fpsController = new _FpsController(this);
            var playListLoader = new PlaylistLoader(this);
            var _ContentSteeringController = config.contentSteeringController;
            var contentSteering = _ContentSteeringController ? new _ContentSteeringController(this) : null;
            var levelController = this.levelController = new LevelController(this, contentSteering);
            var id3TrackController = new ID3TrackController(this);
            var keyLoader = new KeyLoader(this.config);
            var streamController = this.streamController = new StreamController(this, fragmentTracker, keyLoader);
            var gapController = this.gapController = new GapController(this, fragmentTracker);
            capLevelController.setStreamController(streamController);
            fpsController.setStreamController(streamController);
            var networkControllers = [playListLoader, levelController, streamController];
            if (interstitialsController) {
              networkControllers.splice(1, 0, interstitialsController);
            }
            if (contentSteering) {
              networkControllers.splice(1, 0, contentSteering);
            }
            this.networkControllers = networkControllers;
            var coreComponents = [abrController, bufferController, gapController, capLevelController, fpsController, id3TrackController, fragmentTracker];
            this.audioTrackController = this.createController(config.audioTrackController, networkControllers);
            var AudioStreamControllerClass = config.audioStreamController;
            if (AudioStreamControllerClass) {
              networkControllers.push(this.audioStreamController = new AudioStreamControllerClass(this, fragmentTracker, keyLoader));
            }
            this.subtitleTrackController = this.createController(config.subtitleTrackController, networkControllers);
            var SubtitleStreamControllerClass = config.subtitleStreamController;
            if (SubtitleStreamControllerClass) {
              networkControllers.push(this.subtititleStreamController = new SubtitleStreamControllerClass(this, fragmentTracker, keyLoader));
            }
            this.createController(config.timelineController, coreComponents);
            keyLoader.emeController = this.emeController = this.createController(config.emeController, coreComponents);
            this.cmcdController = this.createController(config.cmcdController, coreComponents);
            this.latencyController = this.createController(LatencyController, coreComponents);
            this.coreComponents = coreComponents;
            networkControllers.push(errorController);
            var onErrorOut = errorController.onErrorOut;
            if (typeof onErrorOut === "function") {
              this.on(Events.ERROR, onErrorOut, errorController);
            }
            this.on(Events.MANIFEST_LOADED, playListLoader.onManifestLoaded, playListLoader);
          }
          Hls3.isMSESupported = function isMSESupported$1() {
            return isMSESupported();
          };
          Hls3.isSupported = function isSupported$1() {
            return isSupported();
          };
          Hls3.getMediaSource = function getMediaSource$1() {
            return getMediaSource2();
          };
          var _proto = Hls3.prototype;
          _proto.createController = function createController(ControllerClass, components) {
            if (ControllerClass) {
              var controllerInstance = new ControllerClass(this);
              if (components) {
                components.push(controllerInstance);
              }
              return controllerInstance;
            }
            return null;
          };
          _proto.on = function on(event, listener, context) {
            if (context === void 0) {
              context = this;
            }
            this._emitter.on(event, listener, context);
          };
          _proto.once = function once(event, listener, context) {
            if (context === void 0) {
              context = this;
            }
            this._emitter.once(event, listener, context);
          };
          _proto.removeAllListeners = function removeAllListeners(event) {
            this._emitter.removeAllListeners(event);
          };
          _proto.off = function off(event, listener, context, once) {
            if (context === void 0) {
              context = this;
            }
            this._emitter.off(event, listener, context, once);
          };
          _proto.listeners = function listeners(event) {
            return this._emitter.listeners(event);
          };
          _proto.emit = function emit(event, name, eventObject) {
            return this._emitter.emit(event, name, eventObject);
          };
          _proto.trigger = function trigger(event, eventObject) {
            if (this.config.debug) {
              return this.emit(event, event, eventObject);
            } else {
              try {
                return this.emit(event, event, eventObject);
              } catch (error) {
                this.logger.error("An internal error happened while handling event " + event + '. Error message: "' + error.message + '". Here is a stacktrace:', error);
                if (!this.triggeringException) {
                  this.triggeringException = true;
                  var fatal = event === Events.ERROR;
                  this.trigger(Events.ERROR, {
                    type: ErrorTypes.OTHER_ERROR,
                    details: ErrorDetails.INTERNAL_EXCEPTION,
                    fatal,
                    event,
                    error
                  });
                  this.triggeringException = false;
                }
              }
            }
            return false;
          };
          _proto.listenerCount = function listenerCount(event) {
            return this._emitter.listenerCount(event);
          };
          _proto.destroy = function destroy() {
            this.logger.log("destroy");
            this.trigger(Events.DESTROYING, void 0);
            this.detachMedia();
            this.removeAllListeners();
            this._autoLevelCapping = -1;
            this._url = null;
            this.networkControllers.forEach(function(component) {
              return component.destroy();
            });
            this.networkControllers.length = 0;
            this.coreComponents.forEach(function(component) {
              return component.destroy();
            });
            this.coreComponents.length = 0;
            var config = this.config;
            config.xhrSetup = config.fetchSetup = void 0;
            this.userConfig = null;
          };
          _proto.attachMedia = function attachMedia(data) {
            if (!data || "media" in data && !data.media) {
              var error = new Error("attachMedia failed: invalid argument (" + data + ")");
              this.trigger(Events.ERROR, {
                type: ErrorTypes.OTHER_ERROR,
                details: ErrorDetails.ATTACH_MEDIA_ERROR,
                fatal: true,
                error
              });
              return;
            }
            this.logger.log("attachMedia");
            if (this._media) {
              this.logger.warn("media must be detached before attaching");
              this.detachMedia();
            }
            var attachMediaSource = "media" in data;
            var media = attachMediaSource ? data.media : data;
            var attachingData = attachMediaSource ? data : {
              media
            };
            this._media = media;
            this.trigger(Events.MEDIA_ATTACHING, attachingData);
          };
          _proto.detachMedia = function detachMedia() {
            this.logger.log("detachMedia");
            this.trigger(Events.MEDIA_DETACHING, {});
            this._media = null;
          };
          _proto.transferMedia = function transferMedia() {
            this._media = null;
            var transferMedia2 = this.bufferController.transferMedia();
            this.trigger(Events.MEDIA_DETACHING, {
              transferMedia: transferMedia2
            });
            return transferMedia2;
          };
          _proto.loadSource = function loadSource(url) {
            this.stopLoad();
            var media = this.media;
            var loadedSource = this._url;
            var loadingSource = this._url = urlToolkitExports.buildAbsoluteURL(self.location.href, url, {
              alwaysNormalize: true
            });
            this._autoLevelCapping = -1;
            this._maxHdcpLevel = null;
            this.logger.log("loadSource:" + loadingSource);
            if (media && loadedSource && (loadedSource !== loadingSource || this.bufferController.hasSourceTypes())) {
              this.detachMedia();
              this.attachMedia(media);
            }
            this.trigger(Events.MANIFEST_LOADING, {
              url
            });
          };
          _proto.startLoad = function startLoad(startPosition, skipSeekToStartPosition) {
            if (startPosition === void 0) {
              startPosition = -1;
            }
            this.logger.log("startLoad(" + (startPosition + (skipSeekToStartPosition ? ", <skip seek to start>" : "")) + ")");
            this.started = true;
            this.resumeBuffering();
            for (var i = 0; i < this.networkControllers.length; i++) {
              this.networkControllers[i].startLoad(startPosition, skipSeekToStartPosition);
              if (!this.started || !this.networkControllers) {
                break;
              }
            }
          };
          _proto.stopLoad = function stopLoad() {
            this.logger.log("stopLoad");
            this.started = false;
            for (var i = 0; i < this.networkControllers.length; i++) {
              this.networkControllers[i].stopLoad();
              if (this.started || !this.networkControllers) {
                break;
              }
            }
          };
          _proto.resumeBuffering = function resumeBuffering() {
            if (!this.bufferingEnabled) {
              this.logger.log("resume buffering");
              this.networkControllers.forEach(function(controller) {
                if (controller.resumeBuffering) {
                  controller.resumeBuffering();
                }
              });
            }
          };
          _proto.pauseBuffering = function pauseBuffering() {
            if (this.bufferingEnabled) {
              this.logger.log("pause buffering");
              this.networkControllers.forEach(function(controller) {
                if (controller.pauseBuffering) {
                  controller.pauseBuffering();
                }
              });
            }
          };
          _proto.swapAudioCodec = function swapAudioCodec() {
            this.logger.log("swapAudioCodec");
            this.streamController.swapAudioCodec();
          };
          _proto.recoverMediaError = function recoverMediaError() {
            this.logger.log("recoverMediaError");
            var media = this._media;
            var time = media == null ? void 0 : media.currentTime;
            this.detachMedia();
            if (media) {
              this.attachMedia(media);
              if (time) {
                this.startLoad(time);
              }
            }
          };
          _proto.removeLevel = function removeLevel(levelIndex) {
            this.levelController.removeLevel(levelIndex);
          };
          _proto.setAudioOption = function setAudioOption(audioOption) {
            var _this$audioTrackContr;
            return ((_this$audioTrackContr = this.audioTrackController) == null ? void 0 : _this$audioTrackContr.setAudioOption(audioOption)) || null;
          };
          _proto.setSubtitleOption = function setSubtitleOption(subtitleOption) {
            var _this$subtitleTrackCo;
            return ((_this$subtitleTrackCo = this.subtitleTrackController) == null ? void 0 : _this$subtitleTrackCo.setSubtitleOption(subtitleOption)) || null;
          };
          _proto.getMediaDecodingInfo = function getMediaDecodingInfo(level, audioTracks) {
            if (audioTracks === void 0) {
              audioTracks = this.allAudioTracks;
            }
            var audioTracksByGroup = getAudioTracksByGroup(audioTracks);
            return getMediaDecodingInfoPromise(level, audioTracksByGroup, navigator.mediaCapabilities);
          };
          return _createClass4(Hls3, [{
            key: "url",
            get: function get() {
              return this._url;
            }
            /**
             * Whether or not enough has been buffered to seek to start position or use `media.currentTime` to determine next load position
             */
          }, {
            key: "hasEnoughToStart",
            get: function get() {
              return this.streamController.hasEnoughToStart;
            }
            /**
             * Get the startPosition set on startLoad(position) or on autostart with config.startPosition
             */
          }, {
            key: "startPosition",
            get: function get() {
              return this.streamController.startPositionValue;
            }
          }, {
            key: "loadingEnabled",
            get: function get() {
              return this.started;
            }
            /**
             * Returns state of fragment loading toggled by calling `pauseBuffering()` and `resumeBuffering()`.
             */
          }, {
            key: "bufferingEnabled",
            get: function get() {
              return this.streamController.bufferingEnabled;
            }
          }, {
            key: "inFlightFragments",
            get: function get() {
              var _inFlightData;
              var inFlightData = (_inFlightData = {}, _inFlightData[PlaylistLevelType.MAIN] = this.streamController.inFlightFrag, _inFlightData);
              if (this.audioStreamController) {
                inFlightData[PlaylistLevelType.AUDIO] = this.audioStreamController.inFlightFrag;
              }
              if (this.subtititleStreamController) {
                inFlightData[PlaylistLevelType.SUBTITLE] = this.subtititleStreamController.inFlightFrag;
              }
              return inFlightData;
            }
          }, {
            key: "sessionId",
            get: function get() {
              var _sessionId = this._sessionId;
              if (!_sessionId) {
                _sessionId = this._sessionId = uuid();
              }
              return _sessionId;
            }
            /**
             * @returns an array of levels (variants) sorted by HDCP-LEVEL, RESOLUTION (height), FRAME-RATE, CODECS, VIDEO-RANGE, and BANDWIDTH
             */
          }, {
            key: "levels",
            get: function get() {
              var levels = this.levelController.levels;
              return levels ? levels : [];
            }
            /**
             * @returns LevelDetails of last loaded level (variant) or `null` prior to loading a media playlist.
             */
          }, {
            key: "latestLevelDetails",
            get: function get() {
              return this.streamController.getLevelDetails() || null;
            }
            /**
             * @returns Level object of selected level (variant) or `null` prior to selecting a level or once the level is removed.
             */
          }, {
            key: "loadLevelObj",
            get: function get() {
              return this.levelController.loadLevelObj;
            }
            /**
             * Index of quality level (variant) currently played
             */
          }, {
            key: "currentLevel",
            get: function get() {
              return this.streamController.currentLevel;
            },
            set: function set(newLevel) {
              this.logger.log("set currentLevel:" + newLevel);
              this.levelController.manualLevel = newLevel;
              this.streamController.immediateLevelSwitch();
            }
            /**
             * Index of next quality level loaded as scheduled by stream controller.
             */
          }, {
            key: "nextLevel",
            get: function get() {
              return this.streamController.nextLevel;
            },
            set: function set(newLevel) {
              this.logger.log("set nextLevel:" + newLevel);
              this.levelController.manualLevel = newLevel;
              this.streamController.nextLevelSwitch();
            }
            /**
             * Return the quality level of the currently or last (of none is loaded currently) segment
             */
          }, {
            key: "loadLevel",
            get: function get() {
              return this.levelController.level;
            },
            set: function set(newLevel) {
              this.logger.log("set loadLevel:" + newLevel);
              this.levelController.manualLevel = newLevel;
            }
            /**
             * get next quality level loaded
             */
          }, {
            key: "nextLoadLevel",
            get: function get() {
              return this.levelController.nextLoadLevel;
            },
            set: function set(level) {
              this.levelController.nextLoadLevel = level;
            }
            /**
             * Return "first level": like a default level, if not set,
             * falls back to index of first level referenced in manifest
             */
          }, {
            key: "firstLevel",
            get: function get() {
              return Math.max(this.levelController.firstLevel, this.minAutoLevel);
            },
            set: function set(newLevel) {
              this.logger.log("set firstLevel:" + newLevel);
              this.levelController.firstLevel = newLevel;
            }
            /**
             * Return the desired start level for the first fragment that will be loaded.
             * The default value of -1 indicates automatic start level selection.
             * Setting hls.nextAutoLevel without setting a startLevel will result in
             * the nextAutoLevel value being used for one fragment load.
             */
          }, {
            key: "startLevel",
            get: function get() {
              var startLevel = this.levelController.startLevel;
              if (startLevel === -1 && this.abrController.forcedAutoLevel > -1) {
                return this.abrController.forcedAutoLevel;
              }
              return startLevel;
            },
            set: function set(newLevel) {
              this.logger.log("set startLevel:" + newLevel);
              if (newLevel !== -1) {
                newLevel = Math.max(newLevel, this.minAutoLevel);
              }
              this.levelController.startLevel = newLevel;
            }
            /**
             * Whether level capping is enabled.
             * Default value is set via `config.capLevelToPlayerSize`.
             */
          }, {
            key: "capLevelToPlayerSize",
            get: function get() {
              return this.config.capLevelToPlayerSize;
            },
            set: function set(shouldStartCapping) {
              var newCapLevelToPlayerSize = !!shouldStartCapping;
              if (newCapLevelToPlayerSize !== this.config.capLevelToPlayerSize) {
                if (newCapLevelToPlayerSize) {
                  this.capLevelController.startCapping();
                } else {
                  this.capLevelController.stopCapping();
                  this.autoLevelCapping = -1;
                  this.streamController.nextLevelSwitch();
                }
                this.config.capLevelToPlayerSize = newCapLevelToPlayerSize;
              }
            }
            /**
             * Capping/max level value that should be used by automatic level selection algorithm (`ABRController`)
             */
          }, {
            key: "autoLevelCapping",
            get: function get() {
              return this._autoLevelCapping;
            },
            set: (
              /**
               * Capping/max level value that should be used by automatic level selection algorithm (`ABRController`)
               */
              function set(newLevel) {
                if (this._autoLevelCapping !== newLevel) {
                  this.logger.log("set autoLevelCapping:" + newLevel);
                  this._autoLevelCapping = newLevel;
                  this.levelController.checkMaxAutoUpdated();
                }
              }
            )
          }, {
            key: "bandwidthEstimate",
            get: function get() {
              var bwEstimator = this.abrController.bwEstimator;
              if (!bwEstimator) {
                return NaN;
              }
              return bwEstimator.getEstimate();
            },
            set: function set(abrEwmaDefaultEstimate) {
              this.abrController.resetEstimator(abrEwmaDefaultEstimate);
            }
          }, {
            key: "abrEwmaDefaultEstimate",
            get: function get() {
              var bwEstimator = this.abrController.bwEstimator;
              if (!bwEstimator) {
                return NaN;
              }
              return bwEstimator.defaultEstimate;
            }
            /**
             * get time to first byte estimate
             * @type {number}
             */
          }, {
            key: "ttfbEstimate",
            get: function get() {
              var bwEstimator = this.abrController.bwEstimator;
              if (!bwEstimator) {
                return NaN;
              }
              return bwEstimator.getEstimateTTFB();
            }
          }, {
            key: "maxHdcpLevel",
            get: function get() {
              return this._maxHdcpLevel;
            },
            set: function set(value) {
              if (isHdcpLevel(value) && this._maxHdcpLevel !== value) {
                this._maxHdcpLevel = value;
                this.levelController.checkMaxAutoUpdated();
              }
            }
            /**
             * True when automatic level selection enabled
             */
          }, {
            key: "autoLevelEnabled",
            get: function get() {
              return this.levelController.manualLevel === -1;
            }
            /**
             * Level set manually (if any)
             */
          }, {
            key: "manualLevel",
            get: function get() {
              return this.levelController.manualLevel;
            }
            /**
             * min level selectable in auto mode according to config.minAutoBitrate
             */
          }, {
            key: "minAutoLevel",
            get: function get() {
              var levels = this.levels, minAutoBitrate = this.config.minAutoBitrate;
              if (!levels) return 0;
              var len = levels.length;
              for (var i = 0; i < len; i++) {
                if (levels[i].maxBitrate >= minAutoBitrate) {
                  return i;
                }
              }
              return 0;
            }
            /**
             * max level selectable in auto mode according to autoLevelCapping
             */
          }, {
            key: "maxAutoLevel",
            get: function get() {
              var levels = this.levels, autoLevelCapping = this.autoLevelCapping, maxHdcpLevel = this.maxHdcpLevel;
              var maxAutoLevel;
              if (autoLevelCapping === -1 && levels != null && levels.length) {
                maxAutoLevel = levels.length - 1;
              } else {
                maxAutoLevel = autoLevelCapping;
              }
              if (maxHdcpLevel) {
                for (var i = maxAutoLevel; i--; ) {
                  var hdcpLevel = levels[i].attrs["HDCP-LEVEL"];
                  if (hdcpLevel && hdcpLevel <= maxHdcpLevel) {
                    return i;
                  }
                }
              }
              return maxAutoLevel;
            }
          }, {
            key: "firstAutoLevel",
            get: function get() {
              return this.abrController.firstAutoLevel;
            }
            /**
             * next automatically selected quality level
             */
          }, {
            key: "nextAutoLevel",
            get: function get() {
              return this.abrController.nextAutoLevel;
            },
            set: function set(nextLevel) {
              this.abrController.nextAutoLevel = nextLevel;
            }
            /**
             * get the datetime value relative to media.currentTime for the active level Program Date Time if present
             */
          }, {
            key: "playingDate",
            get: function get() {
              return this.streamController.currentProgramDateTime;
            }
          }, {
            key: "mainForwardBufferInfo",
            get: function get() {
              return this.streamController.getMainFwdBufferInfo();
            }
          }, {
            key: "maxBufferLength",
            get: function get() {
              return this.streamController.maxBufferLength;
            }
          }, {
            key: "allAudioTracks",
            get: function get() {
              var audioTrackController = this.audioTrackController;
              return audioTrackController ? audioTrackController.allAudioTracks : [];
            }
            /**
             * Get the list of selectable audio tracks
             */
          }, {
            key: "audioTracks",
            get: function get() {
              var audioTrackController = this.audioTrackController;
              return audioTrackController ? audioTrackController.audioTracks : [];
            }
            /**
             * index of the selected audio track (index in audio track lists)
             */
          }, {
            key: "audioTrack",
            get: function get() {
              var audioTrackController = this.audioTrackController;
              return audioTrackController ? audioTrackController.audioTrack : -1;
            },
            set: function set(audioTrackId) {
              var audioTrackController = this.audioTrackController;
              if (audioTrackController) {
                audioTrackController.audioTrack = audioTrackId;
              }
            }
            /**
             * get the complete list of subtitle tracks across all media groups
             */
          }, {
            key: "allSubtitleTracks",
            get: function get() {
              var subtitleTrackController = this.subtitleTrackController;
              return subtitleTrackController ? subtitleTrackController.allSubtitleTracks : [];
            }
            /**
             * get alternate subtitle tracks list from playlist
             */
          }, {
            key: "subtitleTracks",
            get: function get() {
              var subtitleTrackController = this.subtitleTrackController;
              return subtitleTrackController ? subtitleTrackController.subtitleTracks : [];
            }
            /**
             * index of the selected subtitle track (index in subtitle track lists)
             */
          }, {
            key: "subtitleTrack",
            get: function get() {
              var subtitleTrackController = this.subtitleTrackController;
              return subtitleTrackController ? subtitleTrackController.subtitleTrack : -1;
            },
            set: (
              /**
               * select an subtitle track, based on its index in subtitle track lists
               */
              function set(subtitleTrackId) {
                var subtitleTrackController = this.subtitleTrackController;
                if (subtitleTrackController) {
                  subtitleTrackController.subtitleTrack = subtitleTrackId;
                }
              }
            )
            /**
             * Whether subtitle display is enabled or not
             */
          }, {
            key: "media",
            get: function get() {
              return this._media;
            }
          }, {
            key: "subtitleDisplay",
            get: function get() {
              var subtitleTrackController = this.subtitleTrackController;
              return subtitleTrackController ? subtitleTrackController.subtitleDisplay : false;
            },
            set: function set(value) {
              var subtitleTrackController = this.subtitleTrackController;
              if (subtitleTrackController) {
                subtitleTrackController.subtitleDisplay = value;
              }
            }
            /**
             * get mode for Low-Latency HLS loading
             */
          }, {
            key: "lowLatencyMode",
            get: function get() {
              return this.config.lowLatencyMode;
            },
            set: function set(mode) {
              this.config.lowLatencyMode = mode;
            }
            /**
             * Position (in seconds) of live sync point (ie edge of live position minus safety delay defined by ```hls.config.liveSyncDuration```)
             * @returns null prior to loading live Playlist
             */
          }, {
            key: "liveSyncPosition",
            get: function get() {
              return this.latencyController.liveSyncPosition;
            }
            /**
             * Estimated position (in seconds) of live edge (ie edge of live playlist plus time sync playlist advanced)
             * @returns 0 before first playlist is loaded
             */
          }, {
            key: "latency",
            get: function get() {
              return this.latencyController.latency;
            }
            /**
             * maximum distance from the edge before the player seeks forward to ```hls.liveSyncPosition```
             * configured using ```liveMaxLatencyDurationCount``` (multiple of target duration) or ```liveMaxLatencyDuration```
             * @returns 0 before first playlist is loaded
             */
          }, {
            key: "maxLatency",
            get: function get() {
              return this.latencyController.maxLatency;
            }
            /**
             * target distance from the edge as calculated by the latency controller
             */
          }, {
            key: "targetLatency",
            get: function get() {
              return this.latencyController.targetLatency;
            },
            set: function set(latency) {
              this.latencyController.targetLatency = latency;
            }
            /**
             * the rate at which the edge of the current live playlist is advancing or 1 if there is none
             */
          }, {
            key: "drift",
            get: function get() {
              return this.latencyController.drift;
            }
            /**
             * set to true when startLoad is called before MANIFEST_PARSED event
             */
          }, {
            key: "forceStartLoad",
            get: function get() {
              return this.streamController.forceStartLoad;
            }
            /**
             * ContentSteering pathways getter
             */
          }, {
            key: "pathways",
            get: function get() {
              return this.levelController.pathways;
            }
            /**
             * ContentSteering pathwayPriority getter/setter
             */
          }, {
            key: "pathwayPriority",
            get: function get() {
              return this.levelController.pathwayPriority;
            },
            set: function set(pathwayPriority) {
              this.levelController.pathwayPriority = pathwayPriority;
            }
            /**
             * returns true when all SourceBuffers are buffered to the end
             */
          }, {
            key: "bufferedToEnd",
            get: function get() {
              var _this$bufferControlle;
              return !!((_this$bufferControlle = this.bufferController) != null && _this$bufferControlle.bufferedToEnd);
            }
            /**
             * returns Interstitials Program Manager
             */
          }, {
            key: "interstitialsManager",
            get: function get() {
              var _this$interstitialsCo;
              return ((_this$interstitialsCo = this.interstitialsController) == null ? void 0 : _this$interstitialsCo.interstitialsManager) || null;
            }
          }], [{
            key: "version",
            get: (
              /**
               * Get the video-dev/hls.js package version.
               */
              function get() {
                return version;
              }
            )
          }, {
            key: "Events",
            get: function get() {
              return Events;
            }
          }, {
            key: "MetadataSchema",
            get: function get() {
              return MetadataSchema;
            }
          }, {
            key: "ErrorTypes",
            get: function get() {
              return ErrorTypes;
            }
          }, {
            key: "ErrorDetails",
            get: function get() {
              return ErrorDetails;
            }
            /**
             * Get the default configuration applied to new instances.
             */
          }, {
            key: "DefaultConfig",
            get: function get() {
              if (!Hls3.defaultConfig) {
                return hlsDefaultConfig;
              }
              return Hls3.defaultConfig;
            },
            set: function set(defaultConfig) {
              Hls3.defaultConfig = defaultConfig;
            }
          }]);
        }();
        Hls2.defaultConfig = void 0;
        return Hls2;
      });
    })(false);
  }
});

// node_modules/xgplayer-flv/es/_virtual/_rollupPluginBabelHelpers.js
function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread2(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys(Object(source), true).forEach(function(key) {
      _defineProperty(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
function _regeneratorRuntime() {
  _regeneratorRuntime = function() {
    return exports;
  };
  var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, defineProperty = Object.defineProperty || function(obj, key, desc) {
    obj[key] = desc.value;
  }, $Symbol = "function" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || "@@iterator", asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator", toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";
  function define2(obj, key, value) {
    return Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    }), obj[key];
  }
  try {
    define2({}, "");
  } catch (err) {
    define2 = function(obj, key, value) {
      return obj[key] = value;
    };
  }
  function wrap(innerFn, outerFn, self2, tryLocsList) {
    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []);
    return defineProperty(generator, "_invoke", {
      value: makeInvokeMethod(innerFn, self2, context)
    }), generator;
  }
  function tryCatch(fn, obj, arg) {
    try {
      return {
        type: "normal",
        arg: fn.call(obj, arg)
      };
    } catch (err) {
      return {
        type: "throw",
        arg: err
      };
    }
  }
  exports.wrap = wrap;
  var ContinueSentinel = {};
  function Generator() {
  }
  function GeneratorFunction() {
  }
  function GeneratorFunctionPrototype() {
  }
  var IteratorPrototype = {};
  define2(IteratorPrototype, iteratorSymbol, function() {
    return this;
  });
  var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([])));
  NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype);
  var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype);
  function defineIteratorMethods(prototype) {
    ["next", "throw", "return"].forEach(function(method) {
      define2(prototype, method, function(arg) {
        return this._invoke(method, arg);
      });
    });
  }
  function AsyncIterator(generator, PromiseImpl) {
    function invoke(method, arg, resolve, reject) {
      var record = tryCatch(generator[method], generator, arg);
      if ("throw" !== record.type) {
        var result = record.arg, value = result.value;
        return value && "object" == typeof value && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function(value2) {
          invoke("next", value2, resolve, reject);
        }, function(err) {
          invoke("throw", err, resolve, reject);
        }) : PromiseImpl.resolve(value).then(function(unwrapped) {
          result.value = unwrapped, resolve(result);
        }, function(error) {
          return invoke("throw", error, resolve, reject);
        });
      }
      reject(record.arg);
    }
    var previousPromise;
    defineProperty(this, "_invoke", {
      value: function(method, arg) {
        function callInvokeWithMethodAndArg() {
          return new PromiseImpl(function(resolve, reject) {
            invoke(method, arg, resolve, reject);
          });
        }
        return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
      }
    });
  }
  function makeInvokeMethod(innerFn, self2, context) {
    var state = "suspendedStart";
    return function(method, arg) {
      if ("executing" === state)
        throw new Error("Generator is already running");
      if ("completed" === state) {
        if ("throw" === method)
          throw arg;
        return doneResult();
      }
      for (context.method = method, context.arg = arg; ; ) {
        var delegate = context.delegate;
        if (delegate) {
          var delegateResult = maybeInvokeDelegate(delegate, context);
          if (delegateResult) {
            if (delegateResult === ContinueSentinel)
              continue;
            return delegateResult;
          }
        }
        if ("next" === context.method)
          context.sent = context._sent = context.arg;
        else if ("throw" === context.method) {
          if ("suspendedStart" === state)
            throw state = "completed", context.arg;
          context.dispatchException(context.arg);
        } else
          "return" === context.method && context.abrupt("return", context.arg);
        state = "executing";
        var record = tryCatch(innerFn, self2, context);
        if ("normal" === record.type) {
          if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel)
            continue;
          return {
            value: record.arg,
            done: context.done
          };
        }
        "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg);
      }
    };
  }
  function maybeInvokeDelegate(delegate, context) {
    var methodName = context.method, method = delegate.iterator[methodName];
    if (void 0 === method)
      return context.delegate = null, "throw" === methodName && delegate.iterator.return && (context.method = "return", context.arg = void 0, maybeInvokeDelegate(delegate, context), "throw" === context.method) || "return" !== methodName && (context.method = "throw", context.arg = new TypeError("The iterator does not provide a '" + methodName + "' method")), ContinueSentinel;
    var record = tryCatch(method, delegate.iterator, context.arg);
    if ("throw" === record.type)
      return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel;
    var info = record.arg;
    return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = void 0), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel);
  }
  function pushTryEntry(locs) {
    var entry = {
      tryLoc: locs[0]
    };
    1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry);
  }
  function resetTryEntry(entry) {
    var record = entry.completion || {};
    record.type = "normal", delete record.arg, entry.completion = record;
  }
  function Context(tryLocsList) {
    this.tryEntries = [{
      tryLoc: "root"
    }], tryLocsList.forEach(pushTryEntry, this), this.reset(true);
  }
  function values(iterable) {
    if (iterable) {
      var iteratorMethod = iterable[iteratorSymbol];
      if (iteratorMethod)
        return iteratorMethod.call(iterable);
      if ("function" == typeof iterable.next)
        return iterable;
      if (!isNaN(iterable.length)) {
        var i = -1, next = function next2() {
          for (; ++i < iterable.length; )
            if (hasOwn.call(iterable, i))
              return next2.value = iterable[i], next2.done = false, next2;
          return next2.value = void 0, next2.done = true, next2;
        };
        return next.next = next;
      }
    }
    return {
      next: doneResult
    };
  }
  function doneResult() {
    return {
      value: void 0,
      done: true
    };
  }
  return GeneratorFunction.prototype = GeneratorFunctionPrototype, defineProperty(Gp, "constructor", {
    value: GeneratorFunctionPrototype,
    configurable: true
  }), defineProperty(GeneratorFunctionPrototype, "constructor", {
    value: GeneratorFunction,
    configurable: true
  }), GeneratorFunction.displayName = define2(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function(genFun) {
    var ctor = "function" == typeof genFun && genFun.constructor;
    return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name));
  }, exports.mark = function(genFun) {
    return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define2(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun;
  }, exports.awrap = function(arg) {
    return {
      __await: arg
    };
  }, defineIteratorMethods(AsyncIterator.prototype), define2(AsyncIterator.prototype, asyncIteratorSymbol, function() {
    return this;
  }), exports.AsyncIterator = AsyncIterator, exports.async = function(innerFn, outerFn, self2, tryLocsList, PromiseImpl) {
    void 0 === PromiseImpl && (PromiseImpl = Promise);
    var iter = new AsyncIterator(wrap(innerFn, outerFn, self2, tryLocsList), PromiseImpl);
    return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function(result) {
      return result.done ? result.value : iter.next();
    });
  }, defineIteratorMethods(Gp), define2(Gp, toStringTagSymbol, "Generator"), define2(Gp, iteratorSymbol, function() {
    return this;
  }), define2(Gp, "toString", function() {
    return "[object Generator]";
  }), exports.keys = function(val) {
    var object = Object(val), keys = [];
    for (var key in object)
      keys.push(key);
    return keys.reverse(), function next() {
      for (; keys.length; ) {
        var key2 = keys.pop();
        if (key2 in object)
          return next.value = key2, next.done = false, next;
      }
      return next.done = true, next;
    };
  }, exports.values = values, Context.prototype = {
    constructor: Context,
    reset: function(skipTempReset) {
      if (this.prev = 0, this.next = 0, this.sent = this._sent = void 0, this.done = false, this.delegate = null, this.method = "next", this.arg = void 0, this.tryEntries.forEach(resetTryEntry), !skipTempReset)
        for (var name in this)
          "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = void 0);
    },
    stop: function() {
      this.done = true;
      var rootRecord = this.tryEntries[0].completion;
      if ("throw" === rootRecord.type)
        throw rootRecord.arg;
      return this.rval;
    },
    dispatchException: function(exception) {
      if (this.done)
        throw exception;
      var context = this;
      function handle(loc, caught) {
        return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = void 0), !!caught;
      }
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i], record = entry.completion;
        if ("root" === entry.tryLoc)
          return handle("end");
        if (entry.tryLoc <= this.prev) {
          var hasCatch = hasOwn.call(entry, "catchLoc"), hasFinally = hasOwn.call(entry, "finallyLoc");
          if (hasCatch && hasFinally) {
            if (this.prev < entry.catchLoc)
              return handle(entry.catchLoc, true);
            if (this.prev < entry.finallyLoc)
              return handle(entry.finallyLoc);
          } else if (hasCatch) {
            if (this.prev < entry.catchLoc)
              return handle(entry.catchLoc, true);
          } else {
            if (!hasFinally)
              throw new Error("try statement without catch or finally");
            if (this.prev < entry.finallyLoc)
              return handle(entry.finallyLoc);
          }
        }
      }
    },
    abrupt: function(type, arg) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) {
          var finallyEntry = entry;
          break;
        }
      }
      finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null);
      var record = finallyEntry ? finallyEntry.completion : {};
      return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record);
    },
    complete: function(record, afterLoc) {
      if ("throw" === record.type)
        throw record.arg;
      return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel;
    },
    finish: function(finallyLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.finallyLoc === finallyLoc)
          return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel;
      }
    },
    catch: function(tryLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc === tryLoc) {
          var record = entry.completion;
          if ("throw" === record.type) {
            var thrown = record.arg;
            resetTryEntry(entry);
          }
          return thrown;
        }
      }
      throw new Error("illegal catch attempt");
    },
    delegateYield: function(iterable, resultName, nextLoc) {
      return this.delegate = {
        iterator: values(iterable),
        resultName,
        nextLoc
      }, "next" === this.method && (this.arg = void 0), ContinueSentinel;
    }
  }, exports;
}
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
  try {
    var info = gen[key](arg);
    var value = info.value;
  } catch (error) {
    reject(error);
    return;
  }
  if (info.done) {
    resolve(value);
  } else {
    Promise.resolve(value).then(_next, _throw);
  }
}
function _asyncToGenerator(fn) {
  return function() {
    var self2 = this, args = arguments;
    return new Promise(function(resolve, reject) {
      var gen = fn.apply(self2, args);
      function _next(value) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
      }
      function _throw(err) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
      }
      _next(void 0);
    });
  };
}
function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
  }
}
function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", {
    writable: false
  });
  return Constructor;
}
function _defineProperty(obj, key, value) {
  key = _toPropertyKey(key);
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  Object.defineProperty(subClass, "prototype", {
    writable: false
  });
  if (superClass)
    _setPrototypeOf(subClass, superClass);
}
function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf22(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf(o);
}
function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf22(o2, p2) {
    o2.__proto__ = p2;
    return o2;
  };
  return _setPrototypeOf(o, p);
}
function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}
function _assertThisInitialized(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _possibleConstructorReturn(self2, call) {
  if (call && (typeof call === "object" || typeof call === "function")) {
    return call;
  } else if (call !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }
  return _assertThisInitialized(self2);
}
function _createSuper(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _toPrimitive(input, hint) {
  if (typeof input !== "object" || input === null)
    return input;
  var prim = input[Symbol.toPrimitive];
  if (prim !== void 0) {
    var res = prim.call(input, hint || "default");
    if (typeof res !== "object")
      return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input);
}
function _toPropertyKey(arg) {
  var key = _toPrimitive(arg, "string");
  return typeof key === "symbol" ? key : String(key);
}

// node_modules/xgplayer-streaming-shared/es/_virtual/_rollupPluginBabelHelpers.js
function ownKeys2(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread22(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys2(Object(source), true).forEach(function(key) {
      _defineProperty2(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys2(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
function _regeneratorRuntime2() {
  _regeneratorRuntime2 = function() {
    return exports;
  };
  var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, defineProperty = Object.defineProperty || function(obj, key, desc) {
    obj[key] = desc.value;
  }, $Symbol = "function" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || "@@iterator", asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator", toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";
  function define2(obj, key, value) {
    return Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    }), obj[key];
  }
  try {
    define2({}, "");
  } catch (err) {
    define2 = function(obj, key, value) {
      return obj[key] = value;
    };
  }
  function wrap(innerFn, outerFn, self2, tryLocsList) {
    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []);
    return defineProperty(generator, "_invoke", {
      value: makeInvokeMethod(innerFn, self2, context)
    }), generator;
  }
  function tryCatch(fn, obj, arg) {
    try {
      return {
        type: "normal",
        arg: fn.call(obj, arg)
      };
    } catch (err) {
      return {
        type: "throw",
        arg: err
      };
    }
  }
  exports.wrap = wrap;
  var ContinueSentinel = {};
  function Generator() {
  }
  function GeneratorFunction() {
  }
  function GeneratorFunctionPrototype() {
  }
  var IteratorPrototype = {};
  define2(IteratorPrototype, iteratorSymbol, function() {
    return this;
  });
  var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([])));
  NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype);
  var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype);
  function defineIteratorMethods(prototype) {
    ["next", "throw", "return"].forEach(function(method) {
      define2(prototype, method, function(arg) {
        return this._invoke(method, arg);
      });
    });
  }
  function AsyncIterator(generator, PromiseImpl) {
    function invoke(method, arg, resolve, reject) {
      var record = tryCatch(generator[method], generator, arg);
      if ("throw" !== record.type) {
        var result = record.arg, value = result.value;
        return value && "object" == typeof value && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function(value2) {
          invoke("next", value2, resolve, reject);
        }, function(err) {
          invoke("throw", err, resolve, reject);
        }) : PromiseImpl.resolve(value).then(function(unwrapped) {
          result.value = unwrapped, resolve(result);
        }, function(error) {
          return invoke("throw", error, resolve, reject);
        });
      }
      reject(record.arg);
    }
    var previousPromise;
    defineProperty(this, "_invoke", {
      value: function(method, arg) {
        function callInvokeWithMethodAndArg() {
          return new PromiseImpl(function(resolve, reject) {
            invoke(method, arg, resolve, reject);
          });
        }
        return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
      }
    });
  }
  function makeInvokeMethod(innerFn, self2, context) {
    var state = "suspendedStart";
    return function(method, arg) {
      if ("executing" === state)
        throw new Error("Generator is already running");
      if ("completed" === state) {
        if ("throw" === method)
          throw arg;
        return doneResult();
      }
      for (context.method = method, context.arg = arg; ; ) {
        var delegate = context.delegate;
        if (delegate) {
          var delegateResult = maybeInvokeDelegate(delegate, context);
          if (delegateResult) {
            if (delegateResult === ContinueSentinel)
              continue;
            return delegateResult;
          }
        }
        if ("next" === context.method)
          context.sent = context._sent = context.arg;
        else if ("throw" === context.method) {
          if ("suspendedStart" === state)
            throw state = "completed", context.arg;
          context.dispatchException(context.arg);
        } else
          "return" === context.method && context.abrupt("return", context.arg);
        state = "executing";
        var record = tryCatch(innerFn, self2, context);
        if ("normal" === record.type) {
          if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel)
            continue;
          return {
            value: record.arg,
            done: context.done
          };
        }
        "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg);
      }
    };
  }
  function maybeInvokeDelegate(delegate, context) {
    var methodName = context.method, method = delegate.iterator[methodName];
    if (void 0 === method)
      return context.delegate = null, "throw" === methodName && delegate.iterator.return && (context.method = "return", context.arg = void 0, maybeInvokeDelegate(delegate, context), "throw" === context.method) || "return" !== methodName && (context.method = "throw", context.arg = new TypeError("The iterator does not provide a '" + methodName + "' method")), ContinueSentinel;
    var record = tryCatch(method, delegate.iterator, context.arg);
    if ("throw" === record.type)
      return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel;
    var info = record.arg;
    return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = void 0), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel);
  }
  function pushTryEntry(locs) {
    var entry = {
      tryLoc: locs[0]
    };
    1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry);
  }
  function resetTryEntry(entry) {
    var record = entry.completion || {};
    record.type = "normal", delete record.arg, entry.completion = record;
  }
  function Context(tryLocsList) {
    this.tryEntries = [{
      tryLoc: "root"
    }], tryLocsList.forEach(pushTryEntry, this), this.reset(true);
  }
  function values(iterable) {
    if (iterable) {
      var iteratorMethod = iterable[iteratorSymbol];
      if (iteratorMethod)
        return iteratorMethod.call(iterable);
      if ("function" == typeof iterable.next)
        return iterable;
      if (!isNaN(iterable.length)) {
        var i = -1, next = function next2() {
          for (; ++i < iterable.length; )
            if (hasOwn.call(iterable, i))
              return next2.value = iterable[i], next2.done = false, next2;
          return next2.value = void 0, next2.done = true, next2;
        };
        return next.next = next;
      }
    }
    return {
      next: doneResult
    };
  }
  function doneResult() {
    return {
      value: void 0,
      done: true
    };
  }
  return GeneratorFunction.prototype = GeneratorFunctionPrototype, defineProperty(Gp, "constructor", {
    value: GeneratorFunctionPrototype,
    configurable: true
  }), defineProperty(GeneratorFunctionPrototype, "constructor", {
    value: GeneratorFunction,
    configurable: true
  }), GeneratorFunction.displayName = define2(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function(genFun) {
    var ctor = "function" == typeof genFun && genFun.constructor;
    return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name));
  }, exports.mark = function(genFun) {
    return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define2(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun;
  }, exports.awrap = function(arg) {
    return {
      __await: arg
    };
  }, defineIteratorMethods(AsyncIterator.prototype), define2(AsyncIterator.prototype, asyncIteratorSymbol, function() {
    return this;
  }), exports.AsyncIterator = AsyncIterator, exports.async = function(innerFn, outerFn, self2, tryLocsList, PromiseImpl) {
    void 0 === PromiseImpl && (PromiseImpl = Promise);
    var iter = new AsyncIterator(wrap(innerFn, outerFn, self2, tryLocsList), PromiseImpl);
    return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function(result) {
      return result.done ? result.value : iter.next();
    });
  }, defineIteratorMethods(Gp), define2(Gp, toStringTagSymbol, "Generator"), define2(Gp, iteratorSymbol, function() {
    return this;
  }), define2(Gp, "toString", function() {
    return "[object Generator]";
  }), exports.keys = function(val) {
    var object = Object(val), keys = [];
    for (var key in object)
      keys.push(key);
    return keys.reverse(), function next() {
      for (; keys.length; ) {
        var key2 = keys.pop();
        if (key2 in object)
          return next.value = key2, next.done = false, next;
      }
      return next.done = true, next;
    };
  }, exports.values = values, Context.prototype = {
    constructor: Context,
    reset: function(skipTempReset) {
      if (this.prev = 0, this.next = 0, this.sent = this._sent = void 0, this.done = false, this.delegate = null, this.method = "next", this.arg = void 0, this.tryEntries.forEach(resetTryEntry), !skipTempReset)
        for (var name in this)
          "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = void 0);
    },
    stop: function() {
      this.done = true;
      var rootRecord = this.tryEntries[0].completion;
      if ("throw" === rootRecord.type)
        throw rootRecord.arg;
      return this.rval;
    },
    dispatchException: function(exception) {
      if (this.done)
        throw exception;
      var context = this;
      function handle(loc, caught) {
        return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = void 0), !!caught;
      }
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i], record = entry.completion;
        if ("root" === entry.tryLoc)
          return handle("end");
        if (entry.tryLoc <= this.prev) {
          var hasCatch = hasOwn.call(entry, "catchLoc"), hasFinally = hasOwn.call(entry, "finallyLoc");
          if (hasCatch && hasFinally) {
            if (this.prev < entry.catchLoc)
              return handle(entry.catchLoc, true);
            if (this.prev < entry.finallyLoc)
              return handle(entry.finallyLoc);
          } else if (hasCatch) {
            if (this.prev < entry.catchLoc)
              return handle(entry.catchLoc, true);
          } else {
            if (!hasFinally)
              throw new Error("try statement without catch or finally");
            if (this.prev < entry.finallyLoc)
              return handle(entry.finallyLoc);
          }
        }
      }
    },
    abrupt: function(type, arg) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) {
          var finallyEntry = entry;
          break;
        }
      }
      finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null);
      var record = finallyEntry ? finallyEntry.completion : {};
      return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record);
    },
    complete: function(record, afterLoc) {
      if ("throw" === record.type)
        throw record.arg;
      return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel;
    },
    finish: function(finallyLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.finallyLoc === finallyLoc)
          return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel;
      }
    },
    catch: function(tryLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc === tryLoc) {
          var record = entry.completion;
          if ("throw" === record.type) {
            var thrown = record.arg;
            resetTryEntry(entry);
          }
          return thrown;
        }
      }
      throw new Error("illegal catch attempt");
    },
    delegateYield: function(iterable, resultName, nextLoc) {
      return this.delegate = {
        iterator: values(iterable),
        resultName,
        nextLoc
      }, "next" === this.method && (this.arg = void 0), ContinueSentinel;
    }
  }, exports;
}
function _typeof(obj) {
  "@babel/helpers - typeof";
  return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
    return typeof obj2;
  } : function(obj2) {
    return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
  }, _typeof(obj);
}
function asyncGeneratorStep2(gen, resolve, reject, _next, _throw, key, arg) {
  try {
    var info = gen[key](arg);
    var value = info.value;
  } catch (error) {
    reject(error);
    return;
  }
  if (info.done) {
    resolve(value);
  } else {
    Promise.resolve(value).then(_next, _throw);
  }
}
function _asyncToGenerator2(fn) {
  return function() {
    var self2 = this, args = arguments;
    return new Promise(function(resolve, reject) {
      var gen = fn.apply(self2, args);
      function _next(value) {
        asyncGeneratorStep2(gen, resolve, reject, _next, _throw, "next", value);
      }
      function _throw(err) {
        asyncGeneratorStep2(gen, resolve, reject, _next, _throw, "throw", err);
      }
      _next(void 0);
    });
  };
}
function _classCallCheck2(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties2(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, _toPropertyKey2(descriptor.key), descriptor);
  }
}
function _createClass2(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties2(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties2(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", {
    writable: false
  });
  return Constructor;
}
function _defineProperty2(obj, key, value) {
  key = _toPropertyKey2(key);
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _inherits2(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  Object.defineProperty(subClass, "prototype", {
    writable: false
  });
  if (superClass)
    _setPrototypeOf2(subClass, superClass);
}
function _getPrototypeOf2(o) {
  _getPrototypeOf2 = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf22(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf2(o);
}
function _setPrototypeOf2(o, p) {
  _setPrototypeOf2 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf22(o2, p2) {
    o2.__proto__ = p2;
    return o2;
  };
  return _setPrototypeOf2(o, p);
}
function _isNativeReflectConstruct2() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}
function _construct(Parent, args, Class) {
  if (_isNativeReflectConstruct2()) {
    _construct = Reflect.construct.bind();
  } else {
    _construct = function _construct2(Parent2, args2, Class2) {
      var a = [null];
      a.push.apply(a, args2);
      var Constructor = Function.bind.apply(Parent2, a);
      var instance = new Constructor();
      if (Class2)
        _setPrototypeOf2(instance, Class2.prototype);
      return instance;
    };
  }
  return _construct.apply(null, arguments);
}
function _isNativeFunction(fn) {
  return Function.toString.call(fn).indexOf("[native code]") !== -1;
}
function _wrapNativeSuper(Class) {
  var _cache = typeof Map === "function" ? /* @__PURE__ */ new Map() : void 0;
  _wrapNativeSuper = function _wrapNativeSuper2(Class2) {
    if (Class2 === null || !_isNativeFunction(Class2))
      return Class2;
    if (typeof Class2 !== "function") {
      throw new TypeError("Super expression must either be null or a function");
    }
    if (typeof _cache !== "undefined") {
      if (_cache.has(Class2))
        return _cache.get(Class2);
      _cache.set(Class2, Wrapper);
    }
    function Wrapper() {
      return _construct(Class2, arguments, _getPrototypeOf2(this).constructor);
    }
    Wrapper.prototype = Object.create(Class2.prototype, {
      constructor: {
        value: Wrapper,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
    return _setPrototypeOf2(Wrapper, Class2);
  };
  return _wrapNativeSuper(Class);
}
function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null)
    return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0)
      continue;
    target[key] = source[key];
  }
  return target;
}
function _objectWithoutProperties(source, excluded) {
  if (source == null)
    return {};
  var target = _objectWithoutPropertiesLoose(source, excluded);
  var key, i;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0)
        continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key))
        continue;
      target[key] = source[key];
    }
  }
  return target;
}
function _assertThisInitialized2(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _possibleConstructorReturn2(self2, call) {
  if (call && (typeof call === "object" || typeof call === "function")) {
    return call;
  } else if (call !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }
  return _assertThisInitialized2(self2);
}
function _createSuper2(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct2();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf2(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf2(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn2(this, result);
  };
}
function _superPropBase(object, property) {
  while (!Object.prototype.hasOwnProperty.call(object, property)) {
    object = _getPrototypeOf2(object);
    if (object === null)
      break;
  }
  return object;
}
function _get() {
  if (typeof Reflect !== "undefined" && Reflect.get) {
    _get = Reflect.get.bind();
  } else {
    _get = function _get2(target, property, receiver) {
      var base = _superPropBase(target, property);
      if (!base)
        return;
      var desc = Object.getOwnPropertyDescriptor(base, property);
      if (desc.get) {
        return desc.get.call(arguments.length < 3 ? target : receiver);
      }
      return desc.value;
    };
  }
  return _get.apply(this, arguments);
}
function _unsupportedIterableToArray(o, minLen) {
  if (!o)
    return;
  if (typeof o === "string")
    return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor)
    n = o.constructor.name;
  if (n === "Map" || n === "Set")
    return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
    return _arrayLikeToArray(o, minLen);
}
function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++)
    arr2[i] = arr[i];
  return arr2;
}
function _createForOfIteratorHelper(o, allowArrayLike) {
  var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
  if (!it) {
    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
      if (it)
        o = it;
      var i = 0;
      var F = function() {
      };
      return {
        s: F,
        n: function() {
          if (i >= o.length)
            return {
              done: true
            };
          return {
            done: false,
            value: o[i++]
          };
        },
        e: function(e) {
          throw e;
        },
        f: F
      };
    }
    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  var normalCompletion = true, didErr = false, err;
  return {
    s: function() {
      it = it.call(o);
    },
    n: function() {
      var step = it.next();
      normalCompletion = step.done;
      return step;
    },
    e: function(e) {
      didErr = true;
      err = e;
    },
    f: function() {
      try {
        if (!normalCompletion && it.return != null)
          it.return();
      } finally {
        if (didErr)
          throw err;
      }
    }
  };
}
function _toPrimitive2(input, hint) {
  if (typeof input !== "object" || input === null)
    return input;
  var prim = input[Symbol.toPrimitive];
  if (prim !== void 0) {
    var res = prim.call(input, hint || "default");
    if (typeof res !== "object")
      return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input);
}
function _toPropertyKey2(arg) {
  var key = _toPrimitive2(arg, "string");
  return typeof key === "symbol" ? key : String(key);
}

// node_modules/xgplayer-streaming-shared/es/buffer.js
var Buffer2 = /* @__PURE__ */ function() {
  function Buffer22() {
    _classCallCheck2(this, Buffer22);
  }
  _createClass2(Buffer22, null, [{
    key: "start",
    value: function start(buf) {
      if (!buf || !buf.length)
        return 0;
      if (buf.length === 1 && buf.end(0) - buf.start(0) < 1e-6)
        return 0;
      if (buf.length === 1 && buf.start(0) < 0)
        return 0;
      return buf.start(0);
    }
  }, {
    key: "end",
    value: function end(buf) {
      if (!buf || !buf.length)
        return 0;
      if (buf.length === 1 && buf.end(0) - buf.start(0) < 1e-6)
        return 0;
      return buf.end(buf.length - 1);
    }
  }, {
    key: "get",
    value: function get(b) {
      if (!b)
        return;
      try {
        return b.buffered;
      } catch (error) {
      }
    }
  }, {
    key: "buffers",
    value: function buffers(buf, maxHole) {
      if (!buf || !buf.length)
        return [];
      var buffers2 = [];
      for (var i = 0, l = buf.length; i < l; i++) {
        var bufLen = buffers2.length;
        if (!bufLen || !maxHole) {
          buffers2.push([buf.start(i), buf.end(i)]);
        } else {
          var last = buffers2[bufLen - 1];
          var lastEnd = last[1];
          var start = buf.start(i);
          if (start - lastEnd <= maxHole) {
            var end = buf.end(i);
            if (end > lastEnd) {
              last[1] = end;
            }
          } else {
            buffers2.push([buf.start(i), buf.end(i)]);
          }
        }
      }
      return buffers2;
    }
  }, {
    key: "totalLength",
    value: function totalLength(buffers) {
      if (!buffers || !buffers.length)
        return 0;
      return buffers.reduce(function(a, c) {
        return a += c[1] - c[0];
      }, 0);
    }
  }, {
    key: "info",
    value: function info(buf) {
      var pos = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
      var maxHole = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
      if (!buf || !buf.length)
        return {
          start: 0,
          end: 0,
          buffers: []
        };
      var start = 0;
      var end = 0;
      var index = 0;
      var nextStart = 0;
      var nextEnd = 0;
      var prevStart = 0;
      var prevEnd = 0;
      var buffers = Buffer22.buffers(buf, maxHole);
      for (var i = 0, l = buffers.length; i < l; i++) {
        var item = buffers[i];
        if (pos + maxHole >= item[0] && pos <= item[1]) {
          start = item[0];
          end = item[1];
          index = i;
        } else if (pos + maxHole < item[0]) {
          nextStart = item[0];
          nextEnd = item[1];
          break;
        } else if (pos + maxHole > item[1]) {
          prevStart = item[0];
          prevEnd = item[1];
        }
      }
      return {
        start,
        end,
        index,
        buffers,
        nextStart,
        nextEnd,
        prevStart,
        prevEnd,
        currentTime: pos,
        behind: pos - start,
        remaining: end ? end - pos : 0,
        length: Buffer22.totalLength && Buffer22.totalLength(buffers)
      };
    }
  }, {
    key: "isBuffered",
    value: function isBuffered(media, pos) {
      if (media) {
        var buffered = Buffer22.get(media);
        if (buffered !== null && buffered !== void 0 && buffered.length) {
          for (var i = 0; i < buffered.length; i++) {
            if (pos >= buffered.start(i) && pos <= buffered.end(i)) {
              return true;
            }
          }
        }
      }
      return false;
    }
  }]);
  return Buffer22;
}();

// node_modules/xgplayer-streaming-shared/es/env.js
var isBrowser = typeof window !== "undefined";

// node_modules/xgplayer-streaming-shared/es/error.js
var _ERR_CODE;
var ERR = {
  MANIFEST: "manifest",
  NETWORK: "network",
  NETWORK_TIMEOUT: "network_timeout",
  NETWORK_FORBIDDEN: "network_forbidden",
  NETWORK_NOTFOUND: "network_notfound",
  NETWROK_RANGE_NOT_SATISFIABLE: "network_range_not_satisfiable",
  DEMUX: "demux",
  REMUX: "remux",
  MEDIA: "media",
  DRM: "drm",
  OTHER: "other",
  RUNTIME: "runtime",
  SUB_TYPES: {
    FLV: "FLV",
    HLS: "HLS",
    MP4: "MP4",
    FMP4: "FMP4",
    MSE_ADD_SB: "MSE_ADD_SB",
    MSE_APPEND_BUFFER: "MSE_APPEND_BUFFER",
    MSE_OTHER: "MSE_OTHER",
    MSE_FULL: "MSE_FULL",
    MSE_CHANGE_TYPE: "MSE_CHANGE_TYPE",
    OPTION: "OPTION",
    DASH: "DASH",
    LICENSE: "LICENSE",
    CUSTOM_LICENSE: "CUSTOM_LICENSE",
    MSE_HIJACK: "MSE_HIJACK",
    EME_HIJACK: "EME_HIJACK",
    SIDX: "SIDX",
    NO_CANPLAY_ERROR: "NO_CANPLAY_ERROR",
    BUFFERBREAK_ERROR: "BUFFERBREAK_ERROR",
    WAITING_TIMEOUT_ERROR: "WAITING_TIMEOUT_ERROR",
    MEDIA_ERR_ABORTED: "MEDIA_ERR_ABORTED",
    MEDIA_ERR_NETWORK: "MEDIA_ERR_NETWORK",
    MEDIA_ERR_DECODE: "MEDIA_ERR_DECODE",
    MEDIA_ERR_SRC_NOT_SUPPORTED: "MEDIA_ERR_SRC_NOT_SUPPORTED",
    MEDIA_ERR_CODEC_NOT_SUPPORTED: "MEDIA_ERR_CODEC_NOT_SUPPORTED",
    MEDIA_ERR_URL_EMPTY: "MEDIA_ERR_URL_EMPTY"
  }
};
var ERR_CODE = (_ERR_CODE = {}, _defineProperty2(_ERR_CODE, ERR.MANIFEST, {
  HLS: 1100,
  DASH: 1200
}), _defineProperty2(_ERR_CODE, ERR.NETWORK, 2100), _defineProperty2(_ERR_CODE, ERR.NETWORK_TIMEOUT, 2101), _defineProperty2(_ERR_CODE, ERR.NETWORK_FORBIDDEN, 2103), _defineProperty2(_ERR_CODE, ERR.NETWORK_NOTFOUND, 2104), _defineProperty2(_ERR_CODE, ERR.NETWROK_RANGE_NOT_SATISFIABLE, 2116), _defineProperty2(_ERR_CODE, ERR.DEMUX, {
  FLV: 3100,
  HLS: 3200,
  MP4: 3300,
  FMP4: 3400,
  SIDX: 3410
}), _defineProperty2(_ERR_CODE, ERR.REMUX, {
  FMP4: 4100,
  MP4: 4200
}), _defineProperty2(_ERR_CODE, ERR.MEDIA, {
  MEDIA_ERR_ABORTED: 5101,
  MEDIA_ERR_NETWORK: 5102,
  MEDIA_ERR_DECODE: 5103,
  MEDIA_ERR_SRC_NOT_SUPPORTED: 5104,
  MEDIA_ERR_CODEC_NOT_SUPPORTED: 5105,
  MEDIA_ERR_URL_EMPTY: 5106,
  MSE_ADD_SB: 5200,
  MSE_APPEND_BUFFER: 5201,
  MSE_OTHER: 5202,
  MSE_FULL: 5203,
  MSE_HIJACK: 5204,
  MSE_CHANGE_TYPE: 5205,
  EME_HIJACK: 5301
}), _defineProperty2(_ERR_CODE, ERR.DRM, {
  LICENSE: 7100,
  CUSTOM_LICENSE: 7200
}), _defineProperty2(_ERR_CODE, ERR.OTHER, 8e3), _defineProperty2(_ERR_CODE, ERR.RUNTIME, {
  NO_CANPLAY_ERROR: 9001,
  BUFFERBREAK_ERROR: 9002,
  WAITING_TIMEOUT_ERROR: 9003
}), _ERR_CODE);
var StreamingError = /* @__PURE__ */ function(_Error) {
  _inherits2(StreamingError2, _Error);
  var _super = _createSuper2(StreamingError2);
  function StreamingError2(type, subType, origin, payload, msg) {
    var _this;
    _classCallCheck2(this, StreamingError2);
    _this = _super.call(this, msg || (origin === null || origin === void 0 ? void 0 : origin.message));
    _this.errorType = type === ERR.NETWORK_TIMEOUT ? ERR.NETWORK : type;
    _this.originError = origin;
    _this.ext = payload;
    _this.errorCode = ERR_CODE[type][subType] || ERR_CODE[type];
    _this.errorMessage = _this.message;
    if (!_this.errorCode) {
      _this.errorType = ERR.OTHER;
      _this.errorCode = ERR_CODE[_this.errorType];
    }
    return _this;
  }
  _createClass2(StreamingError2, null, [{
    key: "create",
    value: function create(type, subType, origin, payload, msg) {
      if (type instanceof StreamingError2) {
        return type;
      } else if (type instanceof Error) {
        origin = type;
        type = "";
      }
      if (!type)
        type = ERR.OTHER;
      return new StreamingError2(type, subType, origin, payload, msg);
    }
  }, {
    key: "network",
    value: function network(error) {
      var _error$response;
      return new StreamingError2(error !== null && error !== void 0 && error.isTimeout ? ERR.NETWORK_TIMEOUT : ERR.NETWORK, null, error instanceof Error ? error : null, {
        url: error === null || error === void 0 ? void 0 : error.url,
        response: error === null || error === void 0 ? void 0 : error.response,
        httpCode: error === null || error === void 0 ? void 0 : (_error$response = error.response) === null || _error$response === void 0 ? void 0 : _error$response.status
      });
    }
  }]);
  return StreamingError2;
}(/* @__PURE__ */ _wrapNativeSuper(Error));

// node_modules/xgplayer-streaming-shared/es/logger.js
var LogCacheLevel = {
  "DEBUG": 1,
  "LOG": 2,
  "WARN": 3,
  "ERROR": 4
};
var LOG_MAX_SIZE = 200 * 1024;
var SIMPLE_TYPE = ["Boolean", "Number", "String", "Undefined", "Null", "Date", "Object"];
var Logger = /* @__PURE__ */ function() {
  function Logger22(name, config) {
    _classCallCheck2(this, Logger22);
    this.name = name || "";
    this._prefix = "[".concat(this.name, "]");
    this.logCacheLevel = (config === null || config === void 0 ? void 0 : config.logCacheLevel) || 3;
    this.logMaxSize = (config === null || config === void 0 ? void 0 : config.logMaxSize) || LOG_MAX_SIZE;
    this.logSize = 0;
    this.logTextArray = [];
  }
  _createClass2(Logger22, [{
    key: "debug",
    value: function debug() {
      var _console;
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      this.logCache.apply(this, [LogCacheLevel.DEBUG].concat(args));
      if (Logger22.disabled)
        return;
      (_console = console).debug.apply(_console, ["[".concat(nowTime(), "]"), this._prefix].concat(args));
    }
  }, {
    key: "log",
    value: function log() {
      var _console2;
      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }
      this.logCache.apply(this, [LogCacheLevel.LOG].concat(args));
      if (Logger22.disabled)
        return;
      (_console2 = console).log.apply(_console2, ["[".concat(nowTime(), "]"), this._prefix].concat(args));
    }
  }, {
    key: "warn",
    value: function warn() {
      var _console3;
      for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
        args[_key3] = arguments[_key3];
      }
      this.logCache.apply(this, [LogCacheLevel.WARN].concat(args));
      if (Logger22.disabled)
        return;
      (_console3 = console).warn.apply(_console3, ["[".concat(nowTime(), "]"), this._prefix].concat(args));
    }
  }, {
    key: "error",
    value: function error() {
      var _console4;
      for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
        args[_key4] = arguments[_key4];
      }
      this.logCache.apply(this, [LogCacheLevel.ERROR].concat(args));
      if (Logger22.disabled)
        return;
      (_console4 = console).error.apply(_console4, ["[".concat(nowTime(), "]"), this._prefix].concat(args));
    }
  }, {
    key: "logCache",
    value: function logCache(logCacheLevel) {
      if (logCacheLevel < this.logCacheLevel)
        return;
      var text = "";
      try {
        for (var _len5 = arguments.length, logText = new Array(_len5 > 1 ? _len5 - 1 : 0), _key5 = 1; _key5 < _len5; _key5++) {
          logText[_key5 - 1] = arguments[_key5];
        }
        var finLogText = logText.map(function(item) {
          return logable(item);
        });
        text = "[".concat(nowTime(), "]") + this._prefix + JSON.stringify(finLogText);
      } catch (e) {
        return;
      }
      if (logCacheLevel >= this.logCacheLevel) {
        this.logSize += text.length;
        this.logTextArray.push(text);
      }
      if (this.logSize > this.logMaxSize) {
        var delLog = this.logTextArray.shift();
        this.logSize -= delLog.length;
      }
    }
  }, {
    key: "getLogCache",
    value: function getLogCache() {
      var logText = this.logTextArray.join("\n");
      this.reset();
      return logText;
    }
  }, {
    key: "reset",
    value: function reset() {
      this.logTextArray = [];
      this.logSize = 0;
    }
  }, {
    key: "table",
    value: function table() {
      var _console5;
      if (Logger22.disabled)
        return;
      console.group(this._prefix);
      (_console5 = console).table.apply(_console5, arguments);
      console.groupEnd();
    }
  }, {
    key: "setLogLevel",
    value: function setLogLevel(val) {
      this.logCacheLevel = val;
    }
  }], [{
    key: "enable",
    value: function enable() {
      Logger22.disabled = false;
    }
  }, {
    key: "disable",
    value: function disable() {
      Logger22.disabled = true;
    }
  }]);
  return Logger22;
}();
_defineProperty2(Logger, "disabled", true);
function nowTime() {
  return (/* @__PURE__ */ new Date()).toLocaleString();
}
function reduceDepth(val) {
  if (_typeof(val) !== "object") {
    return val;
  }
  var objType = Object.prototype.toString.call(val).slice(8, -1);
  switch (objType) {
    case "Array":
    case "Uint8Array":
    case "ArrayBuffer":
      return objType + "[" + val.length + "]";
    case "Object":
      return "{}";
    default:
      return objType;
  }
}
function logable(obj, maxDepth, depth) {
  if (!depth)
    depth = 1;
  if (!maxDepth)
    maxDepth = 2;
  var result = {};
  if (!obj || _typeof(obj) !== "object") {
    return obj;
  }
  var objType = Object.prototype.toString.call(obj).slice(8, -1);
  if (!SIMPLE_TYPE.includes(objType)) {
    return objType;
  }
  if (depth > maxDepth) {
    return void 0;
  }
  for (var key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) {
      if (depth === maxDepth) {
        result[key] = reduceDepth(obj[key]);
      } else if (_typeof(obj[key]) === "object") {
        result[key] = logable(obj[key], maxDepth, depth + 1);
      } else {
        result[key] = obj[key];
      }
    }
  }
  return result;
}

// node_modules/xgplayer-streaming-shared/es/utils.js
function createPublicPromise() {
  var res, rej;
  var promise = new Promise(function(resolve, reject) {
    res = resolve;
    rej = reject;
  });
  promise.used = false;
  promise.resolve = function() {
    promise.used = true;
    return res.apply(void 0, arguments);
  };
  promise.reject = function() {
    promise.used = true;
    return rej.apply(void 0, arguments);
  };
  return promise;
}
function nowTime2() {
  try {
    return parseInt(performance.now(), 10);
  } catch (e) {
    return (/* @__PURE__ */ new Date()).getTime();
  }
}
var SafeJSON = {
  stringify: function stringify(obj) {
    try {
      return JSON.stringify(obj);
    } catch (e) {
      return "";
    }
  },
  parse: function parse(obj) {
    try {
      return JSON.parse(obj);
    } catch (e) {
      return void 0;
    }
  }
};

// node_modules/xgplayer-streaming-shared/es/mse.js
function getMediaSource() {
  var preferMMS = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;
  try {
    if (!isBrowser)
      return null;
    if (preferMMS && typeof ManagedMediaSource !== "undefined")
      return ManagedMediaSource;
    return window.MediaSource;
  } catch (e) {
  }
}
function isMMS(mediaSource) {
  return /ManagedMediaSource/gi.test(Object.prototype.toString.call(mediaSource));
}
function getTimeRanges(buffered) {
  var ranges = [];
  if (buffered instanceof TimeRanges) {
    for (var i = 0; i < buffered.length; i++) {
      ranges.push({
        start: buffered.start(i),
        end: buffered.end(i)
      });
    }
  }
  return ranges;
}
var OP_NAME = {
  APPEND: "appendBuffer",
  REMOVE: "removeBuffer",
  UPDATE_DURATION: "updateDuration"
};
var MSE = /* @__PURE__ */ function() {
  function MSE2(media, config) {
    var _this2 = this;
    _classCallCheck2(this, MSE2);
    _defineProperty2(this, "media", null);
    _defineProperty2(this, "mediaSource", null);
    _defineProperty2(this, "_openPromise", createPublicPromise());
    _defineProperty2(this, "_queue", /* @__PURE__ */ Object.create(null));
    _defineProperty2(this, "_sourceBuffer", /* @__PURE__ */ Object.create(null));
    _defineProperty2(this, "_mseFullFlag", {});
    _defineProperty2(this, "_st", 0);
    _defineProperty2(this, "_opst", 0);
    _defineProperty2(this, "_logger", null);
    _defineProperty2(this, "_config", null);
    _defineProperty2(this, "_url", null);
    _defineProperty2(this, "_onStartStreaming", function() {
      _this2._logger.debug("startstreaming");
    });
    _defineProperty2(this, "_onEndStreaming", function() {
      _this2._logger.debug("endstreaming");
    });
    _defineProperty2(this, "_onSBUpdateEnd", function(type) {
      var queue = _this2._queue[type];
      if (queue) {
        var op = queue[0];
        if (!((op === null || op === void 0 ? void 0 : op.opName) === OP_NAME.UPDATE_DURATION)) {
          queue.shift();
        }
        if (op) {
          var _this2$_sourceBuffer$, _op$context;
          var costtime = nowTime2() - _this2._opst;
          _this2._logger.debug("UpdateEnd(".concat(type, "/").concat(op.opName, ")"), SafeJSON.stringify(getTimeRanges((_this2$_sourceBuffer$ = _this2._sourceBuffer[type]) === null || _this2$_sourceBuffer$ === void 0 ? void 0 : _this2$_sourceBuffer$.buffered)), costtime, op.context);
          op.promise.resolve({
            name: op.opName,
            context: op.context,
            costtime
          });
          var callback = (_op$context = op.context) === null || _op$context === void 0 ? void 0 : _op$context.callback;
          if (callback && typeof callback === "function") {
            callback(op.context);
          }
          _this2._startQueue(type);
        }
      }
    });
    _defineProperty2(this, "_onSBUpdateError", function(type, event) {
      var queue = _this2._queue[type];
      if (queue) {
        var op = queue[0];
        if (op) {
          _this2._logger.error("UpdateError", type, op.opName, op.context);
          op.promise.reject(new StreamingError(ERR.MEDIA, ERR.SUB_TYPES.MSE_APPEND_BUFFER, event));
        }
      }
    });
    this._config = Object.assign(MSE2.getDefaultConfig(), config);
    if (media)
      this.bindMedia(media);
    this._logger = new Logger("MSE");
    if (this._config.openLog) {
      Logger.enable();
    }
  }
  _createClass2(MSE2, [{
    key: "isOpened",
    get: function get() {
      var _this$mediaSource;
      return ((_this$mediaSource = this.mediaSource) === null || _this$mediaSource === void 0 ? void 0 : _this$mediaSource.readyState) === "open";
    }
  }, {
    key: "hasOpTasks",
    get: function get() {
      var _this3 = this;
      var flag = false;
      Object.keys(this._queue).forEach(function(k) {
        var queue = _this3._queue[k];
        if (Array.isArray(queue)) {
          flag || (flag = queue.length > 0);
        }
      });
      return flag;
    }
  }, {
    key: "url",
    get: function get() {
      return this._url;
    }
  }, {
    key: "duration",
    get: function get() {
      var _this$mediaSource2;
      return ((_this$mediaSource2 = this.mediaSource) === null || _this$mediaSource2 === void 0 ? void 0 : _this$mediaSource2.duration) || -1;
    }
  }, {
    key: "isEnded",
    get: function get() {
      return this.mediaSource ? this.mediaSource.readyState === "ended" : false;
    }
  }, {
    key: "streaming",
    get: function get() {
      return isMMS(this.mediaSource) ? this.mediaSource.streaming : true;
    }
  }, {
    key: "isFull",
    value: function isFull(type) {
      return type ? this._mseFullFlag[type] : this._mseFullFlag[MSE2.VIDEO];
    }
  }, {
    key: "updateDuration",
    value: function updateDuration(duration) {
      var _this4 = this;
      var isReduceDuration = this.mediaSource && this.mediaSource.duration > duration;
      if (this.mediaSource && this.mediaSource.duration > duration) {
        var bufferEnd = 0;
        Object.keys(this._sourceBuffer).forEach(function(k) {
          try {
            bufferEnd = Math.max(_this4.bufferEnd(k) || 0, bufferEnd);
          } catch (error) {
          }
        });
        if (duration < bufferEnd) {
          return Promise.resolve();
        }
      }
      return this._enqueueBlockingOp(function() {
        if (_this4.isEnded) {
          _this4._logger.debug("setDuration but ended");
          return;
        }
        if (_this4.mediaSource) {
          _this4.mediaSource.duration = duration;
          _this4._logger.debug("setDuration", duration);
        }
      }, OP_NAME.UPDATE_DURATION, {
        isReduceDuration
      });
    }
  }, {
    key: "open",
    value: function open() {
      var _this5 = this;
      if (this._openPromise.used && !this.isOpened && this.mediaSource) {
        var ms = this.mediaSource;
        var onOpen = function onOpen2() {
          var costTime = nowTime2() - _this5._st;
          _this5._logger.debug("sourceopen", costTime);
          ms.removeEventListener("sourceopen", onOpen2);
          _this5._openPromise.resolve({
            costtime: costTime
          });
        };
        ms.addEventListener("sourceopen", onOpen);
        this._openPromise = createPublicPromise();
      }
      return this._openPromise;
    }
  }, {
    key: "bindMedia",
    value: function() {
      var _bindMedia = _asyncToGenerator2(/* @__PURE__ */ _regeneratorRuntime2().mark(function _callee(media) {
        var _this6 = this;
        var MediaSource2, ms, useMMS, onOpen;
        return _regeneratorRuntime2().wrap(function _callee$(_context) {
          while (1)
            switch (_context.prev = _context.next) {
              case 0:
                if (!(this.mediaSource || this.media)) {
                  _context.next = 3;
                  break;
                }
                _context.next = 3;
                return this.unbindMedia();
              case 3:
                MediaSource2 = getMediaSource(this._config.preferMMS);
                if (!(!media || !MediaSource2)) {
                  _context.next = 6;
                  break;
                }
                throw new Error("Param media or MediaSource does not exist");
              case 6:
                this.media = media;
                ms = this.mediaSource = new MediaSource2();
                useMMS = isMMS(ms);
                this._st = nowTime2();
                onOpen = function onOpen2() {
                  var costTime = nowTime2() - _this6._st;
                  _this6._logger.debug("sourceopen");
                  ms.removeEventListener("sourceopen", onOpen2);
                  URL.revokeObjectURL(media.src);
                  _this6._openPromise.resolve({
                    costtime: costTime
                  });
                };
                ms.addEventListener("sourceopen", onOpen);
                if (useMMS) {
                  ms.addEventListener("startstreaming", this._onStartStreaming);
                  ms.addEventListener("endstreaming", this._onEndStreaming);
                }
                this._url = URL.createObjectURL(ms);
                media.src = this._url;
                media.disableRemotePlayback = useMMS;
                return _context.abrupt("return", this._openPromise);
              case 17:
              case "end":
                return _context.stop();
            }
        }, _callee, this);
      }));
      function bindMedia(_x) {
        return _bindMedia.apply(this, arguments);
      }
      return bindMedia;
    }()
  }, {
    key: "unbindMedia",
    value: function() {
      var _unbindMedia = _asyncToGenerator2(/* @__PURE__ */ _regeneratorRuntime2().mark(function _callee2() {
        var _this7 = this;
        var ms, hasMetadata, mseOpen;
        return _regeneratorRuntime2().wrap(function _callee2$(_context2) {
          while (1)
            switch (_context2.prev = _context2.next) {
              case 0:
                if (!this._openPromise.used)
                  this._openPromise.resolve();
                ms = this.mediaSource;
                if (ms) {
                  Object.keys(this._queue).forEach(function(t) {
                    var queue = _this7._queue[t];
                    if (queue) {
                      queue.forEach(function(x) {
                        var _x$promise, _x$promise$resolve;
                        return (_x$promise = x.promise) === null || _x$promise === void 0 ? void 0 : (_x$promise$resolve = _x$promise.resolve) === null || _x$promise$resolve === void 0 ? void 0 : _x$promise$resolve.call(_x$promise);
                      });
                    }
                  });
                  hasMetadata = !!this.media && this.media.readyState >= 1;
                  mseOpen = ms.readyState === "open";
                  if (hasMetadata && mseOpen) {
                    try {
                      ms.endOfStream();
                    } catch (error) {
                    }
                  }
                  Object.keys(this._sourceBuffer).forEach(function(k) {
                    try {
                      ms.removeSourceBuffer(_this7._sourceBuffer[k]);
                    } catch (error) {
                    }
                  });
                  if (isMMS(ms)) {
                    ms.removeEventListener("startstreaming", this._onStartStreaming);
                    ms.removeEventListener("endstreaming", this._onEndStreaming);
                  }
                }
                if (this.media) {
                  this.media.disableRemotePlayback = false;
                  this.media.removeAttribute("src");
                  try {
                    this.media.load();
                  } catch (error) {
                  }
                  this.media = null;
                }
                this.mediaSource = null;
                this._openPromise = createPublicPromise();
                this._queue = /* @__PURE__ */ Object.create(null);
                this._sourceBuffer = /* @__PURE__ */ Object.create(null);
              case 8:
              case "end":
                return _context2.stop();
            }
        }, _callee2, this);
      }));
      function unbindMedia() {
        return _unbindMedia.apply(this, arguments);
      }
      return unbindMedia;
    }()
  }, {
    key: "createSource",
    value: function createSource(type, mimeType) {
      if (this._sourceBuffer[type] || !this.mediaSource)
        return;
      var sb;
      try {
        sb = this._sourceBuffer[type] = this.mediaSource.addSourceBuffer(mimeType);
      } catch (error) {
        throw new StreamingError(ERR.MEDIA, ERR.SUB_TYPES.MSE_ADD_SB, error);
      }
      sb.mimeType = mimeType;
      sb.addEventListener("updateend", this._onSBUpdateEnd.bind(this, type));
      sb.addEventListener("error", this._onSBUpdateError.bind(this, type));
    }
  }, {
    key: "changeType",
    value: function changeType(type, mimeType) {
      var _this8 = this;
      var sb = this._sourceBuffer[type];
      if (!this.mediaSource || !sb || sb.mimeType === mimeType)
        return Promise.resolve();
      if (typeof sb.changeType !== "function") {
        return Promise.reject(new StreamingError(ERR.MEDIA, ERR.SUB_TYPES.MSE_CHANGE_TYPE, new Error("changeType is not a function")));
      }
      return this._enqueueOp(type, function() {
        try {
          sb.changeType(mimeType);
        } catch (e) {
          throw new StreamingError(ERR.MEDIA, ERR.SUB_TYPES.MSE_CHANGE_TYPE, e);
        }
        sb.mimeType = mimeType;
        _this8._onSBUpdateEnd(type);
      }, "changeType", {
        mimeType
      });
    }
  }, {
    key: "createOrChangeSource",
    value: function createOrChangeSource(type, mimeType) {
      this.createSource(type, mimeType);
      return this.changeType(type, mimeType);
    }
  }, {
    key: "append",
    value: function append(type, buffer, context) {
      var _this9 = this;
      if (!buffer || !buffer.byteLength) {
        return Promise.resolve();
      }
      if (!this._sourceBuffer[type])
        return Promise.resolve();
      return this._enqueueOp(type, function() {
        var _this9$_sourceBuffer$;
        if (!_this9.mediaSource || _this9.media.error)
          return;
        _this9._logger.debug("MSE APPEND START", context);
        _this9._opst = nowTime2();
        (_this9$_sourceBuffer$ = _this9._sourceBuffer[type]) === null || _this9$_sourceBuffer$ === void 0 ? void 0 : _this9$_sourceBuffer$.appendBuffer(buffer);
      }, OP_NAME.APPEND, context);
    }
  }, {
    key: "remove",
    value: function remove(type, startTime, endTime, context) {
      var _this10 = this;
      var isInsertHead = false;
      if (this._mseFullFlag[type]) {
        isInsertHead = true;
      }
      return this._enqueueOp(type, function() {
        if (!_this10.mediaSource || _this10.media.error)
          return;
        var sb = _this10._sourceBuffer[type];
        if (startTime >= endTime || !sb) {
          _this10._onSBUpdateEnd(type);
          return;
        }
        _this10._opst = nowTime2();
        _this10._logger.debug("MSE REMOVE START", type, startTime, endTime, context);
        sb.remove(startTime, endTime);
      }, OP_NAME.REMOVE, context, isInsertHead);
    }
  }, {
    key: "clearBuffer",
    value: function clearBuffer(startTime, endTime) {
      var _this11 = this;
      var p;
      Object.keys(this._sourceBuffer).forEach(function(k) {
        p = _this11.remove(k, startTime, endTime);
      });
      return p || Promise.resolve();
    }
  }, {
    key: "clearAllBuffer",
    value: function clearAllBuffer() {
      var _this12 = this;
      var p;
      Object.keys(this._sourceBuffer).forEach(function(k) {
        var sb = _this12._sourceBuffer[k];
        p = _this12.remove(k, 0, Buffer2.end(Buffer2.get(sb)));
      });
      return p;
    }
  }, {
    key: "clearOpQueues",
    value: function clearOpQueues(type, allClear) {
      var _this$_queue$type;
      this._logger.debug("MSE clearOpQueue START");
      var queue = this._queue[type];
      if (allClear && queue) {
        this._queue[type] = [];
        return;
      }
      if (!queue || !queue[type] || queue.length < 5)
        return;
      var initQueue = [];
      queue.forEach(function(op) {
        if (op.context && op.context.isinit) {
          initQueue.push(op);
        }
      });
      this._queue[type] = queue.slice(0, 2);
      initQueue.length > 0 && (_this$_queue$type = this._queue[type]).push.apply(_this$_queue$type, initQueue);
    }
  }, {
    key: "endOfStream",
    value: function endOfStream(reason) {
      var _this13 = this;
      if (!this.mediaSource || this.mediaSource.readyState !== "open")
        return Promise.resolve();
      return this._enqueueBlockingOp(function() {
        var ms = _this13.mediaSource;
        if (!ms || ms.readyState !== "open")
          return;
        _this13._logger.debug("MSE endOfStream START");
        if (reason) {
          ms.endOfStream(reason);
        } else {
          ms.endOfStream();
        }
      }, "endOfStream");
    }
  }, {
    key: "setLiveSeekableRange",
    value: function setLiveSeekableRange(start, end) {
      var ms = this.mediaSource;
      if (start < 0 || end < start || !(ms !== null && ms !== void 0 && ms.setLiveSeekableRange) || ms.readyState !== "open")
        return;
      ms.setLiveSeekableRange(start, end);
    }
  }, {
    key: "getSourceBuffer",
    value: function getSourceBuffer(type) {
      return this._sourceBuffer[type];
    }
  }, {
    key: "buffered",
    value: function buffered(type) {
      return Buffer2.get(this._sourceBuffer[type]);
    }
  }, {
    key: "bufferStart",
    value: function bufferStart(type) {
      return Buffer2.start(this.buffered(type));
    }
  }, {
    key: "bufferEnd",
    value: function bufferEnd(type) {
      return Buffer2.end(this.buffered(type));
    }
  }, {
    key: "_enqueueOp",
    value: function _enqueueOp(type, exec, opName, context, isInsertHead) {
      var _this14 = this;
      if (!this.mediaSource)
        return Promise.resolve();
      var queue = this._queue[type] = this._queue[type] || [];
      var op = {
        exec,
        promise: createPublicPromise(),
        opName,
        context
      };
      if (isInsertHead) {
        queue.splice(0, 0, op);
        this._mseFullFlag[type] = false;
        this._startQueue(type);
      } else {
        queue.push(op);
      }
      if (this.isOpened || this.isEnded) {
        if (queue.length === 1) {
          this._startQueue(type);
        }
      } else {
        this._openPromise.then(function() {
          if (queue.length === 1) {
            _this14._startQueue(type);
          }
        });
      }
      return op.promise;
    }
  }, {
    key: "_enqueueBlockingOp",
    value: function() {
      var _enqueueBlockingOp2 = _asyncToGenerator2(/* @__PURE__ */ _regeneratorRuntime2().mark(function _callee3(exec, opName, context) {
        var _this15 = this;
        var types, waiters;
        return _regeneratorRuntime2().wrap(function _callee3$(_context3) {
          while (1)
            switch (_context3.prev = _context3.next) {
              case 0:
                if (this.mediaSource) {
                  _context3.next = 2;
                  break;
                }
                return _context3.abrupt("return", Promise.resolve());
              case 2:
                types = Object.keys(this._sourceBuffer);
                if (types.length) {
                  _context3.next = 5;
                  break;
                }
                return _context3.abrupt("return", exec());
              case 5:
                waiters = [];
                types.forEach(function(t) {
                  var queue = _this15._queue[t];
                  var prom = createPublicPromise();
                  waiters.push(prom);
                  queue.push({
                    exec: function exec2() {
                      prom.resolve();
                    },
                    promise: prom,
                    opName,
                    context
                  });
                  if (queue.length === 1) {
                    _this15._startQueue(t);
                  }
                });
                return _context3.abrupt("return", Promise.all(waiters).then(function() {
                  try {
                    return exec();
                  } finally {
                    types.forEach(function(t) {
                      var queue = _this15._queue[t];
                      var sb = _this15._sourceBuffer[t];
                      queue === null || queue === void 0 ? void 0 : queue.shift();
                      if (!sb || !sb.updating) {
                        _this15._startQueue(t);
                      }
                    });
                  }
                }));
              case 8:
              case "end":
                return _context3.stop();
            }
        }, _callee3, this);
      }));
      function _enqueueBlockingOp(_x2, _x3, _x4) {
        return _enqueueBlockingOp2.apply(this, arguments);
      }
      return _enqueueBlockingOp;
    }()
  }, {
    key: "_startQueue",
    value: function _startQueue(type) {
      var queue = this._queue[type];
      if (queue) {
        var op = queue[0];
        if (op && !this._mseFullFlag[type]) {
          try {
            op.exec();
          } catch (error) {
            if (error && error.message && error.message.indexOf("SourceBuffer is full") >= 0) {
              var _op$promise;
              this._mseFullFlag[type] = true;
              if (op.context && _typeof(op.context) === "object") {
                op.context.isFull = true;
              }
              this._logger.error("[MSE error],  context,", op.context, " ,name,", op.opName, ",err,SourceBuffer is full");
              op === null || op === void 0 ? void 0 : (_op$promise = op.promise) === null || _op$promise === void 0 ? void 0 : _op$promise.reject(new StreamingError(ERR.MEDIA, ERR.SUB_TYPES.MSE_FULL, error));
            } else {
              var _op$promise2;
              this._logger.error(error);
              op === null || op === void 0 ? void 0 : (_op$promise2 = op.promise) === null || _op$promise2 === void 0 ? void 0 : _op$promise2.reject(error.constructor === StreamingError ? error : new StreamingError(ERR.MEDIA, ERR.SUB_TYPES.MSE_OTHER, error));
              queue.shift();
              this._startQueue(type);
            }
          }
        }
      }
    }
  }, {
    key: "setTimeoffset",
    value: function setTimeoffset(type, timestampOffset, context) {
      var _this16 = this;
      return this._enqueueOp(type, function() {
        if (timestampOffset < 0) {
          timestampOffset += 1e-3;
        }
        _this16._sourceBuffer[type].timestampOffset = timestampOffset;
        _this16._onSBUpdateEnd(type);
      }, "setTimeoffset", context);
    }
  }, {
    key: "abort",
    value: function abort(type, context) {
      var _this17 = this;
      if (!this.isOpened) {
        return Promise.resolve();
      }
      return this._enqueueOp(type, function() {
        _this17._sourceBuffer[type].abort();
        _this17._onSBUpdateEnd(type);
      }, "abort", context);
    }
  }], [{
    key: "isSupported",
    value: function isSupported() {
      var mime = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 'video/mp4; codecs="avc1.42E01E,mp4a.40.2"';
      var MediaSource2 = getMediaSource();
      if (!MediaSource2)
        return false;
      try {
        return MediaSource2.isTypeSupported(mime);
      } catch (error) {
        this._logger.error(mime, error);
        return false;
      }
    }
  }, {
    key: "isMMSOnly",
    value: function isMMSOnly() {
      return typeof ManagedMediaSource !== "undefined" && typeof MediaSource === "undefined";
    }
  }, {
    key: "getDefaultConfig",
    value: function getDefaultConfig() {
      return {
        openLog: false,
        preferMMS: false
      };
    }
  }]);
  return MSE2;
}();
_defineProperty2(MSE, "VIDEO", "video");
_defineProperty2(MSE, "AUDIO", "audio");

// node_modules/xgplayer-streaming-shared/es/net/types.js
var LoaderType = {
  FETCH: "fetch",
  XHR: "xhr"
};
var ResponseType = {
  ARRAY_BUFFER: "arraybuffer",
  TEXT: "text",
  JSON: "json"
};

// node_modules/xgplayer-streaming-shared/es/net/error.js
var NetError = /* @__PURE__ */ function(_Error) {
  _inherits2(NetError2, _Error);
  var _super = _createSuper2(NetError2);
  function NetError2(url, request, response, msg) {
    var _this;
    _classCallCheck2(this, NetError2);
    _this = _super.call(this, msg);
    _defineProperty2(_assertThisInitialized2(_this), "retryCount", 0);
    _defineProperty2(_assertThisInitialized2(_this), "isTimeout", false);
    _defineProperty2(_assertThisInitialized2(_this), "loaderType", LoaderType.FETCH);
    _defineProperty2(_assertThisInitialized2(_this), "startTime", 0);
    _defineProperty2(_assertThisInitialized2(_this), "endTime", 0);
    _defineProperty2(_assertThisInitialized2(_this), "options", {});
    _this.url = url;
    _this.request = request;
    _this.response = response;
    return _this;
  }
  return _createClass2(NetError2);
}(/* @__PURE__ */ _wrapNativeSuper(Error));

// node_modules/xgplayer-streaming-shared/es/is.js
var toString = Object.prototype.toString;
function isObject(a) {
  return a !== null && _typeof(a) === "object";
}
function isPlainObject(val) {
  if (toString.call(val) !== "[object Object]") {
    return false;
  }
  var prototype = Object.getPrototypeOf(val);
  return prototype === null || prototype === Object.prototype;
}
function isDate(a) {
  return toString.call(a) === "[object Date]";
}

// node_modules/xgplayer-streaming-shared/es/net/helper.js
function getRangeValue(value) {
  if (!value || value[0] === null || value[0] === void 0 || value[0] === 0 && (value[1] === null || value[1] === void 0)) {
    return;
  }
  var ret = "bytes=" + value[0] + "-";
  if (value[1])
    ret += value[1];
  return ret;
}
function encode(val) {
  return encodeURIComponent(val).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
}
function setUrlParams(url, params) {
  if (!url)
    return;
  if (!params)
    return url;
  var v;
  var str = Object.keys(params).map(function(k) {
    v = params[k];
    if (v === null || v === void 0)
      return;
    if (Array.isArray(v)) {
      k = k + "[]";
    } else {
      v = [v];
    }
    return v.map(function(x) {
      if (isDate(x)) {
        x = x.toISOString();
      } else if (isObject(x)) {
        x = JSON.stringify(x);
      }
      return "".concat(encode(k), "=").concat(encode(x));
    }).join("&");
  }).filter(Boolean).join("&");
  if (str) {
    var hashIndex = url.indexOf("#");
    if (hashIndex !== -1) {
      url = url.slice(0, hashIndex);
    }
    url += (url.indexOf("?") === -1 ? "?" : "&") + str;
  }
  return url;
}
function createResponse(data, done, response, contentLength, age, startTime, firstByteTime, index, range, vid, priOptions) {
  age = age !== null && age !== void 0 ? parseFloat(age) : null;
  contentLength = parseInt(contentLength || "0", 10);
  if (Number.isNaN(contentLength))
    contentLength = 0;
  var options = {
    range,
    vid,
    index,
    contentLength,
    age,
    startTime,
    firstByteTime,
    endTime: Date.now(),
    priOptions
  };
  return {
    data,
    done,
    options,
    response
  };
}
function calculateSpeed(byteLen, milliSecond) {
  return Math.round(byteLen * 8 * 1e3 / milliSecond / 1024);
}

// node_modules/xgplayer-streaming-shared/es/event.js
var EVENT = {
  ERROR: "error",
  TTFB: "core.ttfb",
  LOAD_START: "core.loadstart",
  LOAD_RESPONSE_HEADERS: "core.loadresponseheaders",
  LOAD_COMPLETE: "core.loadcomplete",
  LOAD_RETRY: "core.loadretry",
  SOURCEBUFFER_CREATED: "core.sourcebuffercreated",
  MEDIASOURCE_OPENED: "core.mediasourceopened",
  ANALYZE_DURATION_EXCEEDED: "core.analyzedurationexceeded",
  APPEND_BUFFER: "core.appendbuffer",
  REMOVE_BUFFER: "core.removebuffer",
  BUFFEREOS: "core.buffereos",
  KEYFRAME: "core.keyframe",
  CHASEFRAME: "core.chaseframe",
  METADATA_PARSED: "core.metadataparsed",
  SEI: "core.sei",
  SEI_IN_TIME: "core.seiintime",
  FLV_SCRIPT_DATA: "core.flvscriptdata",
  LOWDECODE: "core.lowdecode",
  SWITCH_URL_SUCCESS: "core.switchurlsuccess",
  SWITCH_URL_FAILED: "core.switchurlfailed",
  SPEED: "core.speed",
  HLS_MANIFEST_LOADED: "core.hlsmanifestloaded",
  HLS_LEVEL_LOADED: "core.hlslevelloaded",
  DEMUXED_TRACK: "core.demuxedtrack",
  STREAM_EXCEPTION: "core.streamexception",
  LARGE_AV_FIRST_FRAME_GAP_DETECT: "LARGE_AV_FIRST_FRAME_GAP_DETECT",
  LARGE_VIDEO_DTS_GAP_DETECT: "LARGE_VIDEO_DTS_GAP_DETECT",
  LARGE_AUDIO_DTS_GAP_DETECT: "LARGE_AUDIO_DTS_GAP_DETECT",
  AUDIO_GAP_DETECT: "AUDIO_GAP_DETECT",
  AUDIO_OVERLAP_DETECT: "AUDIO_OVERLAP_DETECT",
  MAX_DTS_DELTA_WITH_NEXT_SEGMENT_DETECT: "MAX_DTS_DELTA_WITH_NEXT_SEGMENT_DETECT",
  REAL_TIME_SPEED: "real_time_speed"
};

// node_modules/xgplayer-streaming-shared/es/net/fetch.js
var import_eventemitter3 = __toESM(require_eventemitter3());
var CACHESIZE = 2 * 1024 * 1024;
var FetchLoader = /* @__PURE__ */ function(_EventEmitter) {
  _inherits2(FetchLoader2, _EventEmitter);
  var _super = _createSuper2(FetchLoader2);
  function FetchLoader2() {
    var _this;
    _classCallCheck2(this, FetchLoader2);
    _this = _super.call(this);
    _defineProperty2(_assertThisInitialized2(_this), "_abortController", null);
    _defineProperty2(_assertThisInitialized2(_this), "_timeoutTimer", null);
    _defineProperty2(_assertThisInitialized2(_this), "_reader", null);
    _defineProperty2(_assertThisInitialized2(_this), "_response", null);
    _defineProperty2(_assertThisInitialized2(_this), "_aborted", false);
    _defineProperty2(_assertThisInitialized2(_this), "_index", -1);
    _defineProperty2(_assertThisInitialized2(_this), "_range", null);
    _defineProperty2(_assertThisInitialized2(_this), "_receivedLength", 0);
    _defineProperty2(_assertThisInitialized2(_this), "_running", false);
    _defineProperty2(_assertThisInitialized2(_this), "_logger", null);
    _defineProperty2(_assertThisInitialized2(_this), "_vid", "");
    _defineProperty2(_assertThisInitialized2(_this), "_onProcessMinLen", 0);
    _defineProperty2(_assertThisInitialized2(_this), "_onCancel", null);
    _defineProperty2(_assertThisInitialized2(_this), "_priOptions", null);
    return _this;
  }
  _createClass2(FetchLoader2, [{
    key: "load",
    value: function load(_ref) {
      var _this$_abortControlle, _this2 = this;
      var url = _ref.url, vid = _ref.vid, timeout = _ref.timeout, responseType = _ref.responseType, onProgress = _ref.onProgress, index = _ref.index, onTimeout = _ref.onTimeout, onCancel = _ref.onCancel, range = _ref.range, transformResponse = _ref.transformResponse, request = _ref.request, params = _ref.params, logger4 = _ref.logger, method = _ref.method, headers = _ref.headers, body = _ref.body, mode = _ref.mode, credentials = _ref.credentials, cache = _ref.cache, redirect = _ref.redirect, referrer = _ref.referrer, referrerPolicy = _ref.referrerPolicy, onProcessMinLen = _ref.onProcessMinLen, priOptions = _ref.priOptions;
      this._logger = logger4;
      this._aborted = false;
      this._onProcessMinLen = onProcessMinLen;
      this._onCancel = onCancel;
      this._abortController = typeof AbortController !== "undefined" && new AbortController();
      this._running = true;
      this._index = index;
      this._range = range || [0, 0];
      this._vid = vid || url;
      this._priOptions = priOptions || {};
      var init = {
        method,
        headers,
        body,
        mode,
        credentials,
        cache,
        redirect,
        referrer,
        referrerPolicy,
        signal: (_this$_abortControlle = this._abortController) === null || _this$_abortControlle === void 0 ? void 0 : _this$_abortControlle.signal
      };
      var isTimeout = false;
      clearTimeout(this._timeoutTimer);
      url = setUrlParams(url, params);
      var rangeValue = getRangeValue(range);
      if (rangeValue) {
        if (request) {
          headers = request.headers;
        } else {
          headers = init.headers = init.headers || (Headers ? new Headers() : {});
        }
        if (Headers && headers instanceof Headers) {
          headers.append("Range", rangeValue);
        } else {
          headers.Range = rangeValue;
        }
      }
      if (timeout) {
        this._timeoutTimer = setTimeout(function() {
          isTimeout = true;
          _this2.cancel();
          if (onTimeout) {
            var error = new NetError(url, init, null, "timeout");
            error.isTimeout = true;
            onTimeout(error, {
              index: _this2._index,
              range: _this2._range,
              vid: _this2._vid,
              priOptions: _this2._priOptions
            });
          }
        }, timeout);
      }
      var startTime = Date.now();
      this._logger.debug("[fetch load start], index,", index, ",range,", range);
      return new Promise(function(resolve, reject) {
        fetch(request || url, request ? void 0 : init).then(/* @__PURE__ */ function() {
          var _ref2 = _asyncToGenerator2(/* @__PURE__ */ _regeneratorRuntime2().mark(function _callee(response) {
            var firstByteTime, data, costTime, speed;
            return _regeneratorRuntime2().wrap(function _callee$(_context) {
              while (1)
                switch (_context.prev = _context.next) {
                  case 0:
                    clearTimeout(_this2._timeoutTimer);
                    _this2._response = response;
                    if (!(_this2._aborted || !_this2._running)) {
                      _context.next = 4;
                      break;
                    }
                    return _context.abrupt("return");
                  case 4:
                    if (transformResponse) {
                      response = transformResponse(response, url) || response;
                    }
                    if (response.ok) {
                      _context.next = 7;
                      break;
                    }
                    throw new NetError(url, init, response, "bad network response");
                  case 7:
                    firstByteTime = Date.now();
                    if (!(responseType === ResponseType.TEXT)) {
                      _context.next = 15;
                      break;
                    }
                    _context.next = 11;
                    return response.text();
                  case 11:
                    data = _context.sent;
                    _this2._running = false;
                    _context.next = 37;
                    break;
                  case 15:
                    if (!(responseType === ResponseType.JSON)) {
                      _context.next = 22;
                      break;
                    }
                    _context.next = 18;
                    return response.json();
                  case 18:
                    data = _context.sent;
                    _this2._running = false;
                    _context.next = 37;
                    break;
                  case 22:
                    if (!onProgress) {
                      _context.next = 29;
                      break;
                    }
                    _this2.resolve = resolve;
                    _this2.reject = reject;
                    _this2._loadChunk(response, onProgress, startTime, firstByteTime);
                    return _context.abrupt("return");
                  case 29:
                    _context.next = 31;
                    return response.arrayBuffer();
                  case 31:
                    data = _context.sent;
                    data = new Uint8Array(data);
                    _this2._running = false;
                    costTime = Date.now() - startTime;
                    speed = calculateSpeed(data.byteLength, costTime);
                    _this2.emit(EVENT.REAL_TIME_SPEED, {
                      speed,
                      len: data.byteLength,
                      time: costTime,
                      vid: _this2._vid,
                      index: _this2._index,
                      range: _this2._range,
                      priOptions: _this2._priOptions
                    });
                  case 37:
                    _this2._logger.debug("[fetch load end], index,", index, ",range,", range);
                    resolve(createResponse(data, true, response, response.headers.get("Content-Length"), response.headers.get("age"), startTime, firstByteTime, index, range, _this2._vid, _this2._priOptions));
                  case 39:
                  case "end":
                    return _context.stop();
                }
            }, _callee);
          }));
          return function(_x) {
            return _ref2.apply(this, arguments);
          };
        }()).catch(function(error) {
          var _error;
          clearTimeout(_this2._timeoutTimer);
          _this2._running = false;
          if (_this2._aborted && !isTimeout)
            return;
          error = error instanceof NetError ? error : new NetError(url, init, null, (_error = error) === null || _error === void 0 ? void 0 : _error.message);
          error.startTime = startTime;
          error.endTime = Date.now();
          error.isTimeout = isTimeout;
          error.options = {
            index: _this2._index,
            range: _this2._range,
            vid: _this2._vid,
            priOptions: _this2._priOptions
          };
          reject(error);
        });
      });
    }
  }, {
    key: "cancel",
    value: function() {
      var _cancel = _asyncToGenerator2(/* @__PURE__ */ _regeneratorRuntime2().mark(function _callee2() {
        return _regeneratorRuntime2().wrap(function _callee2$(_context2) {
          while (1)
            switch (_context2.prev = _context2.next) {
              case 0:
                if (!this._aborted) {
                  _context2.next = 2;
                  break;
                }
                return _context2.abrupt("return");
              case 2:
                this._aborted = true;
                this._running = false;
                if (!this._response) {
                  _context2.next = 14;
                  break;
                }
                _context2.prev = 5;
                if (!this._reader) {
                  _context2.next = 9;
                  break;
                }
                _context2.next = 9;
                return this._reader.cancel();
              case 9:
                _context2.next = 13;
                break;
              case 11:
                _context2.prev = 11;
                _context2.t0 = _context2["catch"](5);
              case 13:
                this._response = this._reader = null;
              case 14:
                if (this._abortController) {
                  try {
                    this._abortController.abort();
                  } catch (error) {
                  }
                  this._abortController = null;
                }
                if (this._onCancel) {
                  this._onCancel({
                    index: this._index,
                    range: this._range,
                    vid: this._vid,
                    priOptions: this._priOptions
                  });
                }
              case 16:
              case "end":
                return _context2.stop();
            }
        }, _callee2, this, [[5, 11]]);
      }));
      function cancel() {
        return _cancel.apply(this, arguments);
      }
      return cancel;
    }()
  }, {
    key: "_loadChunk",
    value: function _loadChunk(response, onProgress, st, firstByteTime) {
      var _this3 = this;
      if (!response.body || !response.body.getReader) {
        this._running = false;
        var err = new NetError(response.url, "", response, "onProgress of bad response.body.getReader");
        err.options = {
          index: this._index,
          range: this._range,
          vid: this._vid,
          priOptions: this._priOptions
        };
        this.reject(err);
        return;
      }
      if (this._onProcessMinLen > 0) {
        this._cache = new Uint8Array(CACHESIZE);
        this._writeIdx = 0;
      }
      var reader = this._reader = response.body.getReader();
      var data;
      var startTime;
      var endTime;
      var pump = /* @__PURE__ */ function() {
        var _ref3 = _asyncToGenerator2(/* @__PURE__ */ _regeneratorRuntime2().mark(function _callee3() {
          var _this3$_range;
          var startRange, startByte, curLen, retData, temp, costTime, speed;
          return _regeneratorRuntime2().wrap(function _callee3$(_context3) {
            while (1)
              switch (_context3.prev = _context3.next) {
                case 0:
                  startTime = Date.now();
                  _context3.prev = 1;
                  _context3.next = 4;
                  return reader.read();
                case 4:
                  data = _context3.sent;
                  endTime = Date.now();
                  _context3.next = 13;
                  break;
                case 8:
                  _context3.prev = 8;
                  _context3.t0 = _context3["catch"](1);
                  endTime = Date.now();
                  if (!_this3._aborted) {
                    _this3._running = false;
                    _context3.t0.options = {
                      index: _this3._index,
                      range: _this3._range,
                      vid: _this3._vid,
                      priOptions: _this3._priOptions
                    };
                    _this3.reject(_context3.t0);
                  }
                  return _context3.abrupt("return");
                case 13:
                  startRange = ((_this3$_range = _this3._range) === null || _this3$_range === void 0 ? void 0 : _this3$_range.length) > 0 ? _this3._range[0] : 0;
                  startByte = startRange + _this3._receivedLength;
                  if (!_this3._aborted) {
                    _context3.next = 19;
                    break;
                  }
                  _this3._running = false;
                  onProgress(void 0, false, {
                    range: [startByte, startByte],
                    vid: _this3._vid,
                    index: _this3._index,
                    startTime,
                    endTime,
                    st,
                    firstByteTime,
                    priOptions: _this3._priOptions
                  }, response);
                  return _context3.abrupt("return");
                case 19:
                  curLen = data.value ? data.value.byteLength : 0;
                  _this3._receivedLength += curLen;
                  _this3._logger.debug("\u3010fetchLoader,onProgress call\u3011,task,", _this3._range, ", start,", startByte, ", end,", startRange + _this3._receivedLength, ", done,", data.done);
                  if (_this3._onProcessMinLen > 0) {
                    if (_this3._writeIdx + curLen >= _this3._onProcessMinLen || data.done) {
                      retData = new Uint8Array(_this3._writeIdx + curLen);
                      retData.set(_this3._cache.slice(0, _this3._writeIdx), 0);
                      curLen > 0 && retData.set(data.value, _this3._writeIdx);
                      _this3._writeIdx = 0;
                      _this3._logger.debug("\u3010fetchLoader,onProgress enough\u3011,done,", data.done, ",len,", retData.byteLength, ", writeIdx,", _this3._writeIdx);
                    } else {
                      if (curLen > 0 && _this3._writeIdx + curLen < CACHESIZE) {
                        _this3._cache.set(data.value, _this3._writeIdx);
                        _this3._writeIdx += curLen;
                        _this3._logger.debug("\u3010fetchLoader,onProgress cache\u3011,len,", curLen, ", writeIdx,", _this3._writeIdx);
                      } else if (curLen > 0) {
                        temp = new Uint8Array(_this3._writeIdx + curLen + 2048);
                        _this3._logger.debug("\u3010fetchLoader,onProgress extra start\u3011,size,", _this3._writeIdx + curLen + 2048, ", datalen,", curLen, ", writeIdx,", _this3._writeIdx);
                        temp.set(_this3._cache.slice(0, _this3._writeIdx), 0);
                        curLen > 0 && temp.set(data.value, _this3._writeIdx);
                        _this3._writeIdx += curLen;
                        delete _this3._cache;
                        _this3._cache = temp;
                        _this3._logger.debug("\u3010fetchLoader,onProgress extra end\u3011,len,", curLen, ", writeIdx,", _this3._writeIdx);
                      }
                    }
                  } else {
                    retData = data.value;
                  }
                  if (retData && retData.byteLength > 0 || data.done) {
                    onProgress(retData, data.done, {
                      range: [_this3._range[0] + _this3._receivedLength - (retData ? retData.byteLength : 0), _this3._range[0] + _this3._receivedLength],
                      vid: _this3._vid,
                      index: _this3._index,
                      startTime,
                      endTime,
                      st,
                      firstByteTime,
                      priOptions: _this3._priOptions
                    }, response);
                  }
                  if (!data.done) {
                    pump();
                  } else {
                    costTime = Date.now() - st;
                    speed = calculateSpeed(_this3._receivedLength, costTime);
                    _this3.emit(EVENT.REAL_TIME_SPEED, {
                      speed,
                      len: _this3._receivedLength,
                      time: costTime,
                      vid: _this3._vid,
                      index: _this3._index,
                      range: _this3._range,
                      priOptions: _this3._priOptions
                    });
                    _this3._running = false;
                    _this3._logger.debug("[fetchLoader onProgress end],task,", _this3._range, ",done,", data.done);
                    _this3.resolve(createResponse(data, true, response, response.headers.get("Content-Length"), response.headers.get("age"), st, firstByteTime, _this3._index, _this3._range, _this3._vid, _this3._priOptions));
                  }
                case 25:
                case "end":
                  return _context3.stop();
              }
          }, _callee3, null, [[1, 8]]);
        }));
        return function pump2() {
          return _ref3.apply(this, arguments);
        };
      }();
      pump();
    }
  }, {
    key: "receiveLen",
    get: function get() {
      return this._receivedLength;
    }
  }, {
    key: "running",
    get: function get() {
      return this._running;
    },
    set: function set(status2) {
      this._running = status2;
    }
  }], [{
    key: "isSupported",
    value: function isSupported() {
      return !!(typeof fetch !== "undefined");
    }
  }]);
  return FetchLoader2;
}(import_eventemitter3.default);

// node_modules/xgplayer-streaming-shared/es/net/config.js
function getConfig(cfg) {
  return _objectSpread22({
    loaderType: LoaderType.FETCH,
    retry: 0,
    retryDelay: 0,
    timeout: 0,
    request: null,
    onTimeout: void 0,
    onProgress: void 0,
    onRetryError: void 0,
    transformRequest: void 0,
    transformResponse: void 0,
    transformError: void 0,
    responseType: ResponseType.TEXT,
    range: void 0,
    url: "",
    params: void 0,
    method: "GET",
    headers: {},
    body: void 0,
    mode: void 0,
    credentials: void 0,
    cache: void 0,
    redirect: void 0,
    referrer: void 0,
    referrerPolicy: void 0,
    integrity: void 0,
    onProcessMinLen: 0
  }, cfg);
}

// node_modules/xgplayer-streaming-shared/es/net/xhr.js
var import_eventemitter32 = __toESM(require_eventemitter3());
var XhrLoader = /* @__PURE__ */ function(_EventEmitter) {
  _inherits2(XhrLoader2, _EventEmitter);
  var _super = _createSuper2(XhrLoader2);
  function XhrLoader2() {
    var _this;
    _classCallCheck2(this, XhrLoader2);
    _this = _super.call(this);
    _defineProperty2(_assertThisInitialized2(_this), "_xhr", null);
    _defineProperty2(_assertThisInitialized2(_this), "_aborted", false);
    _defineProperty2(_assertThisInitialized2(_this), "_timeoutTimer", null);
    _defineProperty2(_assertThisInitialized2(_this), "_range", null);
    _defineProperty2(_assertThisInitialized2(_this), "_receivedLength", 0);
    _defineProperty2(_assertThisInitialized2(_this), "_url", null);
    _defineProperty2(_assertThisInitialized2(_this), "_onProgress", null);
    _defineProperty2(_assertThisInitialized2(_this), "_index", -1);
    _defineProperty2(_assertThisInitialized2(_this), "_headers", null);
    _defineProperty2(_assertThisInitialized2(_this), "_currentChunkSizeKB", 384);
    _defineProperty2(_assertThisInitialized2(_this), "_timeout", null);
    _defineProperty2(_assertThisInitialized2(_this), "_xhr", null);
    _defineProperty2(_assertThisInitialized2(_this), "_withCredentials", null);
    _defineProperty2(_assertThisInitialized2(_this), "_startTime", -1);
    _defineProperty2(_assertThisInitialized2(_this), "_loadCompleteResolve", null);
    _defineProperty2(_assertThisInitialized2(_this), "_loadCompleteReject", null);
    _defineProperty2(_assertThisInitialized2(_this), "_runing", false);
    _defineProperty2(_assertThisInitialized2(_this), "_logger", false);
    _defineProperty2(_assertThisInitialized2(_this), "_vid", "");
    _defineProperty2(_assertThisInitialized2(_this), "_responseType", void 0);
    _defineProperty2(_assertThisInitialized2(_this), "_credentials", void 0);
    _defineProperty2(_assertThisInitialized2(_this), "_method", void 0);
    _defineProperty2(_assertThisInitialized2(_this), "_transformResponse", void 0);
    _defineProperty2(_assertThisInitialized2(_this), "_firstRtt", void 0);
    _defineProperty2(_assertThisInitialized2(_this), "_onCancel", null);
    _defineProperty2(_assertThisInitialized2(_this), "_priOptions", null);
    return _this;
  }
  _createClass2(XhrLoader2, [{
    key: "load",
    value: function load(req) {
      var _this2 = this;
      clearTimeout(this._timeoutTimer);
      this._logger = req.logger;
      this._range = req.range;
      this._onProgress = req.onProgress;
      this._index = req.index;
      this._headers = req.headers;
      this._withCredentials = req.credentials === "include" || req.credentials === "same-origin";
      this._body = req.body || null;
      req.method && (this._method = req.method);
      this._timeout = req.timeout || null;
      this._runing = true;
      this._vid = req.vid || req.url;
      this._responseType = req.responseType;
      this._firstRtt = -1;
      this._onTimeout = req.onTimeout;
      this._onCancel = req.onCancel;
      this._request = req.request;
      this._priOptions = req.priOptions || {};
      this._logger.debug("\u3010xhrLoader task\u3011, range", this._range);
      this._url = setUrlParams(req.url, req.params);
      var startTime = Date.now();
      return new Promise(function(resolve, reject) {
        _this2._loadCompleteResolve = resolve;
        _this2._loadCompleteReject = reject;
        _this2._startLoad();
      }).catch(function(error) {
        clearTimeout(_this2._timeoutTimer);
        _this2._runing = false;
        if (_this2._aborted)
          return;
        error = error instanceof NetError ? error : new NetError(_this2._url, _this2._request);
        error.startTime = startTime;
        error.endTime = Date.now();
        error.options = {
          index: _this2._index,
          vid: _this2._vid,
          priOptions: _this2._priOptions
        };
        throw error;
      });
    }
  }, {
    key: "_startLoad",
    value: function _startLoad() {
      var range = null;
      if (this._responseType === ResponseType.ARRAY_BUFFER && this._range && this._range.length > 1) {
        if (this._onProgress) {
          this._firstRtt = -1;
          var chunkSize = this._currentChunkSizeKB * 1024;
          var from = this._range[0] + this._receivedLength;
          var to = this._range[1];
          if (chunkSize < this._range[1] - from) {
            to = from + chunkSize;
          }
          range = [from, to];
          this._logger.debug("[xhr_loader->],tast :", this._range, ", SubRange, ", range);
        } else {
          range = this._range;
          this._logger.debug("[xhr_loader->],tast :", this._range, ", allRange, ", range);
        }
      }
      this._internalOpen(range);
    }
  }, {
    key: "_internalOpen",
    value: function _internalOpen(range) {
      var _this3 = this;
      try {
        this._startTime = Date.now();
        var xhr = this._xhr = new XMLHttpRequest();
        xhr.open(this._method || "GET", this._url, true);
        xhr.responseType = this._responseType;
        this._timeout && (xhr.timeout = this._timeout);
        xhr.withCredentials = this._withCredentials;
        xhr.onload = this._onLoad.bind(this);
        xhr.onreadystatechange = this._onReadyStatechange.bind(this);
        xhr.onerror = function(errorEvent) {
          var _errorEvent$currentTa, _errorEvent$currentTa2, _errorEvent$currentTa3;
          _this3._running = false;
          var error = new NetError(_this3._url, _this3._request, errorEvent === null || errorEvent === void 0 ? void 0 : (_errorEvent$currentTa = errorEvent.currentTarget) === null || _errorEvent$currentTa === void 0 ? void 0 : _errorEvent$currentTa.response, "xhr.onerror.status:" + (errorEvent === null || errorEvent === void 0 ? void 0 : (_errorEvent$currentTa2 = errorEvent.currentTarget) === null || _errorEvent$currentTa2 === void 0 ? void 0 : _errorEvent$currentTa2.status) + ",statusText," + (errorEvent === null || errorEvent === void 0 ? void 0 : (_errorEvent$currentTa3 = errorEvent.currentTarget) === null || _errorEvent$currentTa3 === void 0 ? void 0 : _errorEvent$currentTa3.statusText));
          error.options = {
            index: _this3._index,
            range: _this3._range,
            vid: _this3._vid,
            priOptions: _this3._priOptions
          };
          _this3._loadCompleteReject(error);
        };
        xhr.ontimeout = function(event) {
          _this3.cancel();
          var error = new NetError(_this3._url, _this3._request, {
            status: 408
          }, "timeout");
          if (_this3._onTimeout) {
            error.isTimeout = true;
            _this3._onTimeout(error, {
              index: _this3._index,
              range: _this3._range,
              vid: _this3._vid,
              priOptions: _this3._priOptions
            });
          }
          error.options = {
            index: _this3._index,
            range: _this3._range,
            vid: _this3._vid,
            priOptions: _this3._priOptions
          };
          _this3._loadCompleteReject(error);
        };
        var headers = this._headers || {};
        var rangeValue = getRangeValue(range);
        if (rangeValue) {
          headers.Range = rangeValue;
        }
        if (headers) {
          Object.keys(headers).forEach(function(k) {
            xhr.setRequestHeader(k, headers[k]);
          });
        }
        this._logger.debug("[xhr.send->] tast,", this._range, ",load sub range, ", range);
        xhr.send(this._body);
      } catch (e) {
        e.options = {
          index: this._index,
          range,
          vid: this._vid,
          priOptions: this._priOptions
        };
        this._loadCompleteReject(e);
      }
    }
  }, {
    key: "_onReadyStatechange",
    value: function _onReadyStatechange(e) {
      var xhr = e.target;
      if (xhr.readyState === 2) {
        this._firstRtt < 0 && (this._firstRtt = Date.now());
      }
    }
  }, {
    key: "_onLoad",
    value: function _onLoad(e) {
      var _this$_range;
      var status2 = e.target.status;
      if (status2 < 200 || status2 > 299) {
        var error = new NetError(this._url, null, _objectSpread22(_objectSpread22({}, e.target.response), {}, {
          status: status2
        }), "bad response,status:" + status2);
        error.options = {
          index: this._index,
          range: this._range,
          vid: this._vid,
          priOptions: this._priOptions
        };
        return this._loadCompleteReject(error);
      }
      var data = null;
      var done = false;
      var byteStart;
      var startRange = ((_this$_range = this._range) === null || _this$_range === void 0 ? void 0 : _this$_range.length) > 0 ? this._range[0] : 0;
      if (this._responseType === ResponseType.ARRAY_BUFFER) {
        var _this$_range2;
        var chunk = new Uint8Array(e.target.response);
        byteStart = startRange + this._receivedLength;
        if (chunk && chunk.byteLength > 0) {
          this._receivedLength += chunk.byteLength;
          var costTime = Date.now() - this._startTime;
          var speed = calculateSpeed(this._receivedLength, costTime);
          this.emit(EVENT.REAL_TIME_SPEED, {
            speed,
            len: this._receivedLength,
            time: costTime,
            vid: this._vid,
            index: this._index,
            range: [byteStart, startRange + this._receivedLength],
            priOptions: this._priOptions
          });
        }
        data = chunk;
        if (((_this$_range2 = this._range) === null || _this$_range2 === void 0 ? void 0 : _this$_range2.length) > 1 && this._range[1] && this._receivedLength < this._range[1] - this._range[0]) {
          done = false;
        } else {
          done = true;
        }
        this._logger.debug("[xhr load done->], tast :", this._range, ", start", byteStart, "end ", startRange + this._receivedLength, ",dataLen,", chunk ? chunk.byteLength : 0, ",receivedLength", this._receivedLength, ",index,", this._index, ", done,", done);
      } else {
        done = true;
        data = e.target.response;
      }
      var response = {
        ok: status2 >= 200 && status2 < 300,
        status: status2,
        statusText: this._xhr.statusText,
        url: this._xhr.responseURL,
        headers: this._getHeaders(this._xhr),
        body: this._xhr.response
      };
      if (this._transformResponse) {
        response = this._transformResponse(response, this._url) || response;
      }
      if (this._onProgress) {
        this._onProgress(data, done, {
          index: this._index,
          vid: this._vid,
          range: [byteStart, startRange + this._receivedLength],
          startTime: this._startTime,
          endTime: Date.now(),
          priOptions: this._priOptions
        }, response);
      }
      if (!done) {
        this._startLoad();
      } else {
        this._runing = false;
        this._loadCompleteResolve && this._loadCompleteResolve(createResponse(this._onProgress ? null : data, done, response, response.headers["content-length"], response.headers.age, this._startTime, this._firstRtt, this._index, this._range, this._vid, this._priOptions));
      }
    }
  }, {
    key: "cancel",
    value: function cancel() {
      if (this._aborted)
        return;
      this._aborted = true;
      this._runing = false;
      _get(_getPrototypeOf2(XhrLoader2.prototype), "removeAllListeners", this).call(this);
      if (this._onCancel) {
        this._onCancel({
          index: this._index,
          range: this._range,
          vid: this._vid,
          priOptions: this._priOptions
        });
      }
      if (this._xhr) {
        return this._xhr.abort();
      }
    }
  }, {
    key: "receiveLen",
    get: function get() {
      return this._receivedLength;
    }
  }, {
    key: "running",
    get: function get() {
      return this._running;
    },
    set: function set(status2) {
      this._running = status2;
    }
  }, {
    key: "_getHeaders",
    value: function _getHeaders(xhr) {
      var headerLines = xhr.getAllResponseHeaders().trim().split("\r\n");
      var headers = {};
      var _iterator = _createForOfIteratorHelper(headerLines), _step;
      try {
        for (_iterator.s(); !(_step = _iterator.n()).done; ) {
          var header = _step.value;
          var parts = header.split(": ");
          headers[parts[0].toLowerCase()] = parts.slice(1).join(": ");
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
      return headers;
    }
  }], [{
    key: "isSupported",
    value: function isSupported() {
      return typeof XMLHttpRequest !== "undefined";
    }
  }]);
  return XhrLoader2;
}(import_eventemitter32.default);

// node_modules/xgplayer-streaming-shared/es/net/task.js
var _excluded = ["retry", "retryDelay", "onRetryError", "transformError"];
var Task = /* @__PURE__ */ function() {
  function Task2(type, config) {
    _classCallCheck2(this, Task2);
    this.promise = createPublicPromise();
    this.alive = !!config.onProgress;
    !config.logger && (config.logger = new Logger("Loader"));
    this._loaderType = type;
    this._loader = type === LoaderType.FETCH && typeof fetch !== "undefined" ? new FetchLoader() : new XhrLoader();
    this._config = config;
    this._retryCount = 0;
    this._retryTimer = null;
    this._canceled = false;
    this._retryCheckFunc = config.retryCheckFunc;
    this._logger = config.logger;
  }
  _createClass2(Task2, [{
    key: "exec",
    value: function exec() {
      var _this = this;
      var _this$_config = this._config, retry = _this$_config.retry, retryDelay = _this$_config.retryDelay, onRetryError = _this$_config.onRetryError, transformError = _this$_config.transformError, rest = _objectWithoutProperties(_this$_config, _excluded);
      var request = /* @__PURE__ */ function() {
        var _ref = _asyncToGenerator2(/* @__PURE__ */ _regeneratorRuntime2().mark(function _callee() {
          var response, error, isRetry;
          return _regeneratorRuntime2().wrap(function _callee$(_context) {
            while (1)
              switch (_context.prev = _context.next) {
                case 0:
                  _context.prev = 0;
                  _context.next = 3;
                  return _this._loader.load(rest);
                case 3:
                  response = _context.sent;
                  _this.promise.resolve(response);
                  _context.next = 27;
                  break;
                case 7:
                  _context.prev = 7;
                  _context.t0 = _context["catch"](0);
                  _this._loader.running = false;
                  _this._logger.debug("[task request catch err]", _context.t0);
                  if (!_this._canceled) {
                    _context.next = 13;
                    break;
                  }
                  return _context.abrupt("return");
                case 13:
                  _context.t0.loaderType = _this._loaderType;
                  _context.t0.retryCount = _this._retryCount;
                  error = _context.t0;
                  if (transformError) {
                    error = transformError(error) || error;
                  }
                  if (onRetryError && _this._retryCount > 0)
                    onRetryError(error, _this._retryCount, {
                      index: rest.index,
                      vid: rest.vid,
                      range: rest.range,
                      priOptions: rest.priOptions
                    });
                  _this._retryCount++;
                  isRetry = true;
                  if (_this._retryCheckFunc) {
                    isRetry = _this._retryCheckFunc(_context.t0);
                  }
                  if (!(isRetry && _this._retryCount <= retry)) {
                    _context.next = 26;
                    break;
                  }
                  clearTimeout(_this._retryTimer);
                  _this._logger.debug("[task request setTimeout],retry", _this._retryCount, ",retry range,", rest.range);
                  _this._retryTimer = setTimeout(request, retryDelay);
                  return _context.abrupt("return");
                case 26:
                  _this.promise.reject(error);
                case 27:
                case "end":
                  return _context.stop();
              }
          }, _callee, null, [[0, 7]]);
        }));
        return function request2() {
          return _ref.apply(this, arguments);
        };
      }();
      request();
      return this.promise;
    }
  }, {
    key: "cancel",
    value: function() {
      var _cancel = _asyncToGenerator2(/* @__PURE__ */ _regeneratorRuntime2().mark(function _callee2() {
        return _regeneratorRuntime2().wrap(function _callee2$(_context2) {
          while (1)
            switch (_context2.prev = _context2.next) {
              case 0:
                clearTimeout(this._retryTimer);
                this._canceled = true;
                this._loader.running = false;
                return _context2.abrupt("return", this._loader.cancel());
              case 4:
              case "end":
                return _context2.stop();
            }
        }, _callee2, this);
      }));
      function cancel() {
        return _cancel.apply(this, arguments);
      }
      return cancel;
    }()
  }, {
    key: "running",
    get: function get() {
      return this._loader && this._loader.running;
    }
  }, {
    key: "loader",
    get: function get() {
      return this._loader;
    }
  }]);
  return Task2;
}();

// node_modules/xgplayer-streaming-shared/es/streaming-helper.js
function isMediaPlaying(media) {
  return media && !media.paused && !media.ended && media.playbackRate !== 0 && media.readyState !== 0;
}
function getVideoPlaybackQuality(video) {
  if (!video)
    return {};
  if (typeof video.getVideoPlaybackQuality === "function") {
    var info = video.getVideoPlaybackQuality();
    return {
      droppedVideoFrames: info.droppedVideoFrames || info.corruptedVideoFrames,
      totalVideoFrames: info.totalVideoFrames,
      creationTime: info.creationTime
    };
  }
  return {
    droppedVideoFrames: video.webkitDroppedFrameCount,
    totalVideoFrames: video.webkitDecodedFrameCount,
    creationTime: performance.now()
  };
}
function concatUint8Array() {
  for (var _len = arguments.length, arr = new Array(_len), _key = 0; _key < _len; _key++) {
    arr[_key] = arguments[_key];
  }
  arr = arr.filter(Boolean);
  if (arr.length < 2)
    return arr[0];
  var data = new Uint8Array(arr.reduce(function(p, c) {
    return p + c.byteLength;
  }, 0));
  var prevLen = 0;
  arr.forEach(function(d) {
    data.set(d, prevLen);
    prevLen += d.byteLength;
  });
  return data;
}
function sleep() {
  var t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
  return new Promise(function(resolve) {
    return setTimeout(resolve, t);
  });
}

// node_modules/xgplayer-streaming-shared/es/net/index.js
var import_eventemitter33 = __toESM(require_eventemitter3());
var NetLoader = /* @__PURE__ */ function(_EventEmitter) {
  _inherits2(NetLoader2, _EventEmitter);
  var _super = _createSuper2(NetLoader2);
  function NetLoader2(cfg) {
    var _this;
    _classCallCheck2(this, NetLoader2);
    _this = _super.call(this, cfg);
    _defineProperty2(_assertThisInitialized2(_this), "type", LoaderType.FETCH);
    _defineProperty2(_assertThisInitialized2(_this), "_queue", []);
    _defineProperty2(_assertThisInitialized2(_this), "_alive", []);
    _defineProperty2(_assertThisInitialized2(_this), "_currentTask", null);
    _defineProperty2(_assertThisInitialized2(_this), "_finnalUrl", "");
    _defineProperty2(_assertThisInitialized2(_this), "_config", void 0);
    _this._config = getConfig(cfg);
    if (_this._config.loaderType === LoaderType.XHR || !FetchLoader.isSupported()) {
      _this.type = LoaderType.XHR;
    }
    _this.log = cfg.logger;
    return _this;
  }
  _createClass2(NetLoader2, [{
    key: "isFetch",
    value: function isFetch() {
      return this.type === LoaderType.FETCH;
    }
  }, {
    key: "load",
    value: function load(url) {
      var _this2 = this;
      var config = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      if (typeof url === "string" || !url) {
        config.url = url || config.url || this._config.url;
      } else {
        config = url;
      }
      config = Object.assign({}, this._config, config);
      if (config.params)
        config.params = Object.assign({}, config.params);
      if (config.headers && isPlainObject(config.headers))
        config.headers = Object.assign({}, config.headers);
      if (config.body && isPlainObject(config.body))
        config.body = Object.assign({}, config.body);
      if (config.transformRequest) {
        config = config.transformRequest(config) || config;
      }
      config.logger = this.log;
      var task = new Task(this.type, config);
      task.loader.on(EVENT.REAL_TIME_SPEED, function(data) {
        _this2.emit(EVENT.REAL_TIME_SPEED, data);
      });
      this._queue.push(task);
      if (this._queue.length === 1 && (!this._currentTask || !this._currentTask.running)) {
        this._processTask();
      }
      return task.promise;
    }
  }, {
    key: "cancel",
    value: function() {
      var _cancel = _asyncToGenerator2(/* @__PURE__ */ _regeneratorRuntime2().mark(function _callee() {
        var cancels;
        return _regeneratorRuntime2().wrap(function _callee$(_context) {
          while (1)
            switch (_context.prev = _context.next) {
              case 0:
                cancels = this._queue.map(function(t) {
                  return t.cancel();
                }).concat(this._alive.map(function(t) {
                  return t.cancel();
                }));
                if (this._currentTask) {
                  cancels.push(this._currentTask.cancel());
                }
                this._queue = [];
                this._alive = [];
                _context.next = 6;
                return Promise.all(cancels);
              case 6:
                _context.next = 8;
                return sleep();
              case 8:
              case "end":
                return _context.stop();
            }
        }, _callee, this);
      }));
      function cancel() {
        return _cancel.apply(this, arguments);
      }
      return cancel;
    }()
  }, {
    key: "_processTask",
    value: function _processTask() {
      var _this3 = this;
      this._currentTask = this._queue.shift();
      if (!this._currentTask)
        return;
      if (this._currentTask.alive) {
        this._alive.push(this._currentTask);
      }
      var req = this._currentTask.exec().catch(function(e) {
      });
      if (!(req && typeof req.finally === "function"))
        return;
      req.finally(function() {
        var _this3$_currentTask, _this3$_alive;
        if ((_this3$_currentTask = _this3._currentTask) !== null && _this3$_currentTask !== void 0 && _this3$_currentTask.alive && ((_this3$_alive = _this3._alive) === null || _this3$_alive === void 0 ? void 0 : _this3$_alive.length) > 0) {
          _this3._alive = _this3._alive.filter(function(task) {
            return task && task !== _this3._currentTask;
          });
        }
        _this3._processTask();
      });
    }
  }], [{
    key: "isFetchSupport",
    value: function isFetchSupport() {
      return FetchLoader.isSupported();
    }
  }]);
  return NetLoader2;
}(import_eventemitter33.default);

// node_modules/xgplayer-streaming-shared/es/services/gap.js
var GapService = /* @__PURE__ */ function() {
  function GapService2() {
    _classCallCheck2(this, GapService2);
    _defineProperty2(this, "_prevCurrentTime", 0);
  }
  _createClass2(GapService2, [{
    key: "do",
    value: function _do(media) {
      var maxJumpDistance = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 3;
      var isLive = arguments.length > 2 ? arguments[2] : void 0;
      var seekThreshold = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 1;
      if (!media)
        return;
      var currentTime = media.currentTime;
      var jumpTo = 0;
      if (this._prevCurrentTime === currentTime) {
        var info = Buffer2.info(Buffer2.get(media), currentTime);
        if (!info.buffers.length)
          return;
        if (isLive && info.nextStart || info.nextStart && info.nextStart - currentTime < maxJumpDistance) {
          jumpTo = info.nextStart + 0.1;
        } else if (info.end && info.end - currentTime > seekThreshold && !media.seeking) {
          jumpTo = currentTime + 0.1;
        }
      }
      this._prevCurrentTime = currentTime;
      if (jumpTo && currentTime !== jumpTo) {
        media.currentTime = jumpTo;
      }
    }
  }]);
  return GapService2;
}();

// node_modules/xgplayer-streaming-shared/es/services/sei.js
var SeiService = /* @__PURE__ */ function() {
  function SeiService2(emitter) {
    var _this = this;
    _classCallCheck2(this, SeiService2);
    _defineProperty2(this, "_seiSet", /* @__PURE__ */ new Set());
    this.emitter = emitter;
    emitter.on(EVENT.SEI, function(sei) {
      if (sei)
        _this._seiSet.add(sei);
    });
  }
  _createClass2(SeiService2, [{
    key: "throw",
    value: function _throw(currentTime, isLive) {
      var _this2 = this;
      if (currentTime === null || currentTime === void 0 || !this._seiSet.size)
        return;
      var min = currentTime - 0.2;
      var max = currentTime + 0.2;
      var toThrow = [];
      this._seiSet.forEach(function(sei) {
        if (sei.time >= min && sei.time <= max) {
          toThrow.push(sei);
        }
      });
      toThrow.forEach(function(sei) {
        _this2._seiSet.delete(sei);
        _this2.emitter.emit(EVENT.SEI_IN_TIME, sei);
      });
      if (!isLive)
        return;
      this._seiSet.forEach(function(s) {
        if (s.time < currentTime - 5) {
          _this2._seiSet.delete(s);
        }
      });
    }
  }, {
    key: "reset",
    value: function reset() {
      this._seiSet.clear();
    }
  }]);
  return SeiService2;
}();

// node_modules/xgplayer-streaming-shared/es/services/bandwidth.js
var SKIP_SMALL_CHUNK = 1e3;
var MAX_CHUNK_SAVE_SIZE = 50;
var MAX_SEGMENT_SAVE_SIZE = 3;
var LONGTIME_NO_RECEIVE = 3e3;
var BandwidthService = /* @__PURE__ */ function() {
  function BandwidthService2(opts) {
    _classCallCheck2(this, BandwidthService2);
    _defineProperty2(this, "_chunkSpeed", 0);
    _defineProperty2(this, "_chunkCache", []);
    _defineProperty2(this, "_speeds", []);
    _defineProperty2(this, "_totalSize", 0);
    _defineProperty2(this, "_totalCost", 0);
    this._opts = opts || {};
  }
  _createClass2(BandwidthService2, [{
    key: "addRecord",
    value: function addRecord(totalByte, ms) {
      if (!totalByte || !ms)
        return;
      this._speeds.push(8e3 * totalByte / ms);
      this._speeds = this._speeds.slice(-MAX_SEGMENT_SAVE_SIZE);
    }
  }, {
    key: "addChunkRecord",
    value: function addChunkRecord(totalByte, ms) {
      var _this$_opts, _this$_opts2;
      if (!totalByte || !ms || totalByte < (((_this$_opts = this._opts) === null || _this$_opts === void 0 ? void 0 : _this$_opts.skipChunkSize) || SKIP_SMALL_CHUNK))
        return;
      this._totalSize += totalByte;
      this._totalCost += ms;
      this._chunkSpeed = 8e3 * totalByte / ms;
      this._chunkCache.push({
        size: totalByte,
        duration: ms,
        timestamp: performance.now()
      });
      var size = ((_this$_opts2 = this._opts) === null || _this$_opts2 === void 0 ? void 0 : _this$_opts2.chunkCountForSpeed) || MAX_CHUNK_SAVE_SIZE;
      if (this._chunkCache.length > size) {
        this._chunkCache = this._chunkCache.slice(-size);
      }
    }
  }, {
    key: "getAvgSpeed",
    value: function getAvgSpeed() {
      var _this$_opts3;
      if (!this._chunkCache.length && !this._speeds.length)
        return 0;
      if (this._speeds.length) {
        return this._speeds.reduce(function(a, c) {
          return a += c;
        }) / this._speeds.length;
      }
      var lastSample = this._chunkCache[this._chunkCache.length - 1];
      var cost = performance.now() - lastSample.timestamp;
      if (cost > (((_this$_opts3 = this._opts) === null || _this$_opts3 === void 0 ? void 0 : _this$_opts3.longtimeNoReceived) || LONGTIME_NO_RECEIVE)) {
        this._chunkCache.push({
          size: 0,
          duration: cost,
          timestamp: performance.now()
        });
      }
      var totalSize = this._chunkCache.reduce(function(a, c) {
        return a += c.size;
      }, 0);
      var totalDuration = this._chunkCache.reduce(function(a, c) {
        return a += c.duration;
      }, 0);
      return 8e3 * totalSize / totalDuration;
    }
  }, {
    key: "getLatestSpeed",
    value: function getLatestSpeed() {
      if (!this._chunkCache.length && !this._speeds.length)
        return 0;
      if (this._speeds.length) {
        return this._speeds[this._speeds.length - 1];
      }
      return this._chunkSpeed;
    }
  }, {
    key: "getTotalSize",
    value: function getTotalSize() {
      return this._totalSize;
    }
  }, {
    key: "getTotalCost",
    value: function getTotalCost() {
      return this._totalCost;
    }
  }, {
    key: "reset",
    value: function reset() {
      this._chunkCache = [];
      this._speeds = [];
      this._totalSize = 0;
      this._totalCost = 0;
    }
  }]);
  return BandwidthService2;
}();

// node_modules/xgplayer-streaming-shared/es/services/stats.js
var import_eventemitter34 = __toESM(require_eventemitter3());
var Stats = /* @__PURE__ */ function() {
  function Stats2(timescale) {
    _classCallCheck2(this, Stats2);
    _defineProperty2(this, "encodeType", "");
    _defineProperty2(this, "audioCodec", "");
    _defineProperty2(this, "videoCodec", "");
    _defineProperty2(this, "domain", "");
    _defineProperty2(this, "fps", 0);
    _defineProperty2(this, "bitrate", 0);
    _defineProperty2(this, "width", 0);
    _defineProperty2(this, "height", 0);
    _defineProperty2(this, "samplerate", 0);
    _defineProperty2(this, "channelCount", 0);
    _defineProperty2(this, "gop", 0);
    _defineProperty2(this, "_bitsAccumulateSize", 0);
    _defineProperty2(this, "_bitsAccumulateDuration", 0);
    _defineProperty2(this, "_startGopId", -1);
    this._timescale = timescale;
  }
  _createClass2(Stats2, [{
    key: "getStats",
    value: function getStats() {
      return {
        encodeType: this.encodeType,
        audioCodec: this.audioCodec,
        videoCodec: this.videoCodec,
        domain: this.domain,
        fps: this.fps,
        bitrate: this.bitrate,
        width: this.width,
        height: this.height,
        samplerate: this.samplerate,
        channelCount: this.channelCount,
        gop: this.gop
      };
    }
  }, {
    key: "setEncodeType",
    value: function setEncodeType(encode2) {
      this.encodeType = encode2;
    }
  }, {
    key: "setFpsFromScriptData",
    value: function setFpsFromScriptData(_ref) {
      var _data$onMetaData;
      var data = _ref.data;
      var fps = data === null || data === void 0 ? void 0 : (_data$onMetaData = data.onMetaData) === null || _data$onMetaData === void 0 ? void 0 : _data$onMetaData.framerate;
      if (fps && fps > 0 && fps < 100) {
        this.fps = fps;
      }
    }
  }, {
    key: "setVideoMeta",
    value: function setVideoMeta(track) {
      this.width = track.width;
      this.height = track.height;
      this.videoCodec = track.codec;
      this.encodeType = track.codecType;
      if (track.fpsNum && track.fpsDen) {
        var fps = track.fpsNum / track.fpsDen;
        if (fps > 0 && fps < 100) {
          this.fps = fps;
        }
      }
    }
  }, {
    key: "setAudioMeta",
    value: function setAudioMeta(track) {
      this.audioCodec = track.codec;
      this.samplerate = track.sampleRate;
      this.channelCount = track.channelCount;
    }
  }, {
    key: "setDomain",
    value: function setDomain(responseUrl) {
      this.domain = responseUrl.split("/").slice(2, 3)[0];
    }
  }, {
    key: "updateBitrate",
    value: function updateBitrate(samples) {
      var _this = this;
      if (!this.fps || this.fps >= 100) {
        if (samples.length) {
          var duration = samples.reduce(function(a, b) {
            return a += b.duration;
          }, 0) / samples.length;
          this.fps = Math.round(this._timescale / duration);
        }
      }
      samples.forEach(function(sample) {
        if (_this._startGopId === -1) {
          _this._startGopId = sample.gopId;
        }
        if (sample.gopId === _this._startGopId) {
          _this.gop++;
        }
        _this._bitsAccumulateDuration += sample.duration / (_this._timescale / 1e3);
        _this._bitsAccumulateSize += sample.units.reduce(function(a, c) {
          return a += c.length;
        }, 0);
        if (_this._bitsAccumulateDuration >= 1e3) {
          _this.bitrate = _this._bitsAccumulateSize * 8;
          _this._bitsAccumulateDuration = 0;
          _this._bitsAccumulateSize = 0;
        }
      });
    }
  }]);
  return Stats2;
}();
var MediaStatsService = /* @__PURE__ */ function() {
  function MediaStatsService2(core) {
    var timescale = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1e3;
    _classCallCheck2(this, MediaStatsService2);
    _defineProperty2(this, "_core", null);
    _defineProperty2(this, "_samples", []);
    this._core = core;
    this._timescale = timescale;
    this._stats = new Stats(timescale);
    this._bindEvents();
  }
  _createClass2(MediaStatsService2, [{
    key: "getStats",
    value: function getStats() {
      var _this$_core, _this$_core2, _this$_core2$speedInf, _this$_core3, _this$_core3$speedInf, _this$_core4, _this$_core4$speedInf, _this$_core5, _this$_core5$speedInf, _this$_core6, _this$_core6$bufferIn;
      var _ref2 = ((_this$_core = this._core) === null || _this$_core === void 0 ? void 0 : _this$_core.media) || {}, _ref2$currentTime = _ref2.currentTime, currentTime = _ref2$currentTime === void 0 ? 0 : _ref2$currentTime, _ref2$decodeFps = _ref2.decodeFps, decodeFps = _ref2$decodeFps === void 0 ? 0 : _ref2$decodeFps;
      return _objectSpread22(_objectSpread22({}, this._stats.getStats()), {}, {
        downloadSpeed: ((_this$_core2 = this._core) === null || _this$_core2 === void 0 ? void 0 : (_this$_core2$speedInf = _this$_core2.speedInfo) === null || _this$_core2$speedInf === void 0 ? void 0 : _this$_core2$speedInf.call(_this$_core2).speed) || 0,
        avgSpeed: ((_this$_core3 = this._core) === null || _this$_core3 === void 0 ? void 0 : (_this$_core3$speedInf = _this$_core3.speedInfo) === null || _this$_core3$speedInf === void 0 ? void 0 : _this$_core3$speedInf.call(_this$_core3).avgSpeed) || 0,
        totalReceivedByte: ((_this$_core4 = this._core) === null || _this$_core4 === void 0 ? void 0 : (_this$_core4$speedInf = _this$_core4.speedInfo) === null || _this$_core4$speedInf === void 0 ? void 0 : _this$_core4$speedInf.call(_this$_core4).totalSize) || 0,
        totalReceivedCost: ((_this$_core5 = this._core) === null || _this$_core5 === void 0 ? void 0 : (_this$_core5$speedInf = _this$_core5.speedInfo) === null || _this$_core5$speedInf === void 0 ? void 0 : _this$_core5$speedInf.call(_this$_core5).totalCost) || 0,
        currentTime,
        bufferEnd: ((_this$_core6 = this._core) === null || _this$_core6 === void 0 ? void 0 : (_this$_core6$bufferIn = _this$_core6.bufferInfo()) === null || _this$_core6$bufferIn === void 0 ? void 0 : _this$_core6$bufferIn.remaining) || 0,
        decodeFps
      });
    }
  }, {
    key: "_bindEvents",
    value: function _bindEvents() {
      var _this2 = this;
      this._core.on(EVENT.DEMUXED_TRACK, function(_ref3) {
        var videoTrack = _ref3.videoTrack;
        return _this2._stats.updateBitrate(videoTrack.samples);
      });
      this._core.on(EVENT.FLV_SCRIPT_DATA, function(data) {
        _this2._stats.setFpsFromScriptData(data);
      });
      this._core.on(EVENT.METADATA_PARSED, function(e) {
        if (e.type === "video") {
          _this2._stats.setVideoMeta(e.track);
        } else {
          _this2._stats.setAudioMeta(e.track);
        }
      });
      this._core.on(EVENT.TTFB, function(e) {
        _this2._stats.setDomain(e.responseUrl);
      });
    }
  }, {
    key: "reset",
    value: function reset() {
      this._samples = [];
      this._stats = new Stats(this._timescale);
    }
  }]);
  return MediaStatsService2;
}();

// node_modules/xgplayer-flv/es/flv/index.js
var import_eventemitter35 = __toESM(require_eventemitter3());

// node_modules/xgplayer-transmuxer/es/_virtual/_rollupPluginBabelHelpers.js
function _iterableToArrayLimit(arr, i) {
  var _i = null == arr ? null : "undefined" != typeof Symbol && arr[Symbol.iterator] || arr["@@iterator"];
  if (null != _i) {
    var _s, _e, _x, _r, _arr = [], _n = true, _d = false;
    try {
      if (_x = (_i = _i.call(arr)).next, 0 === i) {
        if (Object(_i) !== _i)
          return;
        _n = false;
      } else
        for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = true)
          ;
    } catch (err) {
      _d = true, _e = err;
    } finally {
      try {
        if (!_n && null != _i.return && (_r = _i.return(), Object(_r) !== _r))
          return;
      } finally {
        if (_d)
          throw _e;
      }
    }
    return _arr;
  }
}
function _classCallCheck3(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties3(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, _toPropertyKey3(descriptor.key), descriptor);
  }
}
function _createClass3(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties3(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties3(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", {
    writable: false
  });
  return Constructor;
}
function _defineProperty3(obj, key, value) {
  key = _toPropertyKey3(key);
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _inherits3(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  Object.defineProperty(subClass, "prototype", {
    writable: false
  });
  if (superClass)
    _setPrototypeOf3(subClass, superClass);
}
function _getPrototypeOf3(o) {
  _getPrototypeOf3 = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf22(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf3(o);
}
function _setPrototypeOf3(o, p) {
  _setPrototypeOf3 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf22(o2, p2) {
    o2.__proto__ = p2;
    return o2;
  };
  return _setPrototypeOf3(o, p);
}
function _isNativeReflectConstruct3() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}
function _assertThisInitialized3(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _possibleConstructorReturn3(self2, call) {
  if (call && (typeof call === "object" || typeof call === "function")) {
    return call;
  } else if (call !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }
  return _assertThisInitialized3(self2);
}
function _createSuper3(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct3();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf3(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf3(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn3(this, result);
  };
}
function _slicedToArray(arr, i) {
  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray2(arr, i) || _nonIterableRest();
}
function _toConsumableArray(arr) {
  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray2(arr) || _nonIterableSpread();
}
function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr))
    return _arrayLikeToArray2(arr);
}
function _arrayWithHoles(arr) {
  if (Array.isArray(arr))
    return arr;
}
function _iterableToArray(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
    return Array.from(iter);
}
function _unsupportedIterableToArray2(o, minLen) {
  if (!o)
    return;
  if (typeof o === "string")
    return _arrayLikeToArray2(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor)
    n = o.constructor.name;
  if (n === "Map" || n === "Set")
    return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
    return _arrayLikeToArray2(o, minLen);
}
function _arrayLikeToArray2(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++)
    arr2[i] = arr[i];
  return arr2;
}
function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _toPrimitive3(input, hint) {
  if (typeof input !== "object" || input === null)
    return input;
  var prim = input[Symbol.toPrimitive];
  if (prim !== void 0) {
    var res = prim.call(input, hint || "default");
    if (typeof res !== "object")
      return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input);
}
function _toPropertyKey3(arg) {
  var key = _toPrimitive3(arg, "string");
  return typeof key === "symbol" ? key : String(key);
}

// node_modules/xgplayer-transmuxer/es/model/types.js
var TrackType = {
  VIDEO: "video",
  AUDIO: "audio",
  METADATA: "metadata"
};
var VideoCodecType = {
  AV1: "av1",
  AVC: "avc",
  HEVC: "hevc"
};
var AudioCodecType = {
  AAC: "aac",
  G711PCMA: "g7110a",
  G711PCMU: "g7110m",
  OPUS: "opus",
  MP3: "mp3"
};
var WarningType = {
  LARGE_AV_SHIFT: "LARGE_AV_SHIFT",
  LARGE_VIDEO_GAP: "LARGE_VIDEO_GAP",
  LARGE_VIDEO_GAP_BETWEEN_CHUNK: "LARGE_VIDEO_GAP_BETWEEN_CHUNK",
  LARGE_AUDIO_GAP: "LARGE_AUDIO_GAP",
  AUDIO_FILLED: "AUDIO_FILLED",
  AUDIO_DROPPED: "AUDIO_DROPPED"
};

// node_modules/xgplayer-transmuxer/es/model/video-track.js
var VideoTrack = /* @__PURE__ */ function() {
  function VideoTrack2() {
    _classCallCheck3(this, VideoTrack2);
    _defineProperty3(this, "id", 1);
    _defineProperty3(this, "type", TrackType.VIDEO);
    _defineProperty3(this, "codecType", VideoCodecType.AVC);
    _defineProperty3(this, "pid", -1);
    _defineProperty3(this, "hvcC", void 0);
    _defineProperty3(this, "codec", "");
    _defineProperty3(this, "timescale", 0);
    _defineProperty3(this, "formatTimescale", 0);
    _defineProperty3(this, "sequenceNumber", 0);
    _defineProperty3(this, "baseMediaDecodeTime", 0);
    _defineProperty3(this, "baseDts", 0);
    _defineProperty3(this, "duration", 0);
    _defineProperty3(this, "warnings", []);
    _defineProperty3(this, "samples", []);
    _defineProperty3(this, "pps", []);
    _defineProperty3(this, "sps", []);
    _defineProperty3(this, "vps", []);
    _defineProperty3(this, "fpsNum", 0);
    _defineProperty3(this, "fpsDen", 0);
    _defineProperty3(this, "sarRatio", []);
    _defineProperty3(this, "width", 0);
    _defineProperty3(this, "height", 0);
    _defineProperty3(this, "nalUnitSize", 4);
    _defineProperty3(this, "present", false);
    _defineProperty3(this, "isVideoEncryption", false);
    _defineProperty3(this, "isAudioEncryption", false);
    _defineProperty3(this, "isVideo", true);
    _defineProperty3(this, "lastKeyFrameDts", 0);
    _defineProperty3(this, "kid", null);
    _defineProperty3(this, "pssh", null);
    _defineProperty3(this, "ext", void 0);
  }
  _createClass3(VideoTrack2, [{
    key: "reset",
    value: function reset() {
      this.sequenceNumber = this.width = this.height = this.fpsDen = this.fpsNum = this.duration = this.baseMediaDecodeTime = this.timescale = 0;
      this.codec = "";
      this.present = false;
      this.pid = -1;
      this.pps = [];
      this.sps = [];
      this.vps = [];
      this.sarRatio = [];
      this.samples = [];
      this.warnings = [];
      this.hvcC = null;
    }
  }, {
    key: "firstDts",
    get: function get() {
      return this.samples.length ? this.samples[0].dts : null;
    }
  }, {
    key: "firstPts",
    get: function get() {
      return this.samples.length ? this.samples[0].pts : null;
    }
  }, {
    key: "samplesDuration",
    get: function get() {
      if (this.samples.length > 0) {
        var first = this.samples[0];
        var last = this.samples[this.samples.length - 1];
        return last.dts - first.dts + last.duration;
      }
      return 0;
    }
  }, {
    key: "exist",
    value: function exist() {
      if (/av01/.test(this.codec)) {
        return true;
      }
      return !!(this.pps.length && this.sps.length && this.codec);
    }
  }, {
    key: "hasSample",
    value: function hasSample() {
      return !!this.samples.length;
    }
  }, {
    key: "isEncryption",
    get: function get() {
      return this.isVideoEncryption;
    }
  }]);
  return VideoTrack2;
}();

// node_modules/xgplayer-transmuxer/es/model/audio-track.js
var AudioTrack = /* @__PURE__ */ function() {
  function AudioTrack2() {
    _classCallCheck3(this, AudioTrack2);
    _defineProperty3(this, "id", 2);
    _defineProperty3(this, "type", TrackType.AUDIO);
    _defineProperty3(this, "codecType", AudioCodecType.AAC);
    _defineProperty3(this, "pid", -1);
    _defineProperty3(this, "codec", "");
    _defineProperty3(this, "container", "");
    _defineProperty3(this, "sequenceNumber", 0);
    _defineProperty3(this, "sampleDuration", 0);
    _defineProperty3(this, "timescale", 0);
    _defineProperty3(this, "formatTimescale", 0);
    _defineProperty3(this, "baseMediaDecodeTime", 0);
    _defineProperty3(this, "duration", 0);
    _defineProperty3(this, "warnings", []);
    _defineProperty3(this, "samples", []);
    _defineProperty3(this, "baseDts", 0);
    _defineProperty3(this, "sampleSize", 16);
    _defineProperty3(this, "sampleRate", 0);
    _defineProperty3(this, "channelCount", 0);
    _defineProperty3(this, "objectType", 0);
    _defineProperty3(this, "sampleRateIndex", 0);
    _defineProperty3(this, "config", []);
    _defineProperty3(this, "present", false);
    _defineProperty3(this, "isVideoEncryption", false);
    _defineProperty3(this, "isAudioEncryption", false);
    _defineProperty3(this, "kid", null);
    _defineProperty3(this, "ext", void 0);
  }
  _createClass3(AudioTrack2, [{
    key: "reset",
    value: function reset() {
      this.sequenceNumber = 0;
      this.timescale = 0;
      this.sampleDuration = 0;
      this.sampleRate = 0;
      this.channelCount = 0;
      this.baseMediaDecodeTime = 0;
      this.present = false;
      this.pid = -1;
      this.codec = "";
      this.samples = [];
      this.config = [];
      this.warnings = [];
    }
  }, {
    key: "exist",
    value: function exist() {
      return !!(this.sampleRate && this.channelCount && (this.codec || this.container) && (this.codecType === AudioCodecType.AAC || this.codecType === AudioCodecType.G711PCMA || this.codecType === AudioCodecType.G711PCMU || this.codecType === AudioCodecType.OPUS || this.codecType === AudioCodecType.MP3));
    }
  }, {
    key: "hasSample",
    value: function hasSample() {
      return !!this.samples.length;
    }
  }, {
    key: "isEncryption",
    get: function get() {
      return this.isAudioEncryption;
    }
  }, {
    key: "firstDts",
    get: function get() {
      return this.samples.length ? this.samples[0].dts : null;
    }
  }, {
    key: "firstPts",
    get: function get() {
      return this.samples.length ? this.samples[0].pts : null;
    }
  }, {
    key: "samplesDuration",
    get: function get() {
      if (this.samples.length > 0) {
        var first = this.samples[0];
        var last = this.samples[this.samples.length - 1];
        return last.dts - first.dts + last.duration;
      }
      return 0;
    }
  }]);
  return AudioTrack2;
}();

// node_modules/xgplayer-transmuxer/es/model/video-sample.js
var VideoSample = /* @__PURE__ */ function() {
  function VideoSample2(pts, dts, units) {
    _classCallCheck3(this, VideoSample2);
    _defineProperty3(this, "flag", {});
    _defineProperty3(this, "keyframe", false);
    _defineProperty3(this, "gopId", 0);
    _defineProperty3(this, "duration", 0);
    _defineProperty3(this, "size", 0);
    _defineProperty3(this, "units", []);
    _defineProperty3(this, "chromaFormat", 420);
    this.originPts = this.pts = pts;
    this.originDts = this.dts = dts;
    if (units)
      this.units = units;
  }
  _createClass3(VideoSample2, [{
    key: "cts",
    get: function get() {
      return this.pts - this.dts;
    }
  }, {
    key: "setToKeyframe",
    value: function setToKeyframe() {
      this.keyframe = true;
      this.flag.dependsOn = 2;
      this.flag.isNonSyncSample = 0;
    }
  }]);
  return VideoSample2;
}();

// node_modules/xgplayer-transmuxer/es/model/audio-sample.js
var AudioSample = /* @__PURE__ */ _createClass3(
  function AudioSample2(pts, data, duration, sampleOffset) {
    _classCallCheck3(this, AudioSample2);
    _defineProperty3(this, "duration", 1024);
    _defineProperty3(this, "flag", {
      dependsOn: 2,
      isNonSyncSample: 0
    });
    _defineProperty3(this, "keyframe", true);
    this.originPts = this.pts = this.dts = pts;
    this.data = data;
    this.size = data.byteLength;
    this.sampleOffset = sampleOffset;
    if (duration)
      this.duration = duration;
  }
);

// node_modules/xgplayer-transmuxer/es/model/metadata-track.js
var Sample = /* @__PURE__ */ _createClass3(
  function Sample2(data, pts) {
    _classCallCheck3(this, Sample2);
    _defineProperty3(this, "time", 0);
    this.data = data;
    this.originPts = this.pts = pts;
  }
);
var FlvScriptSample = /* @__PURE__ */ function(_Sample) {
  _inherits3(FlvScriptSample2, _Sample);
  var _super = _createSuper3(FlvScriptSample2);
  function FlvScriptSample2() {
    _classCallCheck3(this, FlvScriptSample2);
    return _super.apply(this, arguments);
  }
  return _createClass3(FlvScriptSample2);
}(Sample);
var SeiSample = /* @__PURE__ */ function(_Sample2) {
  _inherits3(SeiSample2, _Sample2);
  var _super2 = _createSuper3(SeiSample2);
  function SeiSample2() {
    _classCallCheck3(this, SeiSample2);
    return _super2.apply(this, arguments);
  }
  return _createClass3(SeiSample2);
}(Sample);
var MetadataTrack = /* @__PURE__ */ function() {
  function MetadataTrack2() {
    _classCallCheck3(this, MetadataTrack2);
    _defineProperty3(this, "id", 3);
    _defineProperty3(this, "type", TrackType.METADATA);
    _defineProperty3(this, "timescale", 0);
    _defineProperty3(this, "flvScriptSamples", []);
    _defineProperty3(this, "seiSamples", []);
  }
  _createClass3(MetadataTrack2, [{
    key: "exist",
    value: function exist() {
      return !!((this.flvScriptSamples.length || this.seiSamples.length) && this.timescale);
    }
  }, {
    key: "reset",
    value: function reset() {
      this.timescale = 0;
      this.flvScriptSamples = [];
      this.seiSamples = [];
    }
  }, {
    key: "hasSample",
    value: function hasSample() {
      return !!(this.flvScriptSamples.length || this.seiSamples.length);
    }
  }]);
  return MetadataTrack2;
}();

// node_modules/xgplayer-transmuxer/es/utils/logger.js
var Logger2 = /* @__PURE__ */ function() {
  function Logger22(name) {
    _classCallCheck3(this, Logger22);
    this.name = name || "";
    this._prefix = "[".concat(this.name, "]");
  }
  _createClass3(Logger22, [{
    key: "warn",
    value: function warn() {
      var _console;
      if (Logger22.disabled)
        return;
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      (_console = console).warn.apply(_console, [this._prefix].concat(args));
    }
  }], [{
    key: "enable",
    value: function enable() {
      Logger22.disabled = false;
    }
  }, {
    key: "disable",
    value: function disable() {
      Logger22.disabled = true;
    }
  }]);
  return Logger22;
}();
_defineProperty3(Logger2, "disabled", true);

// node_modules/xgplayer-transmuxer/es/utils/env.js
var isBrowser2 = typeof window !== "undefined";
var ua = isBrowser2 && navigator.userAgent.toLocaleLowerCase();
var isSafari = isBrowser2 && /^((?!chrome|android).)*safari/.test(ua);
var isFirefox = isBrowser2 && ua.includes("firefox");
var isAndroid = isBrowser2 && ua.includes("android");

// node_modules/xgplayer-transmuxer/es/codec/aac.js
var AAC = /* @__PURE__ */ function() {
  function AAC2() {
    _classCallCheck3(this, AAC2);
  }
  _createClass3(AAC2, null, [{
    key: "getRateIndexByRate",
    value: function getRateIndexByRate(rate) {
      return AAC2.FREQ.indexOf(rate);
    }
  }, {
    key: "parseADTS",
    value: function parseADTS(data, pts) {
      var len = data.length;
      var i = 0;
      while (i + 2 < len) {
        if (data[i] === 255 && (data[i + 1] & 246) === 240) {
          break;
        }
        i++;
      }
      if (i >= len)
        return;
      var skip = i;
      var frames = [];
      var samplingFrequencyIndex = (data[i + 2] & 60) >>> 2;
      var sampleRate = AAC2.FREQ[samplingFrequencyIndex];
      if (!sampleRate)
        throw new Error("Invalid sampling index: ".concat(samplingFrequencyIndex));
      var objectType = ((data[i + 2] & 192) >>> 6) + 1;
      var channelCount = (data[i + 2] & 1) << 2 | (data[i + 3] & 192) >>> 6;
      var _AAC$_getConfig = AAC2._getConfig(samplingFrequencyIndex, channelCount, objectType), config = _AAC$_getConfig.config, codec = _AAC$_getConfig.codec;
      var protectionSkipBytes;
      var frameLength;
      var frameIndex = 0;
      var duration = AAC2.getFrameDuration(sampleRate);
      while (i + 7 < len) {
        if (data[i] !== 255 || (data[i + 1] & 246) !== 240) {
          i++;
          continue;
        }
        frameLength = (data[i + 3] & 3) << 11 | data[i + 4] << 3 | (data[i + 5] & 224) >> 5;
        if (!frameLength || len - i < frameLength)
          break;
        protectionSkipBytes = (~data[i + 1] & 1) * 2;
        frames.push({
          pts: pts + frameIndex * duration,
          data: data.subarray(i + 7 + protectionSkipBytes, i + frameLength)
        });
        frameIndex++;
        i += frameLength;
      }
      return {
        skip,
        remaining: i >= len ? void 0 : data.subarray(i),
        frames,
        samplingFrequencyIndex,
        sampleRate,
        objectType,
        channelCount,
        codec,
        config,
        originCodec: "mp4a.40.".concat(objectType)
      };
    }
  }, {
    key: "parseAudioSpecificConfig",
    value: function parseAudioSpecificConfig(data) {
      if (!data.length)
        return;
      var objectType = data[0] >>> 3;
      var samplingFrequencyIndex = (data[0] & 7) << 1 | data[1] >>> 7;
      var channelCount = (data[1] & 120) >>> 3;
      var sampleRate = AAC2.FREQ[samplingFrequencyIndex];
      if (!sampleRate)
        return;
      var _AAC$_getConfig2 = AAC2._getConfig(samplingFrequencyIndex, channelCount, objectType), config = _AAC$_getConfig2.config, codec = _AAC$_getConfig2.codec;
      return {
        samplingFrequencyIndex,
        sampleRate,
        objectType,
        channelCount,
        config,
        codec,
        originCodec: "mp4a.40.".concat(objectType)
      };
    }
  }, {
    key: "getFrameDuration",
    value: function getFrameDuration(rate) {
      var timescale = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 9e4;
      return 1024 * timescale / rate;
    }
  }, {
    key: "_getConfig",
    value: function _getConfig(samplingIndex, channelCount, originObjectType) {
      var config = [];
      var objectType;
      var extensionSamplingIndex;
      if (isFirefox) {
        if (samplingIndex >= 6) {
          objectType = 5;
          extensionSamplingIndex = samplingIndex - 3;
        } else {
          objectType = 2;
          extensionSamplingIndex = samplingIndex;
        }
      } else if (isAndroid) {
        objectType = 2;
        extensionSamplingIndex = samplingIndex;
      } else {
        objectType = 5;
        extensionSamplingIndex = samplingIndex;
        if (samplingIndex >= 6) {
          extensionSamplingIndex = samplingIndex - 3;
        } else if (channelCount === 1) {
          objectType = 2;
          extensionSamplingIndex = samplingIndex;
        }
      }
      config[0] = objectType << 3;
      config[0] |= (samplingIndex & 14) >> 1;
      config[1] = (samplingIndex & 1) << 7;
      config[1] |= channelCount << 3;
      if (objectType === 5) {
        config[1] |= (extensionSamplingIndex & 14) >> 1;
        config[2] = (extensionSamplingIndex & 1) << 7;
        config[2] |= 2 << 2;
        config[3] = 0;
      }
      return {
        config,
        codec: "mp4a.40.".concat(objectType)
      };
    }
  }, {
    key: "getSilentFrame",
    value: function getSilentFrame(codec, channelCount) {
      switch (codec) {
        case "mp4a.40.2":
          if (channelCount === 1) {
            return new Uint8Array([0, 200, 0, 128, 35, 128]);
          }
          if (channelCount === 2) {
            return new Uint8Array([33, 0, 73, 144, 2, 25, 0, 35, 128]);
          }
          if (channelCount === 3) {
            return new Uint8Array([0, 200, 0, 128, 32, 132, 1, 38, 64, 8, 100, 0, 142]);
          }
          if (channelCount === 4) {
            return new Uint8Array([0, 200, 0, 128, 32, 132, 1, 38, 64, 8, 100, 0, 128, 44, 128, 8, 2, 56]);
          }
          if (channelCount === 5) {
            return new Uint8Array([0, 200, 0, 128, 32, 132, 1, 38, 64, 8, 100, 0, 130, 48, 4, 153, 0, 33, 144, 2, 56]);
          }
          if (channelCount === 6) {
            return new Uint8Array([0, 200, 0, 128, 32, 132, 1, 38, 64, 8, 100, 0, 130, 48, 4, 153, 0, 33, 144, 2, 0, 178, 0, 32, 8, 224]);
          }
          break;
        default:
          if (channelCount === 1) {
            return new Uint8Array([1, 64, 34, 128, 163, 78, 230, 128, 186, 8, 0, 0, 0, 28, 6, 241, 193, 10, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 94]);
          }
          if (channelCount === 2) {
            return new Uint8Array([1, 64, 34, 128, 163, 94, 230, 128, 186, 8, 0, 0, 0, 0, 149, 0, 6, 241, 161, 10, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 94]);
          }
          if (channelCount === 3) {
            return new Uint8Array([1, 64, 34, 128, 163, 94, 230, 128, 186, 8, 0, 0, 0, 0, 149, 0, 6, 241, 161, 10, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 94]);
          }
          break;
      }
    }
  }]);
  return AAC2;
}();
_defineProperty3(AAC, "FREQ", [96e3, 88200, 64e3, 48e3, 44100, 32e3, 24e3, 22050, 16e3, 12e3, 11025, 8e3, 7350]);

// node_modules/xgplayer-transmuxer/es/codec/opus.js
var OPUS = /* @__PURE__ */ function() {
  function OPUS2() {
    _classCallCheck3(this, OPUS2);
  }
  _createClass3(OPUS2, null, [{
    key: "getFrameDuration",
    value: function getFrameDuration(samples) {
      return 20;
    }
  }, {
    key: "parseHeaderPackets",
    value: function parseHeaderPackets(data) {
      if (!data.length)
        return;
      var dv = new DataView(data.buffer, data.byteOffset, data.byteLength);
      var magicSignature = "";
      for (var i = 0; i < 8; i++) {
        magicSignature += String.fromCodePoint(data[i]);
      }
      if (magicSignature !== "OpusHead") {
        throw new Error("Invalid Opus MagicSignature");
      }
      var channelCount = data[9];
      console.log("Pre-skip", data[10], data[11]);
      var sampleRate = dv.getUint32(12, true);
      var outputGain = dv.getInt16(16, true);
      if (!sampleRate)
        return;
      var codec = "opus";
      var originCodec = "opus";
      var config = new Uint8Array(data.buffer, data.byteOffset + 8, data.byteLength - 8);
      return {
        outputGain,
        sampleRate,
        channelCount,
        config,
        codec,
        originCodec
      };
    }
  }]);
  return OPUS2;
}();

// node_modules/xgplayer-transmuxer/es/flv/fixer.js
var LARGE_AV_FIRST_FRAME_GAP = 500;
var AUDIO_GAP_OVERLAP_THRESHOLD_COUNT = 3;
var MAX_SILENT_FRAME_DURATION = 1e3;
var AUDIO_EXCEPTION_LOG_EMIT_DURATION = 5e3;
var MAX_VIDEO_FRAME_DURATION = 1e3;
var MAX_DTS_DELTA_WITH_NEXT_CHUNK = 200;
var VIDEO_EXCEPTION_LOG_EMIT_DURATION = 5e3;
var TRACK_BROKEN_CHECK_TIME = 5;
var FlvFixer = /* @__PURE__ */ function() {
  function FlvFixer2(videoTrack, audioTrack, metadataTrack) {
    _classCallCheck3(this, FlvFixer2);
    this.videoTrack = videoTrack;
    this.audioTrack = audioTrack;
    this.metadataTrack = metadataTrack;
    this._baseDts = -1;
    this._baseDtsInited = false;
    this._audioNextPts = void 0;
    this._videoNextDts = void 0;
    this._audioTimestampBreak = 0;
    this._videoTimestampBreak = 0;
    this._lastVideoDuration = 0;
    this._keyFrameInNextChunk = false;
    this._lastAudioExceptionGapDot = -Infinity;
    this._lastAudioExceptionOverlapDot = -Infinity;
    this._lastAudioExceptionLargeGapDot = -Infinity;
    this._lastVideoExceptionLargeGapDot = -Infinity;
    this._lastVideoExceptionChunkFirstDtsDot = -Infinity;
  }
  _createClass3(FlvFixer2, [{
    key: "fix",
    value: function fix() {
      var _this = this;
      var startTime = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
      var discontinuity = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
      var contiguous = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : true;
      startTime = Math.round(startTime * 1e3);
      var videoTrack = this.videoTrack;
      var audioTrack = this.audioTrack;
      if (discontinuity || !contiguous) {
        this._videoLastSample = null;
        this._audioNextPts = void 0;
        this._videoNextDts = void 0;
        this._audioTimestampBreak = 0;
        this._videoTimestampBreak = 0;
        this._lastAudioExceptionGapDot = -Infinity;
        this._lastAudioExceptionOverlapDot = -Infinity;
        this._lastAudioExceptionLargeGapDot = -Infinity;
        this._lastVideoExceptionLargeGapDot = -Infinity;
        this._lastVideoExceptionChunkFirstDtsDot = -Infinity;
      }
      if (discontinuity && !contiguous) {
        this._baseDtsInited = false;
      }
      if (!this._baseDtsInited) {
        this._calculateBaseDts(audioTrack, videoTrack);
      }
      if (!contiguous && startTime) {
        this._audioNextPts = this._videoNextDts = startTime;
      }
      var resetBaseDts = this._baseDtsInited && (this._videoTimestampBreak || !this.videoTrack.exist()) && (this._audioTimestampBreak || !this.audioTrack.exist());
      if (resetBaseDts) {
        this._resetBaseDtsWhenStreamBreaked();
      }
      this._fixAudio(audioTrack);
      this._keyFrameInNextChunk = false;
      this._fixVideo(videoTrack);
      if (this.metadataTrack.exist()) {
        var timescale = this.metadataTrack.timescale;
        this.metadataTrack.seiSamples.forEach(function(s) {
          s.pts = s.originPts - _this._baseDts;
          s.time = Math.max(0, s.pts) / timescale;
        });
        this.metadataTrack.flvScriptSamples.forEach(function(s) {
          s.pts = s.originPts - _this._baseDts;
          s.time = Math.max(0, s.pts) / timescale;
        });
      }
      if (videoTrack.samples.length) {
        videoTrack.baseMediaDecodeTime = videoTrack.samples[0].dts;
      }
      if (audioTrack.samples.length) {
        audioTrack.baseMediaDecodeTime = audioTrack.samples[0].pts * audioTrack.timescale / 1e3;
      }
    }
  }, {
    key: "_fixVideo",
    value: function _fixVideo(videoTrack) {
      var _this2 = this;
      var samples = videoTrack.samples;
      if (!samples.length)
        return;
      samples.forEach(function(x) {
        x.dts -= _this2._baseDts;
        x.pts -= _this2._baseDts;
        if (x.keyframe)
          _this2._keyFrameInNextChunk = true;
      });
      var refSampleDurationInt;
      if (videoTrack.fpsNum && videoTrack.fpsDen) {
        refSampleDurationInt = videoTrack.timescale * (videoTrack.fpsDen / videoTrack.fpsNum);
      } else if (videoTrack.length > 1) {
        var first = videoTrack.samples[0];
        var last = videoTrack.samples[samples.length - 1];
        refSampleDurationInt = Math.floor((last.dts - first.dts) / (samples.length - 1));
      } else {
        refSampleDurationInt = this._lastVideoDuration || 40;
      }
      var lastSample = samples.pop();
      if (this._videoLastSample) {
        samples.unshift(this._videoLastSample);
      }
      this._videoLastSample = lastSample;
      if (!samples.length)
        return;
      if (this._videoNextDts === void 0) {
        var samp0 = samples[0];
        this._videoNextDts = samp0.dts;
      }
      var len = samples.length;
      var sampleDuration = 0;
      var firstSample = samples[0];
      var vDelta = this._videoNextDts - firstSample.dts;
      if (Math.abs(vDelta) > MAX_DTS_DELTA_WITH_NEXT_CHUNK) {
        if (Math.abs(firstSample.dts - this._lastVideoExceptionChunkFirstDtsDot) > VIDEO_EXCEPTION_LOG_EMIT_DURATION) {
          var _samples$;
          this._lastVideoExceptionChunkFirstDtsDot = firstSample.dts;
          videoTrack.warnings.push({
            type: WarningType.LARGE_VIDEO_GAP_BETWEEN_CHUNK,
            nextDts: this._videoNextDts,
            firstSampleDts: firstSample.dts,
            nextSampleDts: (_samples$ = samples[1]) === null || _samples$ === void 0 ? void 0 : _samples$.dts,
            sampleDuration: vDelta
          });
        }
        if (this._videoTimestampBreak >= TRACK_BROKEN_CHECK_TIME) {
          this._videoNextDts = firstSample.dts;
          this._videoTimestampBreak = 0;
        } else {
          firstSample.dts += vDelta;
          firstSample.pts += vDelta;
          if (!this.audioTrack.exist()) {
            this._videoTimestampBreak = 1;
          }
        }
      }
      for (var i = 0; i < len; i++) {
        var dts = samples[i].dts;
        var nextSample = samples[i + 1];
        if (i < len - 1) {
          sampleDuration = nextSample.dts - dts;
        } else if (lastSample) {
          sampleDuration = lastSample.dts - dts;
        } else {
          sampleDuration = refSampleDurationInt;
        }
        if (sampleDuration > MAX_VIDEO_FRAME_DURATION || sampleDuration < 0) {
          this._videoTimestampBreak++;
          if (Math.abs(dts - this._lastVideoExceptionLargeGapDot) > VIDEO_EXCEPTION_LOG_EMIT_DURATION) {
            this._lastVideoExceptionLargeGapDot = dts;
            videoTrack.warnings.push({
              type: WarningType.LARGE_VIDEO_GAP,
              time: dts / videoTrack.timescale,
              dts,
              originDts: samples[i].originDts,
              nextDts: this._videoNextDts,
              sampleDuration,
              refSampleDuration: refSampleDurationInt
            });
          }
          sampleDuration = refSampleDurationInt;
        }
        samples[i].duration = sampleDuration;
        this._videoNextDts += sampleDuration;
        this._lastVideoDuration = sampleDuration;
      }
    }
  }, {
    key: "_fixAudio",
    value: function _fixAudio(audioTrack) {
      var _this3 = this;
      var samples = audioTrack.samples;
      if (!samples.length)
        return;
      samples.forEach(function(x) {
        x.dts = x.pts -= _this3._baseDts;
      });
      this._doFixAudioInternal(audioTrack, samples, 1e3);
    }
  }, {
    key: "_calculateBaseDts",
    value: function _calculateBaseDts(audioTrack, videoTrack) {
      var audioSamps = audioTrack.samples;
      var videoSamps = videoTrack.samples;
      if (!audioSamps.length && !videoSamps.length) {
        return false;
      }
      var audioBasePts = Infinity;
      var videoBaseDts = Infinity;
      if (audioSamps.length) {
        audioTrack.baseDts = audioBasePts = audioSamps[0].pts;
      }
      if (videoSamps.length) {
        videoTrack.baseDts = videoBaseDts = videoSamps[0].dts;
      }
      this._baseDts = Math.min(audioBasePts, videoBaseDts);
      var delta = videoBaseDts - audioBasePts;
      if (Number.isFinite(delta) && Math.abs(delta) > LARGE_AV_FIRST_FRAME_GAP) {
        videoTrack.warnings.push({
          type: WarningType.LARGE_AV_SHIFT,
          videoBaseDts,
          audioBasePts,
          baseDts: this._baseDts,
          delta
        });
      }
      this._baseDtsInited = true;
      return true;
    }
  }, {
    key: "_resetBaseDtsWhenStreamBreaked",
    value: function _resetBaseDtsWhenStreamBreaked() {
      var calc = this._calculateBaseDts(this.audioTrack, this.videoTrack);
      if (!calc)
        return;
      if (!this.audioTrack.exist()) {
        this._baseDts -= this._videoNextDts;
      } else if (!this.videoTrack.exist()) {
        this._baseDts -= this._audioNextPts;
      } else {
        this._baseDts -= Math.min(this._audioNextPts, this._videoNextDts);
      }
      this._videoTimestampBreak = 0;
      this._audioTimestampBreak = 0;
    }
  }, {
    key: "_doFixAudioInternal",
    value: function _doFixAudioInternal(audioTrack, samples, timescale) {
      if (!audioTrack.sampleDuration) {
        switch (audioTrack.codecType) {
          case AudioCodecType.AAC: {
            audioTrack.sampleDuration = AAC.getFrameDuration(audioTrack.timescale, timescale);
            break;
          }
          case AudioCodecType.OPUS: {
            audioTrack.sampleDuration = OPUS.getFrameDuration(audioTrack.samples, timescale);
            break;
          }
          case AudioCodecType.G711PCMA:
          case AudioCodecType.G711PCMU: {
            audioTrack.sampleDuration = this._getG711Duration(audioTrack);
            break;
          }
          default:
            console.error("can't fix audio codecType:", audioTrack.codecType);
            break;
        }
      }
      var refSampleDuration = audioTrack.sampleDuration;
      var sampleDurationInSampleRate = audioTrack.codecType === AudioCodecType.OPUS ? 20 : audioTrack.codecType === AudioCodecType.AAC ? 1024 : refSampleDuration * audioTrack.timescale / 1e3;
      if (this._audioNextPts === void 0) {
        var samp0 = samples[0];
        this._audioNextPts = samp0.pts;
      }
      for (var i = 0; i < samples.length; i++) {
        var nextPts = this._audioNextPts;
        var sample = samples[i];
        var delta = sample.pts - nextPts;
        if (i === 0 && this._audioTimestampBreak >= TRACK_BROKEN_CHECK_TIME && this._keyFrameInNextChunk) {
          nextPts = this._audioNextPts = sample.dts;
          delta = 0;
          this._audioTimestampBreak = 0;
        }
        if (!this._audioTimestampBreak && delta >= AUDIO_GAP_OVERLAP_THRESHOLD_COUNT * refSampleDuration && delta <= MAX_SILENT_FRAME_DURATION && !isSafari) {
          var silentFrame = this._getSilentFrame(audioTrack) || samples[0].data.subarray();
          var count = Math.floor(delta / refSampleDuration);
          if (Math.abs(sample.pts - this._lastAudioExceptionGapDot) > AUDIO_EXCEPTION_LOG_EMIT_DURATION) {
            this._lastAudioExceptionGapDot = sample.pts;
            audioTrack.warnings.push({
              type: WarningType.AUDIO_FILLED,
              pts: sample.pts,
              originPts: sample.originPts,
              count,
              nextPts,
              refSampleDuration
            });
          }
          for (var j = 0; j < count; j++) {
            var silentSample = new AudioSample(Math.floor(this._audioNextPts + refSampleDuration) - Math.floor(this._audioNextPts), silentFrame, sampleDurationInSampleRate);
            silentSample.originPts = Math.floor(this._baseDts + nextPts);
            samples.splice(i, 0, silentSample);
            this._audioNextPts += refSampleDuration;
            i++;
          }
          i--;
        } else if (delta <= -AUDIO_GAP_OVERLAP_THRESHOLD_COUNT * refSampleDuration && delta >= -1 * MAX_SILENT_FRAME_DURATION) {
          if (Math.abs(sample.pts - this._lastAudioExceptionOverlapDot) > AUDIO_EXCEPTION_LOG_EMIT_DURATION) {
            this._lastAudioExceptionOverlapDot = sample.pts;
            audioTrack.warnings.push({
              type: WarningType.AUDIO_DROPPED,
              pts: sample.pts,
              originPts: sample.originPts,
              nextPts,
              refSampleDuration
            });
          }
          samples.splice(i, 1);
          i--;
        } else {
          if (Math.abs(delta) > MAX_SILENT_FRAME_DURATION) {
            this._audioTimestampBreak++;
            if (Math.abs(sample.pts - this._lastAudioExceptionLargeGapDot) > AUDIO_EXCEPTION_LOG_EMIT_DURATION) {
              this._lastAudioExceptionLargeGapDot = sample.pts;
              audioTrack.warnings.push({
                type: WarningType.LARGE_AUDIO_GAP,
                time: sample.pts / 1e3,
                pts: sample.pts,
                originPts: sample.originPts,
                nextPts,
                sampleDuration: delta,
                refSampleDuration
              });
            }
          }
          if (audioTrack.codecType === AudioCodecType.OPUS) {
            var lastSample = samples[samples.length - 1];
            if (lastSample) {
              lastSample.duration = sample.pts - lastSample.pts;
            }
          } else {
            sample.dts = sample.pts = nextPts;
            sample.duration = sampleDurationInSampleRate;
          }
          this._audioNextPts += refSampleDuration;
        }
      }
    }
  }, {
    key: "_getG711Duration",
    value: function _getG711Duration(track) {
      var sampleSize = track.sampleSize, channelCount = track.channelCount, sampleRate = track.sampleRate;
      var samp0 = track.samples[0];
      if (!samp0)
        return;
      return samp0.data.byteLength * 2 / channelCount / (sampleSize / 8) / sampleRate * 1e3;
    }
  }, {
    key: "_getSilentFrame",
    value: function _getSilentFrame(track) {
      if (track.codecType === AudioCodecType.AAC)
        return AAC.getSilentFrame(track.codec, track.channelCount);
      return new Uint8Array(8 * track.sampleDuration * track.channelCount);
    }
  }]);
  return FlvFixer2;
}();

// node_modules/xgplayer-transmuxer/es/utils/index.js
function concatUint8Array2() {
  for (var _len = arguments.length, arr = new Array(_len), _key = 0; _key < _len; _key++) {
    arr[_key] = arguments[_key];
  }
  arr = arr.filter(Boolean);
  var data = new Uint8Array(arr.reduce(function(p, c) {
    return p + c.byteLength;
  }, 0));
  var prevLen = 0;
  arr.forEach(function(d) {
    data.set(d, prevLen);
    prevLen += d.byteLength;
  });
  return data;
}
var MAX_SIZE = Math.pow(2, 32);
function readBig32(data) {
  var i = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
  return (data[i] << 24 >>> 0) + (data[i + 1] << 16) + (data[i + 2] << 8) + (data[i + 3] || 0);
}
function getAvcCodec(codecs) {
  var codec = "avc1.";
  var h;
  for (var i = 0; i < 3; i++) {
    h = codecs[i].toString(16);
    if (h.length < 2)
      h = "0".concat(h);
    codec += h;
  }
  return codec;
}
function parse2(a) {
  if (!Array.isArray(a)) {
    var arr = [];
    var value = "";
    for (var i = 0; i < a.length; i++) {
      if (i % 2) {
        value = a[i - 1] + a[i];
        arr.push(parseInt(value, 16));
        value = "";
      }
    }
    return arr;
  }
  return a.map(function(item) {
    return parseInt(item, 16);
  });
}

// node_modules/xgplayer-transmuxer/es/codec/nalu.js
var NALu = /* @__PURE__ */ function() {
  function NALu2() {
    _classCallCheck3(this, NALu2);
  }
  _createClass3(NALu2, null, [{
    key: "parseAnnexB",
    value: function parseAnnexB(data) {
      var j = data.byteLength - 1;
      var dropZerosLength = 0;
      do {
        if (data[j] === 0) {
          dropZerosLength++;
        } else {
          break;
        }
        j--;
      } while (j > 0);
      if (dropZerosLength >= 3) {
        data = data.subarray(0, j + 1);
      }
      var len = data.length;
      var start = 2;
      var end = 0;
      while (data[start] !== null && data[start] !== void 0 && data[start] !== 1) {
        start++;
      }
      start++;
      end = start + 2;
      if (end >= len)
        return [];
      var units = [];
      while (end < len) {
        switch (data[end]) {
          case 0:
            if (data[end - 1] !== 0) {
              end += 2;
              break;
            } else if (data[end - 2] !== 0) {
              end++;
              break;
            } else if (end < len - 1 && data[end + 1] !== 1) {
              end++;
              break;
            }
            if (start !== end - 2)
              units.push(data.subarray(start, end - 2));
            do {
              end++;
            } while (data[end] !== 1 && end < len);
            start = end + 1;
            end = start + 2;
            break;
          case 1:
            if (data[end - 1] !== 0 || data[end - 2] !== 0) {
              end += 3;
              break;
            }
            if (start !== end - 2)
              units.push(data.subarray(start, end - 2));
            start = end + 1;
            end = start + 2;
            break;
          default:
            end += 3;
            break;
        }
      }
      if (start < len)
        units.push(data.subarray(start));
      return units;
    }
  }, {
    key: "parseAvcC",
    value: function parseAvcC(data) {
      var size = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 4;
      if (data.length < 4)
        return;
      var dataLen = data.length;
      var units = [];
      var offset = 0;
      var length;
      while (offset + size < dataLen) {
        length = readBig32(data, offset);
        if (size === 3)
          length >>>= 8;
        offset += size;
        if (!length)
          continue;
        if (offset + length > dataLen) {
          break;
        }
        units.push(data.subarray(offset, offset + length));
        offset += length;
      }
      return units;
    }
  }, {
    key: "parseSEI",
    value: function parseSEI(unit, isHevc) {
      var len = unit.length;
      var i = isHevc ? 2 : 1;
      var type = 0;
      var size = 0;
      var uuid = "";
      while (unit[i] === 255) {
        type += 255;
        i++;
      }
      type += unit[i++];
      while (unit[i] === 255) {
        size += 255;
        i++;
      }
      size += unit[i++];
      if (type === 5 && len > i + 16) {
        for (var j = 0; j < 16; j++) {
          uuid += unit[i].toString(16);
          i++;
        }
      }
      return {
        payload: unit.subarray(i, i + size),
        type,
        size,
        uuid
      };
    }
  }, {
    key: "removeEPB",
    value: function removeEPB(uint) {
      var length = uint.byteLength;
      var emulationPreventionBytesPositions = [];
      var i = 1;
      while (i < length - 2) {
        if (uint[i] === 0 && uint[i + 1] === 0 && uint[i + 2] === 3) {
          emulationPreventionBytesPositions.push(i + 2);
          i += 2;
        } else {
          i++;
        }
      }
      if (!emulationPreventionBytesPositions.length)
        return uint;
      var newLength = length - emulationPreventionBytesPositions.length;
      var newData = new Uint8Array(newLength);
      var sourceIndex = 0;
      for (i = 0; i < newLength; sourceIndex++, i++) {
        if (sourceIndex === emulationPreventionBytesPositions[0]) {
          sourceIndex++;
          emulationPreventionBytesPositions.shift();
        }
        newData[i] = uint[sourceIndex];
      }
      return newData;
    }
  }]);
  return NALu2;
}();

// node_modules/xgplayer-transmuxer/es/utils/exp-golomb.js
var ExpGolomb = /* @__PURE__ */ function() {
  function ExpGolomb2(data) {
    _classCallCheck3(this, ExpGolomb2);
    _defineProperty3(this, "_bytesAvailable", void 0);
    _defineProperty3(this, "_bitsAvailable", 0);
    _defineProperty3(this, "_word", 0);
    if (!data)
      throw new Error("ExpGolomb data params is required");
    this._data = data;
    this._bytesAvailable = data.byteLength;
    if (this._bytesAvailable)
      this._loadWord();
  }
  _createClass3(ExpGolomb2, [{
    key: "bitsAvailable",
    get: function get() {
      return this._bitsAvailable;
    }
  }, {
    key: "_loadWord",
    value: function _loadWord() {
      var position = this._data.byteLength - this._bytesAvailable;
      var availableBytes = Math.min(4, this._bytesAvailable);
      if (availableBytes === 0)
        throw new Error("No bytes available");
      var workingBytes = new Uint8Array(4);
      workingBytes.set(this._data.subarray(position, position + availableBytes));
      this._word = new DataView(workingBytes.buffer).getUint32(0);
      this._bitsAvailable = availableBytes * 8;
      this._bytesAvailable -= availableBytes;
    }
  }, {
    key: "skipBits",
    value: function skipBits(count) {
      if (this._bitsAvailable > count) {
        this._word <<= count;
        this._bitsAvailable -= count;
      } else {
        count -= this._bitsAvailable;
        var skipBytes = Math.floor(count / 8);
        count -= skipBytes * 8;
        this._bytesAvailable -= skipBytes;
        this._loadWord();
        this._word <<= count;
        this._bitsAvailable -= count;
      }
    }
  }, {
    key: "readBits",
    value: function readBits(size) {
      if (size > 32) {
        throw new Error("Cannot read more than 32 bits");
      }
      var bits = Math.min(this._bitsAvailable, size);
      var val = this._word >>> 32 - bits;
      this._bitsAvailable -= bits;
      if (this._bitsAvailable > 0) {
        this._word <<= bits;
      } else if (this._bytesAvailable > 0) {
        this._loadWord();
      }
      bits = size - bits;
      if (bits > 0 && this._bitsAvailable) {
        return val << bits | this.readBits(bits);
      }
      return val;
    }
  }, {
    key: "skipLZ",
    value: function skipLZ() {
      var leadingZeroCount;
      for (leadingZeroCount = 0; leadingZeroCount < this._bitsAvailable; ++leadingZeroCount) {
        if ((this._word & 2147483648 >>> leadingZeroCount) !== 0) {
          this._word <<= leadingZeroCount;
          this._bitsAvailable -= leadingZeroCount;
          return leadingZeroCount;
        }
      }
      this._loadWord();
      return leadingZeroCount + this.skipLZ();
    }
  }, {
    key: "skipUEG",
    value: function skipUEG() {
      this.skipBits(1 + this.skipLZ());
    }
  }, {
    key: "readUEG",
    value: function readUEG() {
      var clz = this.skipLZ();
      return this.readBits(clz + 1) - 1;
    }
  }, {
    key: "readEG",
    value: function readEG() {
      var val = this.readUEG();
      if (1 & val) {
        return 1 + val >>> 1;
      }
      return -1 * (val >>> 1);
    }
  }, {
    key: "readBool",
    value: function readBool() {
      return this.readBits(1) === 1;
    }
  }, {
    key: "readUByte",
    value: function readUByte() {
      return this.readBits(8);
    }
  }, {
    key: "skipScalingList",
    value: function skipScalingList(count) {
      var lastScale = 8;
      var nextScale = 8;
      var deltaScale;
      for (var j = 0; j < count; j++) {
        if (nextScale !== 0) {
          deltaScale = this.readEG();
          nextScale = (lastScale + deltaScale + 256) % 256;
        }
        lastScale = nextScale === 0 ? lastScale : nextScale;
      }
    }
  }]);
  return ExpGolomb2;
}();

// node_modules/xgplayer-transmuxer/es/codec/avc.js
var AVC = /* @__PURE__ */ function() {
  function AVC2() {
    _classCallCheck3(this, AVC2);
  }
  _createClass3(AVC2, null, [{
    key: "parseAVCDecoderConfigurationRecord",
    value: function parseAVCDecoderConfigurationRecord(data) {
      if (data.length < 7)
        return;
      var nalUnitSize = (data[4] & 3) + 1;
      var spsParsed;
      var spsArr = [];
      var ppsArr = [];
      var offset = 6;
      var spsCount = data[5] & 31;
      var spsSize;
      for (var i = 0; i < spsCount; i++) {
        spsSize = data[offset] << 8 | data[offset + 1];
        offset += 2;
        if (!spsSize)
          continue;
        var sps = data.subarray(offset, offset + spsSize);
        offset += spsSize;
        spsArr.push(sps);
        if (!spsParsed) {
          spsParsed = AVC2.parseSPS(NALu.removeEPB(sps));
        }
      }
      var ppsCount = data[offset];
      offset++;
      var ppsSize;
      for (var _i = 0; _i < ppsCount; _i++) {
        ppsSize = data[offset] << 8 | data[offset + 1];
        offset += 2;
        if (!ppsSize)
          continue;
        ppsArr.push(data.subarray(offset, offset + ppsSize));
        offset += ppsSize;
      }
      return {
        sps: spsParsed,
        spsArr,
        ppsArr,
        nalUnitSize
      };
    }
  }, {
    key: "parseSPS",
    value: function parseSPS(unit) {
      var eg = new ExpGolomb(unit);
      eg.readUByte();
      var profileIdc = eg.readUByte();
      var profileCompatibility = eg.readUByte();
      var levelIdc = eg.readUByte();
      eg.skipUEG();
      var chromaFormat = 420;
      if (profileIdc === 100 || profileIdc === 110 || profileIdc === 122 || profileIdc === 244 || profileIdc === 44 || profileIdc === 83 || profileIdc === 86 || profileIdc === 118 || profileIdc === 128 || profileIdc === 138 || profileIdc === 144) {
        var chromaFormatIdc = eg.readUEG();
        if (chromaFormatIdc <= 3)
          chromaFormat = [0, 420, 422, 444][chromaFormatIdc];
        if (chromaFormatIdc === 3)
          eg.skipBits(1);
        eg.skipUEG();
        eg.skipUEG();
        eg.skipBits(1);
        if (eg.readBool()) {
          var scalingListCount = chromaFormatIdc !== 3 ? 8 : 12;
          for (var i = 0; i < scalingListCount; i++) {
            if (eg.readBool()) {
              if (i < 6) {
                eg.skipScalingList(16);
              } else {
                eg.skipScalingList(64);
              }
            }
          }
        }
      }
      eg.skipUEG();
      var picOrderCntType = eg.readUEG();
      if (picOrderCntType === 0) {
        eg.readUEG();
      } else if (picOrderCntType === 1) {
        eg.skipBits(1);
        eg.skipUEG();
        eg.skipUEG();
        var numRefFramesInPicOrderCntCycle = eg.readUEG();
        for (var _i2 = 0; _i2 < numRefFramesInPicOrderCntCycle; _i2++) {
          eg.skipUEG();
        }
      }
      eg.skipUEG();
      eg.skipBits(1);
      var picWidthInMbsMinus1 = eg.readUEG();
      var picHeightInMapUnitsMinus1 = eg.readUEG();
      var frameMbsOnlyFlag = eg.readBits(1);
      if (frameMbsOnlyFlag === 0)
        eg.skipBits(1);
      eg.skipBits(1);
      var frameCropLeftOffset = 0;
      var frameCropRightOffset = 0;
      var frameCropTopOffset = 0;
      var frameCropBottomOffset = 0;
      if (eg.readBool()) {
        frameCropLeftOffset = eg.readUEG();
        frameCropRightOffset = eg.readUEG();
        frameCropTopOffset = eg.readUEG();
        frameCropBottomOffset = eg.readUEG();
      }
      var sarRatio;
      var fixedFrame;
      var fpsNum;
      var fpsDen;
      var fps;
      if (eg.readBool()) {
        if (eg.readBool()) {
          var aspectRatioIdc = eg.readUByte();
          switch (aspectRatioIdc) {
            case 1:
              sarRatio = [1, 1];
              break;
            case 2:
              sarRatio = [12, 11];
              break;
            case 3:
              sarRatio = [10, 11];
              break;
            case 4:
              sarRatio = [16, 11];
              break;
            case 5:
              sarRatio = [40, 33];
              break;
            case 6:
              sarRatio = [24, 11];
              break;
            case 7:
              sarRatio = [20, 11];
              break;
            case 8:
              sarRatio = [32, 11];
              break;
            case 9:
              sarRatio = [80, 33];
              break;
            case 10:
              sarRatio = [18, 11];
              break;
            case 11:
              sarRatio = [15, 11];
              break;
            case 12:
              sarRatio = [64, 33];
              break;
            case 13:
              sarRatio = [160, 99];
              break;
            case 14:
              sarRatio = [4, 3];
              break;
            case 15:
              sarRatio = [3, 2];
              break;
            case 16:
              sarRatio = [2, 1];
              break;
            case 255: {
              sarRatio = [eg.readUByte() << 8 | eg.readUByte(), eg.readUByte() << 8 | eg.readUByte()];
              break;
            }
          }
        }
        if (eg.readBool())
          eg.readBool();
        if (eg.readBool()) {
          eg.readBits(4);
          if (eg.readBool())
            eg.readBits(24);
        }
        if (eg.readBool()) {
          eg.readUEG();
          eg.readUEG();
        }
        if (eg.readBool()) {
          var numUnitsInTick = eg.readBits(32);
          var timeScale = eg.readBits(32);
          fixedFrame = eg.readBool();
          fpsNum = timeScale;
          fpsDen = numUnitsInTick * 2;
          fps = fpsNum / fpsDen;
        }
      }
      return {
        codec: getAvcCodec(unit.subarray(1, 4)),
        profileIdc,
        profileCompatibility,
        levelIdc,
        chromaFormat,
        width: Math.ceil((picWidthInMbsMinus1 + 1) * 16 - 2 * (frameCropLeftOffset + frameCropRightOffset)),
        height: (2 - frameMbsOnlyFlag) * (picHeightInMapUnitsMinus1 + 1) * 16 - (frameMbsOnlyFlag ? 2 : 4) * (frameCropTopOffset + frameCropBottomOffset),
        sarRatio,
        fpsNum,
        fpsDen,
        fps,
        fixedFrame
      };
    }
  }]);
  return AVC2;
}();

// node_modules/xgplayer-transmuxer/es/codec/hevc.js
var HEVC = /* @__PURE__ */ function() {
  function HEVC2() {
    _classCallCheck3(this, HEVC2);
  }
  _createClass3(HEVC2, null, [{
    key: "parseHEVCDecoderConfigurationRecord",
    value: function parseHEVCDecoderConfigurationRecord(data) {
      var hvcC = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      if (data.length < 23)
        return;
      hvcC = hvcC || {};
      var nalUnitSize = (data[21] & 3) + 1;
      var vpsParsed;
      var spsParsed;
      var spsArr = [];
      var ppsArr = [];
      var vpsArr = [];
      var offset = 23;
      var numOfArrays = data[22];
      var nalUnitType;
      var numNalus;
      var nalSize;
      for (var i = 0; i < numOfArrays; i++) {
        nalUnitType = data[offset] & 63;
        numNalus = data[offset + 1] << 8 | data[offset + 2];
        offset += 3;
        for (var j = 0; j < numNalus; j++) {
          nalSize = data[offset] << 8 | data[offset + 1];
          offset += 2;
          if (!nalSize)
            continue;
          switch (nalUnitType) {
            case 32:
              {
                var vps = data.subarray(offset, offset + nalSize);
                if (!vpsParsed)
                  vpsParsed = HEVC2.parseVPS(NALu.removeEPB(vps), hvcC);
                vpsArr.push(vps);
              }
              break;
            case 33:
              {
                var sps = data.subarray(offset, offset + nalSize);
                if (!spsParsed)
                  spsParsed = HEVC2.parseSPS(NALu.removeEPB(sps), hvcC);
                spsArr.push(sps);
              }
              break;
            case 34:
              ppsArr.push(data.subarray(offset, offset + nalSize));
              break;
          }
          offset += nalSize;
        }
      }
      return {
        hvcC,
        sps: spsParsed,
        spsArr,
        ppsArr,
        vpsArr,
        nalUnitSize
      };
    }
  }, {
    key: "parseVPS",
    value: function parseVPS(unit, hvcC) {
      hvcC = hvcC || {};
      var eg = new ExpGolomb(unit);
      eg.readUByte();
      eg.readUByte();
      eg.readBits(12);
      var vpsMaxSubLayersMinus1 = eg.readBits(3);
      hvcC.numTemporalLayers = Math.max(hvcC.numTemporalLayers || 0, vpsMaxSubLayersMinus1 + 1);
      eg.readBits(17);
      HEVC2._parseProfileTierLevel(eg, vpsMaxSubLayersMinus1, hvcC);
      return hvcC;
    }
  }, {
    key: "parseSPS",
    value: function parseSPS(unit) {
      var hvcC = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      hvcC = hvcC || {};
      var eg = new ExpGolomb(unit);
      eg.readUByte();
      eg.readUByte();
      eg.readBits(4);
      var spsMaxSubLayersMinus1 = eg.readBits(3);
      hvcC.numTemporalLayers = Math.max(spsMaxSubLayersMinus1 + 1, hvcC.numTemporalLayers || 0);
      hvcC.temporalIdNested = eg.readBits(1);
      HEVC2._parseProfileTierLevel(eg, spsMaxSubLayersMinus1, hvcC);
      eg.readUEG();
      var chromaFormatIdc = hvcC.chromaFormatIdc = eg.readUEG();
      var chromaFormat = 420;
      if (chromaFormatIdc <= 3)
        chromaFormat = [0, 420, 422, 444][chromaFormatIdc];
      var separateColourPlaneFlag = 0;
      if (chromaFormatIdc === 3) {
        separateColourPlaneFlag = eg.readBits(1);
      }
      var width = eg.readUEG();
      var height = eg.readUEG();
      var conformanceWindowFlag = eg.readBits(1);
      var confWinLeftOffset;
      var confWinRightOffset;
      var confWinTopOffset;
      var confWinBottomOffset;
      if (conformanceWindowFlag === 1) {
        confWinLeftOffset = eg.readUEG();
        confWinRightOffset = eg.readUEG();
        confWinTopOffset = eg.readUEG();
        confWinBottomOffset = eg.readUEG();
      }
      hvcC.bitDepthLumaMinus8 = eg.readUEG();
      hvcC.bitDepthChromaMinus8 = eg.readUEG();
      if (conformanceWindowFlag === 1) {
        var subWidthC = (chromaFormatIdc === 1 || chromaFormatIdc === 2) && separateColourPlaneFlag === 0 ? 2 : 1;
        var subHeightC = chromaFormatIdc === 1 && separateColourPlaneFlag === 0 ? 2 : 1;
        width -= subWidthC * (confWinRightOffset + confWinLeftOffset);
        height -= subHeightC * (confWinBottomOffset + confWinTopOffset);
      }
      return {
        codec: "hev1.1.6.L93.B0",
        width,
        height,
        chromaFormat,
        hvcC
      };
    }
  }, {
    key: "_parseProfileTierLevel",
    value: function _parseProfileTierLevel(eg, maxSubLayersMinus1, hvcC) {
      var generalTierFlag = hvcC.generalTierFlag || 0;
      hvcC.generalProfileSpace = eg.readBits(2);
      hvcC.generalTierFlag = Math.max(eg.readBits(1), generalTierFlag);
      hvcC.generalProfileIdc = Math.max(eg.readBits(5), hvcC.generalProfileIdc || 0);
      hvcC.generalProfileCompatibilityFlags = eg.readBits(32);
      hvcC.generalConstraintIndicatorFlags = [eg.readBits(8), eg.readBits(8), eg.readBits(8), eg.readBits(8), eg.readBits(8), eg.readBits(8)];
      var generalLevelIdc = eg.readBits(8);
      if (generalTierFlag < hvcC.generalTierFlag) {
        hvcC.generalLevelIdc = generalLevelIdc;
      } else {
        hvcC.generalLevelIdc = Math.max(generalLevelIdc, hvcC.generalLevelIdc || 0);
      }
      var subLayerProfilePresentFlag = [];
      var subLayerLevelPresentFlag = [];
      if (maxSubLayersMinus1 > eg.bitsAvailable) {
        throw new Error("maxSubLayersMinus inavlid size ".concat(maxSubLayersMinus1));
      }
      for (var j = 0; j < maxSubLayersMinus1; j++) {
        subLayerProfilePresentFlag[j] = eg.readBits(1);
        subLayerLevelPresentFlag[j] = eg.readBits(1);
      }
      if (maxSubLayersMinus1 > 0) {
        eg.readBits((8 - maxSubLayersMinus1) * 2);
      }
      for (var i = 0; i < maxSubLayersMinus1; i++) {
        if (subLayerProfilePresentFlag[i] !== 0) {
          eg.readBits(2);
          eg.readBits(1);
          eg.readBits(5);
          eg.readBits(16);
          eg.readBits(16);
          eg.readBits(4);
          eg.readBits(16);
          eg.readBits(16);
          eg.readBits(12);
        }
        if (subLayerLevelPresentFlag[i] !== 0) {
          eg.readBits(8);
        }
      }
    }
  }]);
  return HEVC2;
}();

// node_modules/xgplayer-transmuxer/es/utils/utf8.js
var UTF8 = /* @__PURE__ */ function() {
  function UTF82() {
    _classCallCheck3(this, UTF82);
  }
  _createClass3(UTF82, null, [{
    key: "decode",
    value: function decode(uint8array) {
      var out = [];
      var input = uint8array;
      var i = 0;
      var length = uint8array.length;
      while (i < length) {
        if (input[i] < 128) {
          out.push(String.fromCharCode(input[i]));
          ++i;
          continue;
        } else if (input[i] < 192)
          ;
        else if (input[i] < 224) {
          if (UTF82._checkContinuation(input, i, 1)) {
            var ucs4 = (input[i] & 31) << 6 | input[i + 1] & 63;
            if (ucs4 >= 128) {
              out.push(String.fromCharCode(ucs4 & 65535));
              i += 2;
              continue;
            }
          }
        } else if (input[i] < 240) {
          if (UTF82._checkContinuation(input, i, 2)) {
            var _ucs = (input[i] & 15) << 12 | (input[i + 1] & 63) << 6 | input[i + 2] & 63;
            if (_ucs >= 2048 && (_ucs & 63488) !== 55296) {
              out.push(String.fromCharCode(_ucs & 65535));
              i += 3;
              continue;
            }
          }
        } else if (input[i] < 248) {
          if (UTF82._checkContinuation(input, i, 3)) {
            var _ucs2 = (input[i] & 7) << 18 | (input[i + 1] & 63) << 12 | (input[i + 2] & 63) << 6 | input[i + 3] & 63;
            if (_ucs2 > 65536 && _ucs2 < 1114112) {
              _ucs2 -= 65536;
              out.push(String.fromCharCode(_ucs2 >>> 10 | 55296));
              out.push(String.fromCharCode(_ucs2 & 1023 | 56320));
              i += 4;
              continue;
            }
          }
        }
        out.push(String.fromCharCode(65533));
        ++i;
      }
      return out.join("");
    }
  }, {
    key: "_checkContinuation",
    value: function _checkContinuation(uint8array, start, checkLength) {
      var array = uint8array;
      if (start + checkLength < array.length) {
        while (checkLength--) {
          if ((array[++start] & 192) !== 128) {
            return false;
          }
        }
        return true;
      } else {
        return false;
      }
    }
  }]);
  return UTF82;
}();

// node_modules/xgplayer-transmuxer/es/flv/amf.js
var AMF = /* @__PURE__ */ function() {
  function AMF2() {
    _classCallCheck3(this, AMF2);
  }
  _createClass3(AMF2, null, [{
    key: "parse",
    value: function parse3(data) {
      if (data.length < 3)
        return;
      var ret = {};
      var name = AMF2._parseValue(new DataView(data.buffer, data.byteOffset, data.byteLength));
      var value = AMF2._parseValue(new DataView(data.buffer, data.byteOffset + name.size, data.byteLength - name.size));
      ret[name.data] = value.data;
      return ret;
    }
  }, {
    key: "_parseValue",
    value: function _parseValue(view) {
      var dataLen = view.byteLength;
      var type = view.getUint8(0);
      var offset = 1;
      var isEnd = false;
      var value;
      switch (type) {
        case 0:
          value = view.getFloat64(1);
          offset += 8;
          break;
        case 1: {
          value = !!view.getUint8(1);
          offset += 1;
          break;
        }
        case 2:
          {
            var _AMF$_parseString = AMF2._parseString(new DataView(view.buffer, view.byteOffset + offset, view.byteLength - offset)), data = _AMF$_parseString.data, size = _AMF$_parseString.size;
            value = data;
            offset += size;
          }
          break;
        case 3:
          {
            value = {};
            var terminal = 0;
            if ((view.getUint32(dataLen - 4) & 16777215) === 9) {
              terminal = 3;
            }
            while (offset < dataLen - 4) {
              var _AMF$_parseObject = AMF2._parseObject(new DataView(view.buffer, view.byteOffset + offset, view.byteLength - offset - terminal)), _size = _AMF$_parseObject.size, _data = _AMF$_parseObject.data, _isEnd = _AMF$_parseObject.isEnd;
              if (_isEnd)
                break;
              value[_data.name] = _data.value;
              offset += _size;
            }
            if (offset <= dataLen - 3) {
              var marker = view.getUint32(offset - 1) & 16777215;
              if (marker === 9)
                offset += 3;
            }
          }
          break;
        case 8:
          {
            value = {};
            offset += 4;
            var _terminal = 0;
            if ((view.getUint32(dataLen - 4) & 16777215) === 9) {
              _terminal = 3;
            }
            while (offset < dataLen - 8) {
              var _AMF$_parseObject2 = AMF2._parseObject(new DataView(view.buffer, view.byteOffset + offset, view.byteLength - offset - _terminal)), _size2 = _AMF$_parseObject2.size, _data2 = _AMF$_parseObject2.data, _isEnd2 = _AMF$_parseObject2.isEnd;
              if (_isEnd2)
                break;
              value[_data2.name] = _data2.value;
              offset += _size2;
            }
            if (offset <= dataLen - 3) {
              var _marker = view.getUint32(offset - 1) & 16777215;
              if (_marker === 9) {
                offset += 3;
              }
            }
          }
          break;
        case 9:
          value = void 0;
          offset = 1;
          isEnd = true;
          break;
        case 10:
          {
            value = [];
            var strictArrayLength = view.getUint32(1);
            offset += 4;
            for (var i = 0; i < strictArrayLength; i++) {
              var _AMF$_parseValue = AMF2._parseValue(new DataView(view.buffer, view.byteOffset + offset, view.byteLength - offset)), _data3 = _AMF$_parseValue.data, _size3 = _AMF$_parseValue.size;
              value.push(_data3);
              offset += _size3;
            }
          }
          break;
        case 11:
          {
            var timestamp = view.getFloat64(offset) + view.getInt16(offset + 8) * 6e4;
            value = new Date(timestamp);
            offset += 10;
          }
          break;
        case 12:
          {
            var length = view.getUint32(1);
            offset += 4;
            value = "";
            if (length > 0) {
              value = UTF8.decode(new Uint8Array(view.buffer, view.byteOffset + offset, length));
            }
            offset += length;
          }
          break;
        default:
          offset = dataLen;
          break;
      }
      return {
        data: value,
        size: offset,
        isEnd
      };
    }
  }, {
    key: "_parseString",
    value: function _parseString(view) {
      var length = view.getUint16(0);
      var data = "";
      if (length > 0) {
        data = UTF8.decode(new Uint8Array(view.buffer, view.byteOffset + 2, length));
      }
      return {
        data,
        size: 2 + length
      };
    }
  }, {
    key: "_parseObject",
    value: function _parseObject(view) {
      if (view.byteLength < 3)
        return;
      var name = AMF2._parseString(view);
      var value = AMF2._parseValue(new DataView(view.buffer, view.byteOffset + name.size, view.byteLength - name.size));
      return {
        data: {
          name: name.data,
          value: value.data
        },
        size: name.size + value.size,
        isEnd: value.isEnd
      };
    }
  }]);
  return AMF2;
}();

// node_modules/xgplayer-transmuxer/es/flv/soundFormat.js
var FlvSoundFormat = {
  MP3: 2,
  G711A: 7,
  G711M: 8,
  AAC: 10,
  OPUS: 13
};

// node_modules/xgplayer-transmuxer/es/flv/index.js
var logger = new Logger2("FlvDemuxer");
var FlvDemuxer = /* @__PURE__ */ function() {
  function FlvDemuxer2(videoTrack, audioTrack, metadataTrack) {
    _classCallCheck3(this, FlvDemuxer2);
    _defineProperty3(this, "_headerParsed", false);
    _defineProperty3(this, "_remainingData", null);
    _defineProperty3(this, "_gopId", 0);
    _defineProperty3(this, "_needAddMetaBeforeKeyFrameNal", true);
    this.videoTrack = videoTrack || new VideoTrack();
    this.audioTrack = audioTrack || new AudioTrack();
    this.metadataTrack = metadataTrack || new MetadataTrack();
    this._fixer = new FlvFixer(this.videoTrack, this.audioTrack, this.metadataTrack);
  }
  _createClass3(FlvDemuxer2, [{
    key: "demux",
    value: function demux(data) {
      var _scriptDataObject$dat;
      var discontinuity = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
      var contiguous = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : true;
      var seamlessLoadingSwitching = arguments.length > 3 ? arguments[3] : void 0;
      var audioTrack = this.audioTrack, videoTrack = this.videoTrack, metadataTrack = this.metadataTrack;
      if (discontinuity || !contiguous) {
        this._remainingData = null;
      }
      if (discontinuity) {
        this._headerParsed = false;
      }
      if (discontinuity) {
        videoTrack.reset();
        audioTrack.reset();
        metadataTrack.reset();
      } else {
        videoTrack.samples = [];
        audioTrack.samples = [];
        metadataTrack.seiSamples = [];
        metadataTrack.flvScriptSamples = [];
        videoTrack.warnings = [];
        audioTrack.warnings = [];
        if (this._remainingData) {
          data = concatUint8Array2(this._remainingData, data);
          this._remainingData = null;
        }
      }
      if (!data.length) {
        return {
          videoTrack,
          audioTrack,
          metadataTrack
        };
      }
      var offset = 0;
      if (!this._headerParsed) {
        if (!FlvDemuxer2.probe(data)) {
          throw new Error("Invalid flv file");
        }
        audioTrack.present = (data[4] & 4) >>> 2 !== 0;
        videoTrack.present = (data[4] & 1) !== 0;
        this._headerParsed = true;
        offset = readBig32(data, 5) + 4;
      }
      var dataLen = data.length;
      var tagType;
      var dataSize;
      var timestamp;
      var bodyData;
      var prevTagSize;
      while (offset + 15 < dataLen) {
        tagType = data[offset];
        dataSize = data[offset + 1] << 16 | data[offset + 2] << 8 | data[offset + 3];
        if (offset + 15 + dataSize > dataLen)
          break;
        timestamp = (data[offset + 7] << 24 >>> 0) + (data[offset + 4] << 16) + (data[offset + 5] << 8) + data[offset + 6];
        offset += 11;
        bodyData = data.subarray(offset, offset + dataSize);
        if (tagType === 8) {
          this._parseAudio(bodyData, timestamp);
        } else if (tagType === 9) {
          if (seamlessLoadingSwitching)
            this.seamlessLoadingSwitching = true;
          this._parseVideo(bodyData, timestamp);
        } else if (tagType === 18) {
          this._parseScript(bodyData, timestamp);
        } else {
          logger.warn("Invalid tag type: ".concat(tagType));
        }
        offset += dataSize;
        prevTagSize = readBig32(data, offset);
        if (prevTagSize !== 11 + dataSize) {
          logger.warn("Invalid PrevTagSize ".concat(prevTagSize, " (").concat(11 + dataSize, ")"));
        }
        offset += 4;
      }
      if (offset < dataLen) {
        this._remainingData = data.subarray(offset);
      }
      audioTrack.formatTimescale = videoTrack.formatTimescale = videoTrack.timescale = metadataTrack.timescale = 1e3;
      audioTrack.timescale = audioTrack.codecType === AudioCodecType.OPUS ? 1e3 : audioTrack.sampleRate || 0;
      if (!audioTrack.exist() && audioTrack.hasSample()) {
        audioTrack.reset();
      }
      if (!videoTrack.exist() && videoTrack.hasSample()) {
        videoTrack.reset();
      }
      var scriptDataObject = metadataTrack.flvScriptSamples[metadataTrack.flvScriptSamples.length - 1];
      var metaData = scriptDataObject === null || scriptDataObject === void 0 ? void 0 : (_scriptDataObject$dat = scriptDataObject.data) === null || _scriptDataObject$dat === void 0 ? void 0 : _scriptDataObject$dat.onMetaData;
      if (metaData) {
        if (videoTrack !== null && videoTrack !== void 0 && videoTrack.exist()) {
          if (metaData.hasOwnProperty("duration")) {
            videoTrack.duration = metaData.duration * 1e3;
          }
          if (metaData.hasOwnProperty("width") && metaData.hasOwnProperty("height")) {
            videoTrack.width = metaData.width;
            videoTrack.height = metaData.height;
          }
        }
        if (audioTrack !== null && audioTrack !== void 0 && audioTrack.exist()) {
          if (metaData.hasOwnProperty("duration")) {
            audioTrack.duration = metaData.duration * 1e3;
          }
        }
      }
      return {
        videoTrack,
        audioTrack,
        metadataTrack
      };
    }
  }, {
    key: "fix",
    value: function fix(startTime, discontinuity, contiguous) {
      this._fixer.fix(startTime, discontinuity, contiguous);
      return {
        videoTrack: this.videoTrack,
        audioTrack: this.audioTrack,
        metadataTrack: this.metadataTrack
      };
    }
  }, {
    key: "demuxAndFix",
    value: function demuxAndFix(data, discontinuity, contiguous, startTime, seamlessLoadingSwitching) {
      this.demux(data, discontinuity, contiguous, seamlessLoadingSwitching);
      return this.fix(startTime, discontinuity, contiguous);
    }
  }, {
    key: "_parseAudio",
    value: function _parseAudio(data, pts) {
      if (!data.length)
        return;
      var format = (data[0] & 240) >>> 4;
      var track = this.audioTrack;
      if (format !== FlvSoundFormat.AAC && format !== FlvSoundFormat.G711A && format !== FlvSoundFormat.G711M && format !== FlvSoundFormat.OPUS) {
        logger.warn("Unsupported sound format: ".concat(format));
        track.reset();
        return;
      }
      if (format !== FlvSoundFormat.AAC && format !== FlvSoundFormat.OPUS) {
        var soundRate = (data[0] & 12) >> 2;
        var soundSize = (data[0] & 2) >> 1;
        var soundType = data[0] & 1;
        track.sampleRate = FlvDemuxer2.AUDIO_RATE[soundRate];
        track.sampleSize = soundSize ? 16 : 8;
        track.channelCount = soundType + 1;
      }
      switch (format) {
        case FlvSoundFormat.G711A:
        case FlvSoundFormat.G711M:
          this._parseG711(data, pts, format);
          break;
        case FlvSoundFormat.AAC:
          this._parseAac(data, pts);
          break;
        case FlvSoundFormat.OPUS:
          this._parseOpus(data, pts);
          break;
      }
    }
  }, {
    key: "_parseOpus",
    value: function _parseOpus(data, pts) {
      var track = this.audioTrack;
      var packetType = data[1];
      track.codecType = AudioCodecType.OPUS;
      switch (packetType) {
        case 0: {
          var ret = OPUS.parseHeaderPackets(data.subarray(2));
          if (ret) {
            track.codec = ret.codec;
            track.channelCount = ret.channelCount;
            track.sampleRate = ret.sampleRate;
            track.config = ret.config;
            track.sampleDuration = OPUS.getFrameDuration([], track.timescale);
          } else {
            track.reset();
            logger.warn("Cannot parse AudioSpecificConfig", data);
          }
          break;
        }
        case 1: {
          if (pts === void 0 || pts === null)
            return;
          var newSample = new AudioSample(pts, data.subarray(2), track.sampleDuration);
          track.samples.push(newSample);
          break;
        }
        default:
          logger.warn("Unknown OpusPacketType: ".concat(packetType));
      }
    }
  }, {
    key: "_parseG711",
    value: function _parseG711(data, pts, format) {
      var track = this.audioTrack;
      var audioData = data.subarray(1);
      if (audioData.byteLength < 1)
        return;
      var sample = new AudioSample(pts, audioData);
      track.codecType = format === 7 ? AudioCodecType.G711PCMA : AudioCodecType.G711PCMU;
      track.sampleRate = 8e3;
      track.codec = track.codecType;
      track.samples.push(sample);
    }
  }, {
    key: "_parseAac",
    value: function _parseAac(data, pts) {
      var track = this.audioTrack;
      track.codecType = AudioCodecType.AAC;
      if (data[1] === 0) {
        var ret = AAC.parseAudioSpecificConfig(data.subarray(2));
        if (ret) {
          track.codec = ret.codec;
          track.channelCount = ret.channelCount;
          track.sampleRate = ret.sampleRate;
          track.config = ret.config;
          track.objectType = ret.objectType;
          track.sampleRateIndex = ret.samplingFrequencyIndex;
        } else {
          track.reset();
          logger.warn("Cannot parse AudioSpecificConfig", data);
        }
      } else if (data[1] === 1) {
        if (pts === void 0 || pts === null)
          return;
        track.samples.push(new AudioSample(pts, data.subarray(2)));
      } else {
        logger.warn("Unknown AACPacketType: ".concat(data[1]));
      }
    }
  }, {
    key: "_parseVideo",
    value: function _parseVideo(data, dts) {
      var _this = this;
      if (data.length < 6)
        return;
      var frameType = (data[0] & 240) >>> 4;
      var codecId = data[0] & 15;
      var track = this.videoTrack;
      if (codecId !== 7 && codecId !== 12) {
        track.reset();
        logger.warn("Unsupported codecId: ".concat(codecId));
        return;
      }
      var isHevc = codecId === 12;
      track.codecType = isHevc ? VideoCodecType.HEVC : VideoCodecType.AVC;
      var packetType = data[1];
      var cts = (data[2] << 16 | data[3] << 8 | data[4]) << 8 >> 8;
      if (packetType === 0) {
        var configData = data.subarray(5);
        var ret = isHevc ? HEVC.parseHEVCDecoderConfigurationRecord(configData) : AVC.parseAVCDecoderConfigurationRecord(configData);
        if (ret) {
          var hvcC = ret.hvcC, sps = ret.sps, ppsArr = ret.ppsArr, spsArr = ret.spsArr, vpsArr = ret.vpsArr, nalUnitSize = ret.nalUnitSize;
          if (hvcC) {
            track.hvcC = track.hvcC || hvcC;
          }
          if (sps) {
            track.codec = sps.codec;
            track.width = sps.width;
            track.height = sps.height;
            track.sarRatio = sps.sarRatio;
            track.fpsNum = sps.fpsNum;
            track.fpsDen = sps.fpsDen;
          }
          if (spsArr.length)
            track.sps = spsArr;
          if (ppsArr.length)
            track.pps = ppsArr;
          if (vpsArr && vpsArr.length)
            track.vps = vpsArr;
          if (nalUnitSize)
            track.nalUnitSize = nalUnitSize;
        } else {
          logger.warn("Cannot parse ".concat(isHevc ? "HEVC" : "AVC", "DecoderConfigurationRecord"), data);
        }
      } else if (packetType === 1) {
        var units = NALu.parseAvcC(data.subarray(5), track.nalUnitSize);
        units = this._checkAddMetaNalToUnits(isHevc, units, track);
        if (units && units.length) {
          var sample = new VideoSample(dts + cts, dts, units);
          if (this.seamlessLoadingSwitching && dts < track.lastKeyFrameDts) {
            return;
          }
          this.seamlessLoadingSwitching = false;
          if (frameType === 1) {
            sample.setToKeyframe();
            track.lastKeyFrameDts = dts;
          }
          track.samples.push(sample);
          units.forEach(function(unit) {
            var type = isHevc ? unit[0] >>> 1 & 63 : unit[0] & 31;
            switch (type) {
              case 5:
              case 16:
              case 17:
              case 18:
              case 19:
              case 20:
              case 21:
              case 22:
              case 23:
                if (!isHevc && type !== 5 || isHevc && type === 5)
                  break;
                sample.setToKeyframe();
                break;
              case 6:
              case 39:
              case 40:
                if (!isHevc && type !== 6 || isHevc && type === 6)
                  break;
                _this.metadataTrack.seiSamples.push(new SeiSample(NALu.parseSEI(NALu.removeEPB(unit), isHevc), dts + cts));
                break;
            }
          });
          if (sample.keyframe) {
            this._gopId++;
          }
          sample.gopId = this._gopId;
        } else {
          logger.warn("Cannot parse NALUs", data);
        }
      } else if (packetType === 2)
        ;
      else {
        logger.warn("Unknown AVCPacketType: ".concat(packetType));
      }
    }
  }, {
    key: "_checkAddMetaNalToUnits",
    value: function _checkAddMetaNalToUnits(hevc, units, track) {
      if (!hevc || !this._needAddMetaBeforeKeyFrameNal) {
        this._needAddMetaBeforeKeyFrameNal = false;
        return units;
      }
      var nalTypes = units.map(function(x) {
        return x[0] >>> 1 & 63;
      });
      if (nalTypes.includes(32)) {
        this._needAddMetaBeforeKeyFrameNal = false;
        return units;
      }
      units.unshift(track.pps[0]);
      units.unshift(track.sps[0]);
      units.unshift(track.vps[0]);
      return units.filter(Boolean);
    }
  }, {
    key: "_parseScript",
    value: function _parseScript(data, pts) {
      this.metadataTrack.flvScriptSamples.push(new FlvScriptSample(AMF.parse(data), pts));
    }
  }], [{
    key: "probe",
    value: function probe(data) {
      if (data[0] !== 70 || data[1] !== 76 || data[2] !== 86 || data[3] !== 1) {
        return false;
      }
      return readBig32(data, 5) >= 9;
    }
  }]);
  return FlvDemuxer2;
}();
_defineProperty3(FlvDemuxer, "AUDIO_RATE", [5500, 11e3, 22e3, 44e3]);

// node_modules/xgplayer-transmuxer/es/mp4/buffer.js
function Concat(ResultConstructor) {
  var totalLength = 0;
  for (var _len = arguments.length, arrays = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    arrays[_key - 1] = arguments[_key];
  }
  arrays.forEach(function(arr) {
    totalLength += arr.length;
  });
  var result = new ResultConstructor(totalLength);
  var offset = 0;
  arrays.forEach(function(arr) {
    result.set(arr, offset);
    offset += arr.length;
  });
  return result;
}
var Buffer3 = /* @__PURE__ */ function() {
  function Buffer22() {
    _classCallCheck3(this, Buffer22);
    this.buffer = new Uint8Array(0);
  }
  _createClass3(Buffer22, [{
    key: "write",
    value: function write() {
      var self2 = this;
      for (var _len2 = arguments.length, buffer = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        buffer[_key2] = arguments[_key2];
      }
      buffer.forEach(function(item) {
        if (item) {
          self2.buffer = Concat(Uint8Array, self2.buffer, item);
        } else {
          window.console.warn(item);
        }
      });
    }
  }], [{
    key: "writeUint16",
    value: function writeUint16(value) {
      return new Uint8Array([value >> 8 & 255, value & 255]);
    }
  }, {
    key: "writeUint32",
    value: function writeUint32(value) {
      return new Uint8Array([value >> 24, value >> 16 & 255, value >> 8 & 255, value & 255]);
    }
  }]);
  return Buffer22;
}();

// node_modules/xgplayer-transmuxer/es/mp4/mp4.js
var UINT32_MAX = Math.pow(2, 32) - 1;
var MP4 = /* @__PURE__ */ function() {
  function MP42() {
    _classCallCheck3(this, MP42);
  }
  _createClass3(MP42, null, [{
    key: "box",
    value: function box(type) {
      for (var _len = arguments.length, payload = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        payload[_key - 1] = arguments[_key];
      }
      payload = payload.filter(Boolean);
      var size = 8 + payload.reduce(function(p, c) {
        return p + c.byteLength;
      }, 0);
      var ret = new Uint8Array(size);
      ret[0] = size >> 24 & 255;
      ret[1] = size >> 16 & 255;
      ret[2] = size >> 8 & 255;
      ret[3] = size & 255;
      ret.set(type, 4);
      var offset = 8;
      payload.forEach(function(data) {
        ret.set(data, offset);
        offset += data.byteLength;
      });
      return ret;
    }
  }, {
    key: "ftyp",
    value: function ftyp(tracks) {
      var isHevc = tracks.find(function(t) {
        return t.type === TrackType.VIDEO && t.codecType === VideoCodecType.HEVC;
      });
      return isHevc ? MP42.FTYPHEV1 : MP42.FTYPAVC1;
    }
  }, {
    key: "initSegment",
    value: function initSegment(tracks) {
      var ftyp = MP42.ftyp(tracks);
      var init = concatUint8Array2(ftyp, MP42.moov(tracks));
      return init;
    }
  }, {
    key: "pssh",
    value: function pssh(data) {
      var content = new Uint8Array([
        1,
        0,
        0,
        0
      ].concat([16, 119, 239, 236, 192, 178, 77, 2, 172, 227, 60, 30, 82, 226, 251, 75], [0, 0, 0, 1], parse2(data.kid), [0, 0, 0, 0]));
      return MP42.box(MP42.types.pssh, content);
    }
  }, {
    key: "moov",
    value: function moov(tracks) {
      if (tracks[0].useEME && (tracks[0].encv || tracks[0].enca)) {
        if (!tracks[0].pssh) {
          tracks[0].pssh = {
            kid: tracks[0].kid
          };
        }
        var pssh = this.pssh(tracks[0].pssh);
        return MP42.box.apply(MP42, [MP42.types.moov, MP42.mvhd(tracks[0].mvhdDurtion || tracks[0].duration, tracks[0].mvhdTimecale || tracks[0].timescale), MP42.mvex(tracks)].concat(_toConsumableArray(tracks.map(function(t) {
          return MP42.trak(t);
        })), [pssh]));
      } else {
        return MP42.box.apply(MP42, [MP42.types.moov, MP42.mvhd(tracks[0].mvhdDurtion || tracks[0].duration, tracks[0].mvhdTimecale || tracks[0].timescale)].concat(_toConsumableArray(tracks.map(function(t) {
          return MP42.trak(t);
        })), [MP42.mvex(tracks)]));
      }
    }
  }, {
    key: "mvhd",
    value: function mvhd(duration) {
      var timescale = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 9e4;
      var mvhd2 = MP42.box(MP42.types.mvhd, new Uint8Array([
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        timescale >> 24 & 255,
        timescale >> 16 & 255,
        timescale >> 8 & 255,
        timescale & 255,
        duration >> 24 & 255,
        duration >> 16 & 255,
        duration >> 8 & 255,
        duration & 255,
        0,
        1,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        64,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        255,
        255,
        255,
        255
      ]));
      return mvhd2;
    }
  }, {
    key: "trak",
    value: function trak(track) {
      var trak2 = MP42.box(MP42.types.trak, MP42.tkhd(track.id, track.tkhdDuration || 0, track.width, track.height), MP42.mdia(track));
      return trak2;
    }
  }, {
    key: "tkhd",
    value: function tkhd(id, duration) {
      var width = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
      var height = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0;
      var tkhd2 = MP42.box(MP42.types.tkhd, new Uint8Array([
        0,
        0,
        0,
        7,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        id >> 24 & 255,
        id >> 16 & 255,
        id >> 8 & 255,
        id & 255,
        0,
        0,
        0,
        0,
        duration >> 24 & 255,
        duration >> 16 & 255,
        duration >> 8 & 255,
        duration & 255,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        64,
        0,
        0,
        0,
        width >> 8 & 255,
        width & 255,
        0,
        0,
        height >> 8 & 255,
        height & 255,
        0,
        0
      ]));
      return tkhd2;
    }
  }, {
    key: "mdia",
    value: function mdia(track) {
      var mdia2 = MP42.box(MP42.types.mdia, MP42.mdhd(track.duration, track.timescale), MP42.hdlr(track.type), MP42.minf(track));
      return mdia2;
    }
  }, {
    key: "mdhd",
    value: function mdhd(duration) {
      var timescale = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 9e4;
      var mdhd2 = MP42.box(MP42.types.mdhd, new Uint8Array([
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        timescale >> 24 & 255,
        timescale >> 16 & 255,
        timescale >> 8 & 255,
        timescale & 255,
        duration >> 24 & 255,
        duration >> 16 & 255,
        duration >> 8 & 255,
        duration & 255,
        85,
        196,
        0,
        0
      ]));
      return mdhd2;
    }
  }, {
    key: "hdlr",
    value: function hdlr(type) {
      var hdlr2 = MP42.box(MP42.types.hdlr, MP42.HDLR_TYPES[type]);
      return hdlr2;
    }
  }, {
    key: "minf",
    value: function minf(track) {
      var minf2 = MP42.box(MP42.types.minf, track.type === TrackType.VIDEO ? MP42.VMHD : MP42.SMHD, MP42.DINF, MP42.stbl(track));
      return minf2;
    }
  }, {
    key: "stbl",
    value: function stbl(track) {
      var extBox = [];
      if (track && track.ext) {
        track.ext.stss && extBox.push(MP42.stss(track.ext.stss.entries));
      }
      var stbl2 = MP42.box(MP42.types.stbl, MP42.stsd(track), MP42.STTS, extBox[0], MP42.STSC, MP42.STSZ, MP42.STCO);
      return stbl2;
    }
  }, {
    key: "stsd",
    value: function stsd(track) {
      var content;
      if (track.type === "audio") {
        if (track.useEME && track.enca) {
          content = MP42.enca(track);
        } else {
          if (track.codecType === AudioCodecType.OPUS) {
            content = MP42.opus(track);
          } else {
            content = MP42.mp4a(track);
          }
        }
      } else if (track.useEME && track.encv) {
        content = MP42.encv(track);
      } else if (track.av1C) {
        content = MP42.av01(track);
      } else {
        content = MP42.avc1hev1(track);
      }
      var stsd2 = MP42.box(MP42.types.stsd, new Uint8Array([
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        1
      ]), content);
      return stsd2;
    }
  }, {
    key: "enca",
    value: function enca(data) {
      var channelCount = data.enca.channelCount;
      var sampleRate = data.enca.sampleRate;
      var content = new Uint8Array([
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        channelCount,
        0,
        16,
        0,
        0,
        0,
        0,
        sampleRate >> 8 & 255,
        sampleRate & 255,
        0,
        0
      ]);
      var esds = MP42.esds(data.config);
      var sinf = MP42.sinf(data.enca);
      return MP42.box(MP42.types.enca, content, esds, sinf);
    }
  }, {
    key: "encv",
    value: function encv(track) {
      var _concat$concat, _ref;
      var sps = track.sps.length > 0 ? track.sps[0] : [];
      var pps = track.pps.length > 0 ? track.pps[0] : [];
      var width = track.width;
      var height = track.height;
      var hSpacing = track.sarRatio[0];
      var vSpacing = track.sarRatio[1];
      var content = new Uint8Array([
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        width >> 8 & 255,
        width & 255,
        height >> 8 & 255,
        height & 255,
        0,
        72,
        0,
        0,
        0,
        72,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        1,
        18,
        100,
        97,
        105,
        108,
        121,
        109,
        111,
        116,
        105,
        111,
        110,
        47,
        104,
        108,
        115,
        46,
        106,
        115,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        24,
        17,
        17
      ]);
      var avcc = new Uint8Array((_concat$concat = (_ref = [
        1,
        sps[1],
        sps[2],
        sps[3],
        252 | 3,
        224 | 1,
        sps.length >>> 8 & 255,
        sps.length & 255
      ]).concat.apply(_ref, _toConsumableArray(sps)).concat([1, pps.length >>> 8 & 255, pps.length & 255])).concat.apply(_concat$concat, _toConsumableArray(pps)));
      var btrt = new Uint8Array([0, 0, 88, 57, 0, 15, 200, 192, 0, 4, 86, 72]);
      var sinf = MP42.sinf(track.encv);
      var pasp = new Uint8Array([
        hSpacing >> 24,
        hSpacing >> 16 & 255,
        hSpacing >> 8 & 255,
        hSpacing & 255,
        vSpacing >> 24,
        vSpacing >> 16 & 255,
        vSpacing >> 8 & 255,
        vSpacing & 255
      ]);
      return MP42.box(MP42.types.encv, content, MP42.box(MP42.types.avcC, avcc), MP42.box(MP42.types.btrt, btrt), sinf, MP42.box(MP42.types.pasp, pasp));
    }
  }, {
    key: "schi",
    value: function schi(data) {
      var content = new Uint8Array([]);
      var tenc = MP42.tenc(data);
      return MP42.box(MP42.types.schi, content, tenc);
    }
  }, {
    key: "tenc",
    value: function tenc(data) {
      var content = new Uint8Array([
        0,
        0,
        0,
        0,
        0,
        0,
        data.default_IsEncrypted & 255,
        data.default_IV_size & 255
      ].concat(parse2(data.default_KID)));
      return MP42.box(MP42.types.tenc, content);
    }
  }, {
    key: "sinf",
    value: function sinf(data) {
      var content = new Uint8Array([]);
      var frma = new Uint8Array([data.data_format.charCodeAt(0), data.data_format.charCodeAt(1), data.data_format.charCodeAt(2), data.data_format.charCodeAt(3)]);
      var schm = new Uint8Array([
        0,
        0,
        0,
        0,
        99,
        101,
        110,
        99,
        0,
        1,
        0,
        0
      ]);
      var schi = MP42.schi(data);
      return MP42.box(MP42.types.sinf, content, MP42.box(MP42.types.frma, frma), MP42.box(MP42.types.schm, schm), schi);
    }
  }, {
    key: "av01",
    value: function av01(track) {
      return MP42.box(MP42.types.av01, new Uint8Array([
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        track.width >> 8 & 255,
        track.width & 255,
        track.height >> 8 & 255,
        track.height & 255,
        0,
        72,
        0,
        0,
        0,
        72,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        24,
        17,
        17
      ]), track.av1C, track.colr);
    }
  }, {
    key: "avc1hev1",
    value: function avc1hev1(track) {
      var isHevc = track.codecType === VideoCodecType.HEVC;
      var typ = isHevc ? MP42.types.hvc1 : MP42.types.avc1;
      var config = isHevc ? MP42.hvcC(track) : MP42.avcC(track);
      var boxes = [new Uint8Array([
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        track.width >> 8 & 255,
        track.width & 255,
        track.height >> 8 & 255,
        track.height & 255,
        0,
        72,
        0,
        0,
        0,
        72,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        24,
        17,
        17
      ]), config];
      if (isHevc) {
        boxes.push(MP42.box(MP42.types.fiel, new Uint8Array([1, 0])));
      } else if (track.sarRatio && track.sarRatio.length > 1) {
        boxes.push(MP42.pasp(track.sarRatio));
      }
      return MP42.box.apply(MP42, [typ].concat(boxes));
    }
  }, {
    key: "avcC",
    value: function avcC(track) {
      var _concat$concat2, _ref2;
      var sps = [];
      var pps = [];
      var len;
      track.sps.forEach(function(s) {
        len = s.byteLength;
        sps.push(len >>> 8 & 255);
        sps.push(len & 255);
        sps.push.apply(sps, _toConsumableArray(s));
      });
      track.pps.forEach(function(p) {
        len = p.byteLength;
        pps.push(len >>> 8 & 255);
        pps.push(len & 255);
        pps.push.apply(pps, _toConsumableArray(p));
      });
      return MP42.box(MP42.types.avcC, new Uint8Array((_concat$concat2 = (_ref2 = [
        1,
        sps[3],
        sps[4],
        sps[5],
        252 | 3,
        224 | track.sps.length
      ]).concat.apply(_ref2, sps).concat([track.pps.length])).concat.apply(_concat$concat2, pps)));
    }
  }, {
    key: "hvcC",
    value: function hvcC(track) {
      var hvcC2 = track.hvcC;
      if (hvcC2 instanceof ArrayBuffer || hvcC2 instanceof Uint8Array)
        return hvcC2;
      var vps = track.vps, sps = track.sps, pps = track.pps;
      var data;
      if (hvcC2) {
        var pcf = hvcC2.generalProfileCompatibilityFlags;
        var cif = hvcC2.generalConstraintIndicatorFlags;
        var numOfArrays = (vps.length && 1) + (sps.length && 1) + (pps.length && 1);
        data = [
          1,
          hvcC2.generalProfileSpace << 6 | hvcC2.generalTierFlag << 5 | hvcC2.generalProfileIdc,
          pcf >>> 24,
          pcf >>> 16,
          pcf >>> 8,
          pcf,
          cif[0],
          cif[1],
          cif[2],
          cif[3],
          cif[4],
          cif[5],
          hvcC2.generalLevelIdc,
          240,
          0,
          252,
          hvcC2.chromaFormatIdc | 252,
          hvcC2.bitDepthLumaMinus8 | 248,
          hvcC2.bitDepthChromaMinus8 | 248,
          0,
          0,
          hvcC2.numTemporalLayers << 3 | hvcC2.temporalIdNested << 2 | 3,
          numOfArrays
        ];
        var write = function write2(x) {
          var _data;
          data.push(x.length >> 8, x.length);
          (_data = data).push.apply(_data, _toConsumableArray(x));
        };
        if (vps.length) {
          data.push(160, 0, vps.length);
          vps.forEach(write);
        }
        if (sps.length) {
          data.push(161, 0, sps.length);
          sps.forEach(write);
        }
        if (pps.length) {
          data.push(162, 0, pps.length);
          pps.forEach(write);
        }
      } else {
        data = [
          1,
          1,
          96,
          0,
          0,
          0,
          144,
          0,
          0,
          0,
          0,
          0,
          93,
          240,
          0,
          252,
          253,
          248,
          248,
          0,
          0,
          15,
          3,
          160,
          0,
          1,
          0,
          24,
          64,
          1,
          12,
          1,
          255,
          255,
          1,
          96,
          0,
          0,
          3,
          0,
          144,
          0,
          0,
          3,
          0,
          0,
          3,
          0,
          93,
          153,
          152,
          9,
          161,
          0,
          1,
          0,
          45,
          66,
          1,
          1,
          1,
          96,
          0,
          0,
          3,
          0,
          144,
          0,
          0,
          3,
          0,
          0,
          3,
          0,
          93,
          160,
          2,
          128,
          128,
          45,
          22,
          89,
          153,
          164,
          147,
          43,
          154,
          128,
          128,
          128,
          130,
          0,
          0,
          3,
          0,
          2,
          0,
          0,
          3,
          0,
          50,
          16,
          162,
          0,
          1,
          0,
          7,
          68,
          1,
          193,
          114,
          180,
          98,
          64
        ];
      }
      return MP42.box(MP42.types.hvcC, new Uint8Array(data));
    }
  }, {
    key: "pasp",
    value: function pasp(_ref3) {
      var _ref4 = _slicedToArray(_ref3, 2), hSpacing = _ref4[0], vSpacing = _ref4[1];
      return MP42.box(MP42.types.pasp, new Uint8Array([hSpacing >> 24, hSpacing >> 16 & 255, hSpacing >> 8 & 255, hSpacing & 255, vSpacing >> 24, vSpacing >> 16 & 255, vSpacing >> 8 & 255, vSpacing & 255]));
    }
  }, {
    key: "mp4a",
    value: function mp4a(track) {
      return MP42.box(MP42.types.mp4a, new Uint8Array([
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        track.channelCount,
        0,
        16,
        0,
        0,
        0,
        0,
        track.sampleRate >> 8 & 255,
        track.sampleRate & 255,
        0,
        0
      ]), track.config.length ? MP42.esds(track.config) : void 0);
    }
  }, {
    key: "esds",
    value: function esds(config) {
      var len = config.length;
      var esds2 = MP42.box(MP42.types.esds, new Uint8Array([
        0,
        0,
        0,
        0,
        3,
        23 + len,
        0,
        0,
        0,
        4,
        15 + len,
        64,
        21,
        0,
        6,
        0,
        0,
        0,
        218,
        192,
        0,
        0,
        218,
        192,
        5
      ].concat([len]).concat(config).concat(
        [6, 1, 2]
      )));
      return esds2;
    }
  }, {
    key: "opus",
    value: function opus(track) {
      var opusAudioDescription = new Uint8Array([
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        track.channelCount,
        0,
        16,
        0,
        0,
        0,
        0,
        track.sampleRate >> 8 & 255,
        track.sampleRate & 255,
        0,
        0
      ]);
      var opusSpecificConfig = track.config.length ? MP42.dOps(track) : [];
      return MP42.box(MP42.types.Opus, opusAudioDescription, opusSpecificConfig);
    }
  }, {
    key: "dOps",
    value: function dOps(track) {
      if (track.config) {
        track.config[4] = track.sampleRate >>> 24 & 255;
        track.config[5] = track.sampleRate >>> 16 & 255;
        track.config[6] = track.sampleRate >>> 8 & 255;
        track.config[7] = track.sampleRate & 255;
        return MP42.box(MP42.types.dOps, track.config);
      }
    }
  }, {
    key: "mvex",
    value: function mvex(tracks) {
      var mvex2 = MP42.box.apply(MP42, [MP42.types.mvex].concat(_toConsumableArray(tracks.map(function(t) {
        return MP42.trex(t.id);
      }))));
      return mvex2;
    }
  }, {
    key: "trex",
    value: function trex(id) {
      var trex2 = MP42.box(MP42.types.trex, new Uint8Array([
        0,
        0,
        0,
        0,
        id >> 24,
        id >> 16 & 255,
        id >> 8 & 255,
        id & 255,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        1,
        0,
        1
      ]));
      return trex2;
    }
  }, {
    key: "trex1",
    value: function trex1(id) {
      var trex = MP42.box(MP42.types.trex, new Uint8Array([
        0,
        0,
        0,
        0,
        id >> 24,
        id >> 16 & 255,
        id >> 8 & 255,
        id & 255,
        0,
        0,
        0,
        1,
        0,
        0,
        2,
        0,
        0,
        0,
        0,
        0,
        0,
        1,
        0,
        0
      ]));
      return trex;
    }
  }, {
    key: "trex2",
    value: function trex2(id) {
      var trex = MP42.box(MP42.types.trex, new Uint8Array([
        0,
        0,
        0,
        0,
        id >> 24,
        id >> 16 & 255,
        id >> 8 & 255,
        id & 255,
        0,
        0,
        0,
        1,
        0,
        0,
        4,
        0,
        0,
        0,
        0,
        0,
        2,
        0,
        0,
        0
      ]));
      return trex;
    }
  }, {
    key: "moof",
    value: function moof(tracks) {
      var moof2 = MP42.box.apply(MP42, [MP42.types.moof, MP42.mfhd(tracks[0].samples ? tracks[0].samples[0].gopId : 0)].concat(_toConsumableArray(tracks.map(function(t) {
        return MP42.traf(t);
      }))));
      return moof2;
    }
  }, {
    key: "mfhd",
    value: function mfhd(sequenceNumber) {
      var mfhd2 = MP42.box(MP42.types.mfhd, new Uint8Array([
        0,
        0,
        0,
        0,
        sequenceNumber >> 24,
        sequenceNumber >> 16 & 255,
        sequenceNumber >> 8 & 255,
        sequenceNumber & 255
      ]));
      return mfhd2;
    }
  }, {
    key: "traf",
    value: function traf(track) {
      var tfhd = MP42.tfhd(track.id);
      var tfdt = MP42.tfdt(track, track.baseMediaDecodeTime);
      var sencLength = 0;
      var samples;
      if (track.isVideo && track.videoSenc) {
        samples = track.videoSenc;
        samples.forEach(function(item) {
          sencLength = sencLength + 8;
          if (item.subsamples && item.subsamples.length) {
            sencLength = sencLength + 2;
            sencLength = sencLength + item.subsamples.length * 6;
          }
        });
      }
      track.videoSencLength = sencLength;
      if (!track.useEME || !track.isVideoEncryption && !track.isAudioEncryption) {
        var sdtp = MP42.sdtp(track);
        var offset = 16 + 20 + 8 + 16 + 8 + 8;
        return MP42.box(MP42.types.traf, tfhd, tfdt, sdtp, MP42.trun(track.samples, sdtp.byteLength + offset));
      } else if (track.isVideoEncryption) {
        if (track.isVideo) {
          var saiz = MP42.saiz(track);
          var saio = MP42.saio(track);
          var trun = MP42.trun1(track);
          var senc = MP42.senc(track);
          var traf2 = MP42.box(MP42.types.traf, tfhd, tfdt, saiz, saio, trun, senc);
          return traf2;
        } else {
          if (!track.isAudioEncryption) {
            var sbgp = MP42.sbgp();
            var _trun = MP42.trun1(track);
            return MP42.box(MP42.types.traf, tfhd, tfdt, sbgp, _trun);
          } else {
            var _sbgp = MP42.sbgp();
            var _saiz = MP42.saiz(track);
            var _saio = MP42.saio(track);
            var _senc = MP42.senc(track);
            var _trun2 = MP42.trun1(track);
            var _traf = MP42.box(MP42.types.traf, tfhd, tfdt, _sbgp, _saiz, _saio, _senc, _trun2);
            return _traf;
          }
        }
      } else {
        if (track.isVideo) {
          var _trun3 = MP42.trun1(track);
          return MP42.box(MP42.types.traf, tfhd, tfdt, _trun3);
        } else {
          var _sbgp2 = MP42.sbgp();
          var _saiz2 = MP42.saiz(track);
          var _saio2 = MP42.saio(track);
          var _senc2 = MP42.senc(track);
          var _trun4 = MP42.trun1(track);
          var _traf2 = MP42.box(MP42.types.traf, tfhd, tfdt, _sbgp2, _saiz2, _saio2, _senc2, _trun4);
          return _traf2;
        }
      }
    }
  }, {
    key: "sdtp",
    value: function sdtp(data) {
      var buffer = new Buffer3();
      data.samples.forEach(function(item) {
        buffer.write(new Uint8Array(data.isVideo ? [item.keyframe ? 32 : 16] : [16]));
      });
      return MP42.box(MP42.types.sdtp, this.extension(0, 0), buffer.buffer);
    }
  }, {
    key: "trun1",
    value: function trun1(data) {
      var buffer = new Buffer3();
      var sampleCount = Buffer3.writeUint32(data.samples.length);
      var offset = null;
      if (data.isVideo) {
        var sencLength = data.videoSencLength;
        offset = Buffer3.writeUint32(data.samples.length * 16 + sencLength + 149);
        if (!data.isVideoEncryption && data.isAudioEncryption) {
          offset = Buffer3.writeUint32(data.samples.length * 16 + 92);
        }
      } else {
        var len = data.samples.length * 12 + 124;
        if (data.isAudioEncryption) {
          len = data.samples.length * 12 + 8 * data.audioSenc.length + 177;
        }
        offset = Buffer3.writeUint32(len);
      }
      data.samples.forEach(function(item) {
        buffer.write(Buffer3.writeUint32(item.duration));
        buffer.write(Buffer3.writeUint32(item.size));
        buffer.write(Buffer3.writeUint32(item.keyframe ? 33554432 : 65536));
        if (data.isVideo) {
          buffer.write(Buffer3.writeUint32(item.cts ? item.cts : 0));
        }
      });
      return MP42.box(MP42.types.trun, this.extension(0, data.flags), sampleCount, offset, buffer.buffer);
    }
  }, {
    key: "senc",
    value: function senc(data) {
      var buffer = new Buffer3();
      var len = data.samples.length;
      var ceil = data.isVideo ? 16 : 8;
      var flag = data.isVideo ? 2 : 0;
      var samples = [];
      var samplesLength = 0;
      if (data.isVideo) {
        samples = data.videoSenc;
        samplesLength = data.videoSencLength;
      } else {
        samples = data.audioSenc;
      }
      samplesLength = samplesLength || ceil * len;
      buffer.write(Buffer3.writeUint32(16 + samplesLength), MP42.types.senc, this.extension(0, flag));
      buffer.write(Buffer3.writeUint32(len));
      samples.forEach(function(item) {
        for (var i = 0; i < item.InitializationVector.length; i++) {
          buffer.write(new Uint8Array([item.InitializationVector[i]]));
        }
        if (item.subsamples && item.subsamples.length) {
          buffer.write(Buffer3.writeUint16(item.subsamples.length));
          item.subsamples.forEach(function(value) {
            buffer.write(Buffer3.writeUint16(value.BytesOfClearData));
            buffer.write(Buffer3.writeUint32(value.BytesOfProtectedData));
          });
        }
      });
      return buffer.buffer;
    }
  }, {
    key: "saio",
    value: function saio(data) {
      var length = data.samples.length * 12 + 141;
      if (!data.isVideo && data.isAudioEncryption) {
        length = 149;
      }
      var content = new Uint8Array([1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, length >> 24 & 255, length >> 16 & 255, length >> 8 & 255, length & 255]);
      return MP42.box(MP42.types.saio, content);
    }
  }, {
    key: "saiz",
    value: function saiz(data) {
      var samplesLength = data.samples.length;
      var content = new Uint8Array([
        0,
        0,
        0,
        0,
        16,
        samplesLength >> 24 & 255,
        samplesLength >> 16 & 255,
        samplesLength >> 8 & 255,
        samplesLength & 255
      ]);
      return MP42.box(MP42.types.saiz, content);
    }
  }, {
    key: "sbgp",
    value: function sbgp() {
      var content = new Uint8Array([
        114,
        111,
        108,
        108,
        0,
        0,
        0,
        1,
        0,
        0,
        1,
        25,
        0,
        0,
        0,
        1
      ]);
      return MP42.box(MP42.types.sbgp, this.extension(0, 0), content);
    }
  }, {
    key: "extension",
    value: function extension(version, flag) {
      return new Uint8Array([version, flag >> 16 & 255, flag >> 8 & 255, flag & 255]);
    }
  }, {
    key: "tfhd",
    value: function tfhd(id) {
      return MP42.box(MP42.types.tfhd, new Uint8Array([
        0,
        0,
        0,
        0,
        id >> 24,
        id >> 16 & 255,
        id >> 8 & 255,
        id & 255
      ]));
    }
  }, {
    key: "tfdt",
    value: function tfdt(data, baseMediaDecodeTime) {
      var upperWordBaseMediaDecodeTime = Math.floor(baseMediaDecodeTime / (UINT32_MAX + 1));
      var lowerWordBaseMediaDecodeTime = Math.floor(baseMediaDecodeTime % (UINT32_MAX + 1));
      if (data.useEME && (data.isVideoEncryption || data.isAudioEncryption)) {
        return MP42.box(MP42.types.tfdt, new Uint8Array([
          0,
          0,
          0,
          0,
          lowerWordBaseMediaDecodeTime >> 24,
          lowerWordBaseMediaDecodeTime >> 16 & 255,
          lowerWordBaseMediaDecodeTime >> 8 & 255,
          lowerWordBaseMediaDecodeTime & 255
        ]));
      } else {
        return MP42.box(MP42.types.tfdt, new Uint8Array([
          1,
          0,
          0,
          0,
          upperWordBaseMediaDecodeTime >> 24,
          upperWordBaseMediaDecodeTime >> 16 & 255,
          upperWordBaseMediaDecodeTime >> 8 & 255,
          upperWordBaseMediaDecodeTime & 255,
          lowerWordBaseMediaDecodeTime >> 24,
          lowerWordBaseMediaDecodeTime >> 16 & 255,
          lowerWordBaseMediaDecodeTime >> 8 & 255,
          lowerWordBaseMediaDecodeTime & 255
        ]));
      }
    }
  }, {
    key: "trun",
    value: function trun(samples, offset) {
      var sampleLen = samples.length;
      var dataLen = 12 + 16 * sampleLen;
      offset += 8 + dataLen;
      var data = new Uint8Array(dataLen);
      data.set([
        0,
        0,
        15,
        1,
        sampleLen >>> 24 & 255,
        sampleLen >>> 16 & 255,
        sampleLen >>> 8 & 255,
        sampleLen & 255,
        offset >>> 24 & 255,
        offset >>> 16 & 255,
        offset >>> 8 & 255,
        offset & 255
      ], 0);
      for (var i = 0; i < sampleLen; i++) {
        var _samples$i = samples[i], duration = _samples$i.duration, size = _samples$i.size, _samples$i$flag = _samples$i.flag, flag = _samples$i$flag === void 0 ? {} : _samples$i$flag, _samples$i$cts = _samples$i.cts, cts = _samples$i$cts === void 0 ? 0 : _samples$i$cts;
        data.set([
          duration >>> 24 & 255,
          duration >>> 16 & 255,
          duration >>> 8 & 255,
          duration & 255,
          size >>> 24 & 255,
          size >>> 16 & 255,
          size >>> 8 & 255,
          size & 255,
          flag.isLeading << 2 | (flag.dependsOn === null || flag.dependsOn === void 0 ? 1 : flag.dependsOn),
          flag.isDependedOn << 6 | flag.hasRedundancy << 4 | flag.paddingValue << 1 | (flag.isNonSyncSample === null || flag.isNonSyncSample === void 0 ? 1 : flag.isNonSyncSample),
          flag.degradationPriority & 240 << 8,
          flag.degradationPriority & 15,
          cts >>> 24 & 255,
          cts >>> 16 & 255,
          cts >>> 8 & 255,
          cts & 255
        ], 12 + 16 * i);
      }
      return MP42.box(MP42.types.trun, data);
    }
  }, {
    key: "moovMP4",
    value: function moovMP4(tracks) {
      return MP42.box.apply(MP42, [MP42.types.moov, MP42.mvhd(tracks[0].duration, tracks[0].timescale)].concat(_toConsumableArray(tracks.map(function(t) {
        return MP42.trackMP4(t);
      }))));
    }
  }, {
    key: "trackMP4",
    value: function trackMP4(track) {
      return MP42.box(MP42.types.trak, MP42.tkhd(track.id, track.duration, track.width, track.height), MP42.mdiaMP4(track));
    }
  }, {
    key: "mdiaMP4",
    value: function mdiaMP4(track) {
      return MP42.box(MP42.types.mdia, MP42.mdhd(track.duration, track.timescale), MP42.hdlr(track.type), MP42.minfMP4(track));
    }
  }, {
    key: "minfMP4",
    value: function minfMP4(track) {
      return MP42.box(MP42.types.minf, track.type === TrackType.VIDEO ? MP42.VMHD : MP42.SMHD, MP42.DINF, MP42.stblMP4(track));
    }
  }, {
    key: "stblMP4",
    value: function stblMP4(track) {
      var ext = track.ext;
      var boxes = [MP42.stsd(track), MP42.stts(ext.stts), MP42.stsc(ext.stsc), MP42.stsz(ext.stsz), MP42.stco(ext.stco)];
      if (ext.stss.length) {
        boxes.push(MP42.stss(ext.stss));
      }
      if (ext.ctts.length) {
        boxes.push(MP42.ctts(ext.ctts));
      }
      return MP42.box.apply(MP42, [MP42.types.stbl].concat(boxes));
    }
  }, {
    key: "stts",
    value: function stts(samples) {
      var len = samples.length;
      var data = new Uint8Array(8 * len);
      var offset = 0;
      samples.forEach(function(_ref5) {
        var value = _ref5.value, count = _ref5.count;
        data.set([count >> 24, count >> 16 & 255, count >> 8 & 255, count & 255, value >> 24, value >> 16 & 255, value >> 8 & 255, value & 255], offset);
        offset += 8;
      });
      return MP42.box(MP42.types.stts, concatUint8Array2(new Uint8Array([0, 0, 0, 0, len >> 24, len >> 16 & 255, len >> 8 & 255, len & 255]), data));
    }
  }, {
    key: "stsc",
    value: function stsc(entries) {
      var len = entries.length;
      var data = new Uint8Array(12 * len);
      var offset = 0;
      entries.forEach(function(_ref6) {
        var firstChunk = _ref6.firstChunk, samplesPerChunk = _ref6.samplesPerChunk, sampleDescIndex = _ref6.sampleDescIndex;
        data.set([firstChunk >> 24, firstChunk >> 16 & 255, firstChunk >> 8 & 255, firstChunk & 255, samplesPerChunk >> 24, samplesPerChunk >> 16 & 255, samplesPerChunk >> 8 & 255, samplesPerChunk & 255, sampleDescIndex >> 24, sampleDescIndex >> 16 & 255, sampleDescIndex >> 8 & 255, sampleDescIndex & 255], offset);
        offset += 12;
      });
      return MP42.box(MP42.types.stsc, concatUint8Array2(new Uint8Array([0, 0, 0, 0, len >> 24, len >> 16 & 255, len >> 8 & 255, len & 255]), data));
    }
  }, {
    key: "stsz",
    value: function stsz(samplesSizes) {
      var len = samplesSizes.length;
      var data = new Uint8Array(4 * len);
      var offset = 0;
      samplesSizes.forEach(function(x) {
        data.set([x >> 24, x >> 16 & 255, x >> 8 & 255, x & 255], offset);
        offset += 4;
      });
      return MP42.box(MP42.types.stsz, concatUint8Array2(new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, len >> 24, len >> 16 & 255, len >> 8 & 255, len & 255]), data));
    }
  }, {
    key: "stco",
    value: function stco(offsets) {
      var len = offsets.length;
      var data = new Uint8Array(4 * len);
      var offset = 0;
      offsets.forEach(function(x) {
        data.set([x >> 24, x >> 16 & 255, x >> 8 & 255, x & 255], offset);
        offset += 4;
      });
      return MP42.box(MP42.types.stco, concatUint8Array2(new Uint8Array([0, 0, 0, 0, len >> 24, len >> 16 & 255, len >> 8 & 255, len & 255]), data));
    }
  }, {
    key: "stss",
    value: function stss(keyframeIndexes) {
      var len = keyframeIndexes.length;
      var data = new Uint8Array(4 * len);
      var offset = 0;
      keyframeIndexes.forEach(function(x) {
        data.set([x >> 24, x >> 16 & 255, x >> 8 & 255, x & 255], offset);
        offset += 4;
      });
      return MP42.box(MP42.types.stss, concatUint8Array2(new Uint8Array([0, 0, 0, 0, len >> 24, len >> 16 & 255, len >> 8 & 255, len & 255]), data));
    }
  }, {
    key: "ctts",
    value: function ctts(samples) {
      var len = samples.length;
      var data = new Uint8Array(8 * len);
      var offset = 0;
      samples.forEach(function(_ref7) {
        var value = _ref7.value, count = _ref7.count;
        data.set([count >> 24, count >> 16 & 255, count >> 8 & 255, count & 255, value >> 24, value >> 16 & 255, value >> 8 & 255, value & 255], offset);
        offset += 8;
      });
      return MP42.box(MP42.types.ctts, concatUint8Array2(new Uint8Array([0, 0, 0, 0, len >> 24, len >> 16 & 255, len >> 8 & 255, len & 255]), data));
    }
  }, {
    key: "styp",
    value: function styp() {
      return MP42.box(MP42.types.styp, new Uint8Array([109, 115, 100, 104, 0, 0, 0, 0, 109, 115, 100, 104, 109, 115, 105, 120]));
    }
  }, {
    key: "sidx",
    value: function sidx(data) {
      var timescale = data.timescale;
      var duration = data.samples[0].duration;
      var durationCount = duration * data.samples.length;
      var earliestTime = data.samples[0].sampleOffset * duration;
      var mdatSize = 8;
      data.samples.forEach(function(item) {
        mdatSize += item.size;
      });
      var length = 0;
      if (data.isVideo) {
        var sencLength = 0;
        var samples;
        if (data.videoSenc) {
          samples = data.videoSenc;
        }
        if (data.isVideo) {
          samples.forEach(function(item) {
            sencLength = sencLength + 8;
            if (item.subsamples && item.subsamples.length) {
              sencLength = sencLength + 2;
              sencLength = sencLength + item.subsamples.length * 6;
            }
          });
        }
        data.videoSencLength = sencLength;
        length = mdatSize + 141 + data.samples.length * 16 + sencLength;
        if (data.useEME && data.isAudioEncryption && !data.isVideoEncryption) {
          length = mdatSize + data.samples.length * 16 + 84;
        }
      } else {
        length = mdatSize + 116 + data.samples.length * 12;
        if (data.useEME && data.isAudioEncryption) {
          length = mdatSize + 169 + data.samples.length * 12 + 8 * data.audioSenc.length;
        }
      }
      var content = new Uint8Array([
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        data.id & 255,
        timescale >> 24 & 255,
        timescale >> 16 & 255,
        timescale >> 8 & 255,
        timescale & 255,
        earliestTime >> 24 & 255,
        earliestTime >> 16 & 255,
        earliestTime >> 8 & 255,
        earliestTime & 255,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        1,
        0,
        length >> 16 & 255,
        length >> 8 & 255,
        length & 255,
        durationCount >> 24 & 255,
        durationCount >> 16 & 255,
        durationCount >> 8 & 255,
        durationCount & 255,
        144,
        0,
        0,
        0
      ]);
      return MP42.box(MP42.types.sidx, content);
    }
  }, {
    key: "mdat",
    value: function mdat(data) {
      var mdat2 = MP42.box(MP42.types.mdat, data);
      return mdat2;
    }
  }]);
  return MP42;
}();
_defineProperty3(MP4, "types", ["Opus", "dOps", "av01", "av1C", "avc1", "avcC", "hvc1", "hvcC", "dinf", "dref", "esds", "ftyp", "hdlr", "mdat", "mdhd", "mdia", "mfhd", "minf", "moof", "moov", "mp4a", "mvex", "mvhd", "pasp", "stbl", "stco", "stsc", "stsd", "stsz", "stts", "tfdt", "tfhd", "traf", "trak", "trex", "tkhd", "vmhd", "smhd", "ctts", "stss", "styp", "pssh", "sidx", "sbgp", "saiz", "saio", "senc", "trun", "encv", "enca", "sinf", "btrt", "frma", "tenc", "schm", "schi", "mehd", "fiel", "sdtp"].reduce(function(p, c) {
  p[c] = [c.charCodeAt(0), c.charCodeAt(1), c.charCodeAt(2), c.charCodeAt(3)];
  return p;
}, /* @__PURE__ */ Object.create(null)));
_defineProperty3(MP4, "HDLR_TYPES", {
  video: new Uint8Array([
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    118,
    105,
    100,
    101,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    86,
    105,
    100,
    101,
    111,
    72,
    97,
    110,
    100,
    108,
    101,
    114,
    0
  ]),
  audio: new Uint8Array([
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    115,
    111,
    117,
    110,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    83,
    111,
    117,
    110,
    100,
    72,
    97,
    110,
    100,
    108,
    101,
    114,
    0
  ])
});
_defineProperty3(MP4, "FTYPAVC1", MP4.box(MP4.types.ftyp, new Uint8Array([
  105,
  115,
  111,
  109,
  0,
  0,
  0,
  1,
  105,
  115,
  111,
  109,
  97,
  118,
  99,
  49
])));
_defineProperty3(MP4, "FTYPHEV1", MP4.box(MP4.types.ftyp, new Uint8Array([
  105,
  115,
  111,
  109,
  0,
  0,
  0,
  1,
  105,
  115,
  111,
  109,
  104,
  101,
  118,
  49
])));
_defineProperty3(MP4, "DINF", MP4.box(MP4.types.dinf, MP4.box(MP4.types.dref, new Uint8Array([
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  1,
  0,
  0,
  0,
  12,
  117,
  114,
  108,
  32,
  0,
  0,
  0,
  1
]))));
_defineProperty3(MP4, "VMHD", MP4.box(MP4.types.vmhd, new Uint8Array([
  0,
  0,
  0,
  1,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0
])));
_defineProperty3(MP4, "SMHD", MP4.box(MP4.types.smhd, new Uint8Array([
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0
])));
_defineProperty3(MP4, "StblTable", new Uint8Array([
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0
]));
_defineProperty3(MP4, "STTS", MP4.box(MP4.types.stts, MP4.StblTable));
_defineProperty3(MP4, "STSC", MP4.box(MP4.types.stsc, MP4.StblTable));
_defineProperty3(MP4, "STSZ", MP4.box(MP4.types.stsz, new Uint8Array([
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0
])));
_defineProperty3(MP4, "STCO", MP4.box(MP4.types.stco, MP4.StblTable));

// node_modules/xgplayer-transmuxer/es/mp4/logger.js
var Logger3 = /* @__PURE__ */ function() {
  function Logger22(name, enable) {
    _classCallCheck3(this, Logger22);
    this.name = name || "";
    this._prefix = "[".concat(this.name, "]");
    Logger22.disabled = enable;
  }
  _createClass3(Logger22, [{
    key: "debug",
    value: function debug() {
      var _console;
      if (Logger22.disabled)
        return;
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      (_console = console).debug.apply(_console, [this._prefix].concat(args));
    }
  }, {
    key: "log",
    value: function log() {
      var _console2;
      if (Logger22.disabled)
        return;
      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }
      (_console2 = console).log.apply(_console2, [this._prefix].concat(args));
    }
  }, {
    key: "warn",
    value: function warn() {
      var _console3;
      if (Logger22.disabled)
        return;
      for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
        args[_key3] = arguments[_key3];
      }
      (_console3 = console).warn.apply(_console3, [this._prefix].concat(args));
    }
  }, {
    key: "error",
    value: function error() {
      var _console4;
      if (Logger22.disabled)
        return;
      for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
        args[_key4] = arguments[_key4];
      }
      (_console4 = console).error.apply(_console4, [this._prefix].concat(args));
    }
  }, {
    key: "table",
    value: function table() {
      var _console5;
      if (Logger22.disabled)
        return;
      console.group(this._prefix);
      (_console5 = console).table.apply(_console5, arguments);
      console.groupEnd();
    }
  }], [{
    key: "enable",
    value: function enable() {
      Logger22.disabled = false;
    }
  }, {
    key: "disable",
    value: function disable() {
      Logger22.disabled = true;
    }
  }]);
  return Logger22;
}();
_defineProperty3(Logger3, "disabled", true);

// node_modules/xgplayer-transmuxer/es/mp4/fmp4-remuxer.js
var FMP4Remuxer = /* @__PURE__ */ function() {
  function FMP4Remuxer2(videoTrack, audioTrack, options) {
    _classCallCheck3(this, FMP4Remuxer2);
    this.videoTrack = videoTrack;
    this.audioTrack = audioTrack;
    var browserVersions = /Chrome\/([^.]+)/.exec(navigator.userAgent);
    this.forceFirstIDR = browserVersions && Number(browserVersions[1]) < 50;
    this.log = new Logger3("FMP4Remuxer", options && options.openLog ? !options.openLog : true);
  }
  _createClass3(FMP4Remuxer2, [{
    key: "remux",
    value: function remux() {
      var createInit = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
      var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      var videoTrack = this.videoTrack;
      var audioTrack = this.audioTrack;
      var hasVideo = videoTrack.exist();
      var hasAudio = audioTrack.exist();
      var videoInitSegment;
      var audioInitSegment;
      var initSegment;
      var tracks = [];
      if (createInit) {
        if (options && options.initMerge) {
          if (hasVideo) {
            tracks.push(this.videoTrack);
          }
          if (hasAudio) {
            tracks.push(this.audioTrack);
          }
          initSegment = MP4.initSegment(tracks);
        } else {
          if (hasVideo)
            videoInitSegment = MP4.initSegment([this.videoTrack]);
          if (hasAudio)
            audioInitSegment = MP4.initSegment([this.audioTrack]);
        }
      }
      var videoSegment;
      var audioSegment;
      if (hasVideo && videoTrack.hasSample()) {
        videoSegment = this._remuxVideo();
      }
      if (hasAudio && audioTrack.hasSample()) {
        audioSegment = this._remuxAudio();
      }
      videoTrack.samples = [];
      audioTrack.samples = [];
      return {
        initSegment,
        videoInitSegment,
        audioInitSegment,
        videoSegment,
        audioSegment
      };
    }
  }, {
    key: "_remuxVideo",
    value: function _remuxVideo() {
      var track = this.videoTrack;
      if (this.forceFirstIDR) {
        track.samples[0].flag = {
          dependsOn: 2,
          isNonSyncSample: 0
        };
      }
      var samples = track.samples;
      var isAV01 = /av01/.test(track.codec);
      var mdatSize = 0;
      if (isAV01) {
        samples.forEach(function(s) {
          mdatSize += s.data.byteLength;
        });
      } else {
        samples.forEach(function(s) {
          mdatSize += s.units.reduce(function(t, c) {
            return t + c.byteLength;
          }, 0);
          mdatSize += s.units.length * 4;
        });
      }
      var mdata = new Uint8Array(mdatSize);
      if (isAV01) {
        for (var i = 0, l = samples.length, offset = 0, sample; i < l; i++) {
          sample = samples[i];
          mdata.set(sample.data, offset);
          sample.size = sample.data.byteLength;
          offset += sample.size;
        }
      } else {
        var mdatView = new DataView(mdata.buffer);
        var _loop = function _loop2(_offset2, _sample2) {
          _sample2 = samples[_i];
          var sampleSize = 0;
          _sample2.units.forEach(function(u) {
            mdatView.setUint32(_offset2, u.byteLength);
            _offset2 += 4;
            mdata.set(u, _offset2);
            _offset2 += u.byteLength;
            sampleSize += 4 + u.byteLength;
          });
          _sample2.size = sampleSize;
          _offset = _offset2, _sample = _sample2;
        };
        for (var _i = 0, _l = samples.length, _offset = 0, _sample; _i < _l; _i++) {
          _loop(_offset, _sample);
        }
      }
      var mdat = MP4.mdat(mdata);
      var moof = MP4.moof([track]);
      return concatUint8Array2(moof, mdat);
    }
  }, {
    key: "_remuxAudio",
    value: function _remuxAudio() {
      var track = this.audioTrack;
      var mdata = new Uint8Array(track.samples.reduce(function(t, c) {
        return t + c.size;
      }, 0));
      track.samples.reduce(function(offset, s) {
        mdata.set(s.data, offset);
        return offset + s.size;
      }, 0);
      var mdat = MP4.mdat(mdata);
      var moof = MP4.moof([track]);
      return concatUint8Array2(moof, mdat);
    }
  }, {
    key: "reset",
    value: function reset() {
      this.videoTrack.reset();
      this.audioTrack.reset();
    }
  }]);
  return FMP4Remuxer2;
}();

// node_modules/xgplayer-flv/es/flv/services/transfer-cost.js
var TransferCost = /* @__PURE__ */ function() {
  function TransferCost2() {
    _classCallCheck(this, TransferCost2);
    _defineProperty(this, "_ttfb", 0);
    _defineProperty(this, "_demuxStart", 0);
    _defineProperty(this, "_demuxEnd", 0);
    _defineProperty(this, "_demuxCost", 0);
    _defineProperty(this, "_remuxStart", 0);
    _defineProperty(this, "_remuxEnd", 0);
    _defineProperty(this, "_remuxCost", 0);
    _defineProperty(this, "_appendStart", 0);
    _defineProperty(this, "_appendEnd", 0);
    _defineProperty(this, "_appendCost", 0);
  }
  _createClass(TransferCost2, [{
    key: "set",
    value: function set(event, value) {
      this["_".concat(event)] = value;
    }
  }, {
    key: "start",
    value: function start(event) {
      this["_".concat(event, "Start")] = Date.now();
    }
  }, {
    key: "end",
    value: function end(event) {
      this["_".concat(event, "End")] = Date.now();
      this["_".concat(event, "Cost")] = this["_".concat(event, "Cost")] + (this["_".concat(event, "End")] - this["_".concat(event, "Start")]);
    }
  }, {
    key: "transferCost",
    get: function get() {
      return {
        ttfbCost: this._ttfb,
        demuxCost: this._demuxCost,
        remuxCost: this._remuxCost,
        appendCost: this._appendCost
      };
    }
  }]);
  return TransferCost2;
}();
var TRANSFER_EVENT = {
  TTFB: "ttfb",
  DEMUX: "demux",
  REMUX: "remux",
  APPEND: "append"
};

// node_modules/xgplayer-flv/es/flv/services/buffer-service.js
var logger2 = new Logger("BufferService");
var BufferService = /* @__PURE__ */ function() {
  function BufferService2(flv, softVideo) {
    var opts = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    _classCallCheck(this, BufferService2);
    _defineProperty(this, "flv", null);
    _defineProperty(this, "_demuxer", new FlvDemuxer());
    _defineProperty(this, "_remuxer", null);
    _defineProperty(this, "_mse", null);
    _defineProperty(this, "_softVideo", null);
    _defineProperty(this, "_sourceCreated", false);
    _defineProperty(this, "_needInitSegment", true);
    _defineProperty(this, "_discontinuity", true);
    _defineProperty(this, "_contiguous", false);
    _defineProperty(this, "_initSegmentId", "");
    _defineProperty(this, "_cachedBuffer", null);
    _defineProperty(this, "_demuxStartTime", 0);
    _defineProperty(this, "_opts", null);
    this.flv = flv;
    this._opts = opts;
    if (softVideo) {
      this._softVideo = softVideo;
    } else {
      this._remuxer = new FMP4Remuxer(this._demuxer.videoTrack, this._demuxer.audioTrack);
      this._mse = new MSE(null, {
        preferMMS: typeof opts.preferMMS === "boolean" ? opts.preferMMS : !!opts.perferMMS
      });
      this._mse.bindMedia(flv.media);
    }
  }
  _createClass(BufferService2, [{
    key: "baseDts",
    get: function get() {
      var _this$_demuxer, _this$_demuxer$_fixer;
      return (_this$_demuxer = this._demuxer) === null || _this$_demuxer === void 0 ? void 0 : (_this$_demuxer$_fixer = _this$_demuxer._fixer) === null || _this$_demuxer$_fixer === void 0 ? void 0 : _this$_demuxer$_fixer._baseDts;
    }
  }, {
    key: "blobUrl",
    get: function get() {
      var _this$_mse;
      return (_this$_mse = this._mse) === null || _this$_mse === void 0 ? void 0 : _this$_mse.url;
    }
  }, {
    key: "isFull",
    value: function isFull() {
      var mediaType = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : MSE.VIDEO;
      return this._mse.isFull(mediaType);
    }
  }, {
    key: "seamlessSwitch",
    value: function seamlessSwitch() {
      this._needInitSegment = true;
      this._discontinuity = true;
      this._contiguous = true;
      this._initSegmentId = "";
    }
  }, {
    key: "unContiguous",
    value: function unContiguous(startTime) {
      this._contiguous = false;
      this._demuxStartTime = startTime;
    }
  }, {
    key: "reset",
    value: function() {
      var _reset = _asyncToGenerator(/* @__PURE__ */ _regeneratorRuntime().mark(function _callee() {
        var reuseMse, _args = arguments;
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1)
            switch (_context.prev = _context.next) {
              case 0:
                reuseMse = _args.length > 0 && _args[0] !== void 0 ? _args[0] : false;
                if (!(this._mse && !reuseMse)) {
                  _context.next = 6;
                  break;
                }
                _context.next = 4;
                return this._mse.unbindMedia();
              case 4:
                _context.next = 6;
                return this._mse.bindMedia(this.flv.media);
              case 6:
                this._needInitSegment = true;
                this._discontinuity = true;
                this._contiguous = false;
                this._sourceCreated = false;
                this._initSegmentId = "";
                this.resetSeamlessSwitchStats();
              case 12:
              case "end":
                return _context.stop();
            }
        }, _callee, this);
      }));
      function reset() {
        return _reset.apply(this, arguments);
      }
      return reset;
    }()
  }, {
    key: "resetSeamlessSwitchStats",
    value: function resetSeamlessSwitchStats() {
      this.seamlessLoadingSwitch = null;
      this.seamlessLoadingSwitching = false;
      if (this._demuxer) {
        this._demuxer.seamlessLoadingSwitching = false;
      }
    }
  }, {
    key: "endOfStream",
    value: function() {
      var _endOfStream = _asyncToGenerator(/* @__PURE__ */ _regeneratorRuntime().mark(function _callee2() {
        return _regeneratorRuntime().wrap(function _callee2$(_context2) {
          while (1)
            switch (_context2.prev = _context2.next) {
              case 0:
                if (!this._mse) {
                  _context2.next = 7;
                  break;
                }
                if (!this._sourceCreated) {
                  _context2.next = 5;
                  break;
                }
                _context2.next = 4;
                return this._mse.endOfStream();
              case 4:
                this.flv.emit(EVENT.BUFFEREOS);
              case 5:
                _context2.next = 8;
                break;
              case 7:
                if (this._softVideo) {
                  this._softVideo.endOfStream();
                }
              case 8:
              case "end":
                return _context2.stop();
            }
        }, _callee2, this);
      }));
      function endOfStream() {
        return _endOfStream.apply(this, arguments);
      }
      return endOfStream;
    }()
  }, {
    key: "updateDuration",
    value: function() {
      var _updateDuration = _asyncToGenerator(/* @__PURE__ */ _regeneratorRuntime().mark(function _callee3(duration) {
        return _regeneratorRuntime().wrap(function _callee3$(_context3) {
          while (1)
            switch (_context3.prev = _context3.next) {
              case 0:
                if (!this._mse) {
                  _context3.next = 7;
                  break;
                }
                if (this._mse.isOpened) {
                  _context3.next = 4;
                  break;
                }
                _context3.next = 4;
                return this._mse.open();
              case 4:
                logger2.debug("update duration", duration);
                _context3.next = 7;
                return this._mse.updateDuration(duration);
              case 7:
              case "end":
                return _context3.stop();
            }
        }, _callee3, this);
      }));
      function updateDuration(_x) {
        return _updateDuration.apply(this, arguments);
      }
      return updateDuration;
    }()
  }, {
    key: "destroy",
    value: function() {
      var _destroy = _asyncToGenerator(/* @__PURE__ */ _regeneratorRuntime().mark(function _callee4() {
        return _regeneratorRuntime().wrap(function _callee4$(_context4) {
          while (1)
            switch (_context4.prev = _context4.next) {
              case 0:
                if (!this._mse) {
                  _context4.next = 3;
                  break;
                }
                _context4.next = 3;
                return this._mse.unbindMedia();
              case 3:
                this._mse = null;
                this._softVideo = null;
                this._demuxer = null;
                this._remuxer = null;
              case 7:
              case "end":
                return _context4.stop();
            }
        }, _callee4, this);
      }));
      function destroy() {
        return _destroy.apply(this, arguments);
      }
      return destroy;
    }()
  }, {
    key: "appendBuffer",
    value: function() {
      var _appendBuffer = _asyncToGenerator(/* @__PURE__ */ _regeneratorRuntime().mark(function _callee5(chunk) {
        var _this = this;
        var switchingNoReset, demuxer, videoTrack, audioTrack, metadataTrack, idx, videoExist, audioExist, duration, track, videoType, audioType, mse, afterAppend, newId, remuxResult, p, ret;
        return _regeneratorRuntime().wrap(function _callee5$(_context5) {
          while (1)
            switch (_context5.prev = _context5.next) {
              case 0:
                switchingNoReset = false;
                if (this._cachedBuffer) {
                  chunk = concatUint8Array(this._cachedBuffer, chunk);
                  this._cachedBuffer = null;
                }
                demuxer = this._demuxer;
                if (!(!chunk || !chunk.length || !demuxer)) {
                  _context5.next = 5;
                  break;
                }
                return _context5.abrupt("return");
              case 5:
                _context5.prev = 5;
                this.flv._transferCost.start(TRANSFER_EVENT.DEMUX);
                demuxer.demuxAndFix(chunk, this.seamlessLoadingSwitching || this._discontinuity, this._contiguous, this._demuxStartTime, this.seamlessLoadingSwitching);
                this.seamlessLoadingSwitching = false;
                this.flv._transferCost.end(TRANSFER_EVENT.DEMUX);
                _context5.next = 15;
                break;
              case 12:
                _context5.prev = 12;
                _context5.t0 = _context5["catch"](5);
                throw new StreamingError(ERR.DEMUX, ERR.SUB_TYPES.FLV, _context5.t0);
              case 15:
                videoTrack = demuxer.videoTrack, audioTrack = demuxer.audioTrack, metadataTrack = demuxer.metadataTrack;
                if (!this.seamlessLoadingSwitch) {
                  _context5.next = 25;
                  break;
                }
                idx = videoTrack.samples.findIndex(function(sample) {
                  return sample.originDts === videoTrack.lastKeyFrameDts;
                });
                if (!(idx >= 0)) {
                  _context5.next = 25;
                  break;
                }
                videoTrack.samples.splice(idx);
                _context5.next = 22;
                return this.seamlessLoadingSwitch();
              case 22:
                this.seamlessLoadingSwitch = null;
                chunk = null;
                switchingNoReset = true;
              case 25:
                videoExist = videoTrack.exist();
                audioExist = audioTrack.exist();
                if (this._opts.onlyAudio) {
                  videoExist = false;
                  videoTrack.present = false;
                }
                if (this._opts.onlyVideo) {
                  audioExist = false;
                  audioTrack.present = false;
                }
                if (!(!videoExist && videoTrack.present || !audioExist && audioTrack.present)) {
                  _context5.next = 42;
                  break;
                }
                duration = 0;
                track = videoExist ? videoTrack : audioExist ? audioTrack : void 0;
                if (track && track.samples.length) {
                  duration = (track.samples[track.samples.length - 1].originPts - track.samples[0].originPts) / track.timescale * 1e3;
                }
                if (!(duration > this._opts.analyzeDuration)) {
                  _context5.next = 40;
                  break;
                }
                logger2.warn("analyze duration exceeded, ".concat(duration, "ms"), track);
                videoTrack.present = videoExist;
                audioTrack.present = audioExist;
                this.flv.emit(EVENT.ANALYZE_DURATION_EXCEEDED, {
                  duration
                });
                _context5.next = 42;
                break;
              case 40:
                this._cachedBuffer = chunk;
                return _context5.abrupt("return");
              case 42:
                videoType = videoTrack.type;
                audioType = audioTrack.type;
                this._fireEvents(videoTrack, audioTrack, metadataTrack);
                if (!switchingNoReset) {
                  this._discontinuity = false;
                  this._contiguous = true;
                  this._demuxStartTime = 0;
                }
                mse = this._mse;
                afterAppend = function afterAppend2() {
                  var _this$flv;
                  if ((_this$flv = _this.flv) !== null && _this$flv !== void 0 && _this$flv.emit) {
                    var _this$flv2;
                    (_this$flv2 = _this.flv) === null || _this$flv2 === void 0 ? void 0 : _this$flv2.emit(EVENT.APPEND_BUFFER, {});
                  }
                };
                this.flv.emit(EVENT.DEMUXED_TRACK, {
                  videoTrack
                });
                newId = "".concat(videoTrack.codec, "/").concat(videoTrack.width, "/").concat(videoTrack.height, "/").concat(audioTrack.codec, "/").concat(audioTrack.config);
                if (newId !== this._initSegmentId) {
                  this._needInitSegment = true;
                  this._initSegmentId = newId;
                  this._emitMetaParsedEvent(videoTrack, audioTrack);
                }
                if (!mse) {
                  _context5.next = 83;
                  break;
                }
                if (this._sourceCreated) {
                  _context5.next = 59;
                  break;
                }
                _context5.next = 55;
                return mse.open();
              case 55:
                if (videoExist) {
                  logger2.log("codec: video/mp4;codecs=".concat(videoTrack.codec));
                  mse.createSource(videoType, "video/mp4;codecs=".concat(videoTrack.codec));
                }
                if (audioExist) {
                  logger2.log("codec: audio/mp4;codecs=".concat(audioTrack.codec));
                  mse.createSource(audioType, "audio/mp4;codecs=".concat(audioTrack.codec));
                }
                this._sourceCreated = true;
                this.flv.emit(EVENT.SOURCEBUFFER_CREATED);
              case 59:
                _context5.prev = 59;
                if (this._needInitSegment && !this._opts.mseLowLatency) {
                  videoTrack.duration = this._opts.durationForMSELowLatencyOff * videoTrack.timescale;
                  audioTrack.duration = this._opts.durationForMSELowLatencyOff * audioExist.timescale;
                }
                this.flv._transferCost.start(TRANSFER_EVENT.REMUX);
                remuxResult = this._remuxer.remux(this._needInitSegment);
                this.flv._transferCost.end(TRANSFER_EVENT.REMUX);
                _context5.next = 69;
                break;
              case 66:
                _context5.prev = 66;
                _context5.t1 = _context5["catch"](59);
                throw new StreamingError(ERR.REMUX, ERR.SUB_TYPES.FMP4, _context5.t1);
              case 69:
                if (!(this._needInitSegment && !remuxResult.videoInitSegment && !remuxResult.audioInitSegment)) {
                  _context5.next = 71;
                  break;
                }
                return _context5.abrupt("return");
              case 71:
                this._needInitSegment = false;
                p = [];
                if (remuxResult.videoInitSegment)
                  p.push(mse.append(videoType, remuxResult.videoInitSegment));
                if (remuxResult.audioInitSegment)
                  p.push(mse.append(audioType, remuxResult.audioInitSegment));
                if (remuxResult.videoSegment)
                  p.push(mse.append(videoType, remuxResult.videoSegment));
                if (remuxResult.audioSegment)
                  p.push(mse.append(audioType, remuxResult.audioSegment));
                this.flv._transferCost.start(TRANSFER_EVENT.APPEND);
                ret = Promise.all(p);
                ret.then(afterAppend).then(function() {
                  _this.flv._transferCost.end(TRANSFER_EVENT.APPEND);
                  afterAppend();
                });
                return _context5.abrupt("return", ret);
              case 83:
                if (this._softVideo) {
                  this._softVideo.appendBuffer(videoTrack, audioTrack);
                  afterAppend();
                }
              case 84:
              case "end":
                return _context5.stop();
            }
        }, _callee5, this, [[5, 12], [59, 66]]);
      }));
      function appendBuffer(_x2) {
        return _appendBuffer.apply(this, arguments);
      }
      return appendBuffer;
    }()
  }, {
    key: "evictBuffer",
    value: function() {
      var _evictBuffer = _asyncToGenerator(/* @__PURE__ */ _regeneratorRuntime().mark(function _callee6(bufferBehind) {
        var _this2 = this;
        var media, currentTime, removeEnd, start;
        return _regeneratorRuntime().wrap(function _callee6$(_context6) {
          while (1)
            switch (_context6.prev = _context6.next) {
              case 0:
                media = this.flv.media;
                if (!(!this._mse || !this._demuxer || !media || !bufferBehind || bufferBehind < 0)) {
                  _context6.next = 3;
                  break;
                }
                return _context6.abrupt("return");
              case 3:
                currentTime = media.currentTime;
                removeEnd = currentTime - bufferBehind;
                if (!(removeEnd <= 0)) {
                  _context6.next = 7;
                  break;
                }
                return _context6.abrupt("return");
              case 7:
                start = Buffer2.start(Buffer2.get(media));
                if (!(start + 1 >= removeEnd)) {
                  _context6.next = 10;
                  break;
                }
                return _context6.abrupt("return");
              case 10:
                return _context6.abrupt("return", this._mse.clearBuffer(0, removeEnd).then(function() {
                  return _this2.flv.emit(EVENT.REMOVE_BUFFER, {
                    removeEnd
                  });
                }));
              case 11:
              case "end":
                return _context6.stop();
            }
        }, _callee6, this);
      }));
      function evictBuffer(_x3) {
        return _evictBuffer.apply(this, arguments);
      }
      return evictBuffer;
    }()
  }, {
    key: "_emitMetaParsedEvent",
    value: function _emitMetaParsedEvent(videoTrack, audioTrack) {
      if (videoTrack.exist()) {
        this.flv.emit(EVENT.METADATA_PARSED, {
          type: "video",
          track: videoTrack,
          meta: {
            codec: videoTrack.codec,
            timescale: videoTrack.timescale,
            width: videoTrack.width,
            height: videoTrack.height,
            sarRatio: videoTrack.sarRatio,
            baseDts: videoTrack.baseDts
          }
        });
      }
      if (audioTrack.exist()) {
        this.flv.emit(EVENT.METADATA_PARSED, {
          type: "audio",
          track: audioTrack,
          meta: {
            codec: audioTrack.codec,
            channelCount: audioTrack.channelCount,
            sampleRate: audioTrack.sampleRate,
            timescale: audioTrack.timescale,
            baseDts: audioTrack.baseDts
          }
        });
      }
      logger2.debug("track parsed", videoTrack, audioTrack);
    }
  }, {
    key: "_fireEvents",
    value: function _fireEvents(videoTrack, audioTrack, metadataTrack) {
      var _this3 = this;
      logger2.debug("videoTrack samples count: ".concat(videoTrack.samples.length, ", audioTrack samples count: ").concat(audioTrack.samples.length));
      metadataTrack.flvScriptSamples.forEach(function(sample) {
        _this3.flv.emit(EVENT.FLV_SCRIPT_DATA, sample);
        logger2.debug("flvScriptData", sample);
      });
      videoTrack.samples.forEach(function(sample) {
        if (sample.keyframe) {
          _this3.flv.emit(EVENT.KEYFRAME, {
            pts: sample.originPts
          });
        }
      });
      videoTrack.warnings.forEach(function(warn) {
        var type;
        switch (warn.type) {
          case WarningType.LARGE_AV_SHIFT:
            type = EVENT.LARGE_AV_FIRST_FRAME_GAP_DETECT;
            break;
          case WarningType.LARGE_VIDEO_GAP:
            type = EVENT.LARGE_VIDEO_DTS_GAP_DETECT;
            break;
          case WarningType.LARGE_VIDEO_GAP_BETWEEN_CHUNK:
            type = EVENT.MAX_DTS_DELTA_WITH_NEXT_SEGMENT_DETECT;
            break;
        }
        if (type)
          _this3.flv.emit(EVENT.STREAM_EXCEPTION, _objectSpread2(_objectSpread2({}, warn), {}, {
            type
          }));
        logger2.warn("video exception", warn);
      });
      audioTrack.warnings.forEach(function(warn) {
        var type;
        switch (warn.type) {
          case WarningType.LARGE_AUDIO_GAP:
            type = EVENT.LARGE_AUDIO_DTS_GAP_DETECT;
            break;
          case WarningType.AUDIO_FILLED:
            type = EVENT.AUDIO_GAP_DETECT;
            break;
          case WarningType.AUDIO_DROPPED:
            type = EVENT.AUDIO_OVERLAP_DETECT;
            break;
        }
        if (type)
          _this3.flv.emit(EVENT.STREAM_EXCEPTION, _objectSpread2(_objectSpread2({}, warn), {}, {
            type
          }));
        logger2.warn("audio exception", warn);
      });
      metadataTrack.seiSamples.forEach(function(sei) {
        _this3.flv.emit(EVENT.SEI, _objectSpread2(_objectSpread2({}, sei), {}, {
          sei: {
            code: sei.data.type,
            content: sei.data.payload,
            dts: sei.pts
          }
        }));
      });
    }
  }]);
  return BufferService2;
}();

// node_modules/xgplayer-flv/es/flv/options.js
function getOption(opts) {
  var ret = _objectSpread2({
    retryCount: 3,
    retryDelay: 1e3,
    disconnectRetryCount: 0,
    loadTimeout: 1e4,
    maxReaderInterval: 5e3,
    preloadTime: 5,
    defaultVodLoadSize: 1e7,
    isLive: false,
    softDecode: false,
    bufferBehind: 10,
    maxJumpDistance: 3,
    analyzeDuration: 2e4,
    seamlesslyReload: false,
    keepStatusAfterSwitch: true,
    onlyVideo: false,
    onlyAudio: false,
    preferMMS: false,
    mseLowLatency: true,
    durationForMSELowLatencyOff: 6,
    chunkCountForSpeed: 50,
    skipChunkSize: 1e3,
    longtimeNoReceived: 3e3,
    enableStartGapJump: true
  }, opts);
  if (ret.isLive) {
    if (ret.preloadTime) {
      if (!ret.maxLatency) {
        ret.maxLatency = ret.preloadTime * 2;
      }
      if (!ret.targetLatency) {
        ret.targetLatency = ret.preloadTime;
      }
      if (ret.disconnectTime === null || ret.disconnectTime === void 0) {
        ret.disconnectTime = ret.maxLatency;
      }
    }
  }
  return ret;
}

// node_modules/xgplayer-flv/es/flv/utils.js
function searchKeyframeIndex(list, value) {
  var idx = 0;
  var last = list.length - 1;
  var mid = 0;
  var lbound = 0;
  var ubound = last;
  if (value < list[0]) {
    idx = 0;
    lbound = ubound + 1;
  }
  while (lbound <= ubound) {
    mid = lbound + Math.floor((ubound - lbound) / 2);
    if (mid === last || value >= list[mid] && value < list[mid + 1]) {
      idx = mid;
      break;
    } else if (list[mid] < value) {
      lbound = mid + 1;
    } else {
      ubound = mid - 1;
    }
  }
  return idx;
}

// node_modules/xgplayer-flv/es/flv/index.js
var logger3 = new Logger("flv");
var MAX_HOLE = 0.1;
var MAX_START_GAP = 0.3;
var Flv = /* @__PURE__ */ function(_EventEmitter) {
  _inherits(Flv2, _EventEmitter);
  var _super = _createSuper(Flv2);
  function Flv2(_opts) {
    var _this;
    _classCallCheck(this, Flv2);
    _this = _super.call(this);
    _defineProperty(_assertThisInitialized(_this), "media", null);
    _defineProperty(_assertThisInitialized(_this), "_loading", false);
    _defineProperty(_assertThisInitialized(_this), "_opts", null);
    _defineProperty(_assertThisInitialized(_this), "_bufferService", null);
    _defineProperty(_assertThisInitialized(_this), "_gapService", null);
    _defineProperty(_assertThisInitialized(_this), "_stats", null);
    _defineProperty(_assertThisInitialized(_this), "_mediaLoader", null);
    _defineProperty(_assertThisInitialized(_this), "_maxChunkWaitTimer", null);
    _defineProperty(_assertThisInitialized(_this), "_tickTimer", null);
    _defineProperty(_assertThisInitialized(_this), "_tickInterval", 500);
    _defineProperty(_assertThisInitialized(_this), "_urlSwitching", false);
    _defineProperty(_assertThisInitialized(_this), "_seamlessSwitching", false);
    _defineProperty(_assertThisInitialized(_this), "_disconnectRetryCount", 0);
    _defineProperty(_assertThisInitialized(_this), "_preLoadEndPoint", 0);
    _defineProperty(_assertThisInitialized(_this), "_keyframes", null);
    _defineProperty(_assertThisInitialized(_this), "_acceptRanges", true);
    _defineProperty(_assertThisInitialized(_this), "_onProgress", /* @__PURE__ */ function() {
      var _ref2 = _asyncToGenerator(/* @__PURE__ */ _regeneratorRuntime().mark(function _callee(chunk, done, _ref, response) {
        var startTime, endTime, st, firstByteTime, _this$_mediaLoader, headers, elapsed, _this$_bufferService, remaining, maxReaderInterval;
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1)
            switch (_context.prev = _context.next) {
              case 0:
                startTime = _ref.startTime, endTime = _ref.endTime, st = _ref.st, firstByteTime = _ref.firstByteTime;
                _this._loading = !done;
                if (_this._firstProgressEmit) {
                  _context.next = 13;
                  break;
                }
                if (_this.media) {
                  _context.next = 6;
                  break;
                }
                (_this$_mediaLoader = _this._mediaLoader) === null || _this$_mediaLoader === void 0 ? void 0 : _this$_mediaLoader.cancel();
                return _context.abrupt("return");
              case 6:
                headers = response.headers;
                elapsed = st ? firstByteTime - st : endTime - startTime;
                _this.emit(EVENT.TTFB, {
                  url: _this._opts.url,
                  responseUrl: response.url,
                  elapsed
                });
                _this.emit(EVENT.LOAD_RESPONSE_HEADERS, {
                  headers
                });
                _this._transferCost.set(TRANSFER_EVENT.TTFB, elapsed);
                _this._acceptRanges = !!(headers !== null && headers !== void 0 && headers.get("Accept-Ranges")) || !!(headers !== null && headers !== void 0 && headers.get("Content-Range"));
                _this._firstProgressEmit = true;
              case 13:
                if (_this._bufferService) {
                  _context.next = 15;
                  break;
                }
                return _context.abrupt("return");
              case 15:
                clearTimeout(_this._maxChunkWaitTimer);
                _this._bandwidthService.addChunkRecord(chunk === null || chunk === void 0 ? void 0 : chunk.byteLength, endTime - startTime);
                _context.prev = 17;
                _context.next = 20;
                return _this._bufferService.appendBuffer(chunk);
              case 20:
                (_this$_bufferService = _this._bufferService) === null || _this$_bufferService === void 0 ? void 0 : _this$_bufferService.evictBuffer(_this._opts.bufferBehind);
                _context.next = 33;
                break;
              case 23:
                _context.prev = 23;
                _context.t0 = _context["catch"](17);
                if (!(!_this.isLive && _this._bufferService.isFull())) {
                  _context.next = 32;
                  break;
                }
                _context.next = 28;
                return _this._mediaLoader.cancel();
              case 28:
                _this._loading = false;
                remaining = _this.bufferInfo().remaining;
                _this._opts.preloadTime = parseInt(remaining) / 2;
                return _context.abrupt("return");
              case 32:
                return _context.abrupt("return", _this._emitError(StreamingError.create(_context.t0)));
              case 33:
                if (_this._urlSwitching) {
                  _this._urlSwitching = false;
                  _this.emit(EVENT.SWITCH_URL_SUCCESS, {
                    url: _this._opts.url
                  });
                }
                if (_this._seamlessSwitching) {
                  _this._seamlessSwitching = false;
                  _this._tick();
                }
                if (!(done && !_this.media.seeking)) {
                  _context.next = 40;
                  break;
                }
                _this.emit(EVENT.LOAD_COMPLETE);
                logger3.debug("load done");
                if (_this.isLive && _this._disconnectRetryCount <= 0) {
                  _this._end();
                }
                return _context.abrupt("return");
              case 40:
                if (_this.isLive) {
                  _context.next = 42;
                  break;
                }
                return _context.abrupt("return");
              case 42:
                maxReaderInterval = _this._opts.maxReaderInterval;
                if (maxReaderInterval && _this._firstProgressEmit) {
                  clearTimeout(_this._maxChunkWaitTimer);
                  _this._maxChunkWaitTimer = setTimeout(function() {
                    if (_this._disconnectRetryCount) {
                      _this._disconnectRetryCount--;
                      _this.load();
                      return;
                    }
                    logger3.debug("onMaxChunkWait", maxReaderInterval);
                    _this._end();
                  }, maxReaderInterval);
                }
              case 44:
              case "end":
                return _context.stop();
            }
        }, _callee, null, [[17, 23]]);
      }));
      return function(_x, _x2, _x3, _x4) {
        return _ref2.apply(this, arguments);
      };
    }());
    _defineProperty(_assertThisInitialized(_this), "_onRetryError", function(error, retryTime) {
      logger3.debug("load retry", error, retryTime);
      _this.emit(EVENT.LOAD_RETRY, {
        error: StreamingError.network(error),
        retryTime
      });
    });
    _defineProperty(_assertThisInitialized(_this), "_end", function() {
      _this._clear();
      if (_this._bufferService) {
        _this._bufferService.endOfStream();
      }
      logger3.debug("end stream");
    });
    _defineProperty(_assertThisInitialized(_this), "_resetDisconnectCount", function() {
      _this._disconnectRetryCount = _this._opts.disconnectRetryCount;
    });
    _defineProperty(_assertThisInitialized(_this), "_tick", function() {
      clearTimeout(_this._tickTimer);
      var _assertThisInitialize = _assertThisInitialized(_this), media = _assertThisInitialize.media;
      if (!media)
        return;
      _this._tickTimer = setTimeout(_this._tick, _this._tickInterval);
      var bufferEnd = Buffer2.end(Buffer2.get(media));
      if (bufferEnd < MAX_HOLE || !media.readyState)
        return;
      var opts = _this._opts;
      if (isMediaPlaying(media) && media.currentTime) {
        if (_this._gapService) {
          _this._gapService.do(media, opts.maxJumpDistance, _this.isLive, 3);
        }
      } else {
        if (!media.currentTime && _this._gapService && opts.enableStartGapJump) {
          var gapJump = _this._opts.mseLowLatency || _this._opts.mseLowLatency === false && _this.bufferInfo(MAX_START_GAP).nextStart;
          if (gapJump) {
            _this._gapService.do(media, opts.maxJumpDistance, _this.isLive, 3);
          }
          return;
        }
        if (opts.isLive && media.readyState === 4 && bufferEnd - media.currentTime > opts.disconnectTime) {
          _this.disconnect();
        }
      }
    });
    _defineProperty(_assertThisInitialized(_this), "_onPlay", function() {
      var _this$media, _this$media$buffered;
      var canReplay = _this._opts.softDecode || ((_this$media = _this.media) === null || _this$media === void 0 ? void 0 : (_this$media$buffered = _this$media.buffered) === null || _this$media$buffered === void 0 ? void 0 : _this$media$buffered.length);
      if (_this.isLive) {
        if (!_this._loading && canReplay) {
          _this.replay(void 0, true);
        }
        return;
      }
      var info = _this.bufferInfo();
      if ((info.start || info.nextStart) > MAX_HOLE) {
        _this._tick();
      }
    });
    _defineProperty(_assertThisInitialized(_this), "_onLoadeddata", function() {
      if (_this.isLive && !_this._opts.mseLowLatency) {
        if (_this.media.duration !== Infinity) {
          _this._bufferService.updateDuration(Infinity).catch(function(e) {
          });
        }
      }
    });
    _defineProperty(_assertThisInitialized(_this), "_onSeeking", /* @__PURE__ */ _asyncToGenerator(/* @__PURE__ */ _regeneratorRuntime().mark(function _callee2() {
      return _regeneratorRuntime().wrap(function _callee2$(_context2) {
        while (1)
          switch (_context2.prev = _context2.next) {
            case 0:
              if (!_this.isLive && _this.seekable) {
                _this._preLoadEndPoint = -1;
                _this._checkPreload();
              }
            case 1:
            case "end":
              return _context2.stop();
          }
      }, _callee2);
    })));
    _defineProperty(_assertThisInitialized(_this), "_onTimeupdate", function() {
      if (!_this.media)
        return;
      var opts = _this._opts;
      var currentTime = _this.media.currentTime;
      if (opts.isLive && opts.maxLatency && opts.targetLatency) {
        var bufferEnd = Buffer2.end(Buffer2.get(_this.media));
        var latency = bufferEnd - currentTime;
        if (latency >= opts.maxLatency) {
          _this.media.currentTime = bufferEnd - opts.targetLatency;
          _this.emit(EVENT.CHASEFRAME, {
            currentTime: _this.media.currentTime,
            latency: opts.targetLatency
          });
        }
      }
      _this._seiService.throw(currentTime, true);
      if (opts.isLive || !_this.seekable || _this._loading)
        return;
      _this._checkPreload();
    });
    _defineProperty(_assertThisInitialized(_this), "_onWaiting", function() {
      if (_this.isLive && !_this._loading && _this._disconnectRetryCount) {
        _this._disconnectRetryCount--;
        _this.load();
      }
    });
    _defineProperty(_assertThisInitialized(_this), "_onBufferUpdate", function() {
      if (_this._opts.isLive)
        return;
      var _this$bufferInfo = _this.bufferInfo(), end = _this$bufferInfo.end, nextEnd = _this$bufferInfo.nextEnd;
      if (Math.abs((end || nextEnd) - _this.media.duration) < 1) {
        _this._end();
        if (_this.media.readyState <= 2) {
          _this._tick();
        }
      }
    });
    _defineProperty(_assertThisInitialized(_this), "_checkPreload", /* @__PURE__ */ _asyncToGenerator(/* @__PURE__ */ _regeneratorRuntime().mark(function _callee3() {
      var _this$bufferInfo2, _this$bufferInfo2$rem, remainingBuffer, opts, filepositions, times, currentTime, i, end, startByte;
      return _regeneratorRuntime().wrap(function _callee3$(_context3) {
        while (1)
          switch (_context3.prev = _context3.next) {
            case 0:
              _this$bufferInfo2 = _this.bufferInfo(), _this$bufferInfo2$rem = _this$bufferInfo2.remaining, remainingBuffer = _this$bufferInfo2$rem === void 0 ? 0 : _this$bufferInfo2$rem;
              opts = _this._opts;
              filepositions = _this._keyframes.filepositions;
              times = _this._keyframes.times;
              currentTime = _this.media.currentTime;
              if (!(remainingBuffer < opts.preloadTime)) {
                _context3.next = 19;
                break;
              }
              i = searchKeyframeIndex(_this._keyframes.times, currentTime + remainingBuffer + MAX_HOLE);
              end = searchKeyframeIndex(_this._keyframes.times, currentTime + remainingBuffer + _this._opts.preloadTime);
              if (end === i) {
                end = i + 1;
              }
              if (!(_this._preLoadEndPoint === end)) {
                _context3.next = 11;
                break;
              }
              return _context3.abrupt("return");
            case 11:
              startByte = filepositions[i];
              if (!(startByte === null || startByte === void 0)) {
                _context3.next = 14;
                break;
              }
              return _context3.abrupt("return");
            case 14:
              _context3.next = 16;
              return _this._mediaLoader.cancel();
            case 16:
              _this._loadData(null, [startByte, filepositions[end]]);
              _this._preLoadEndPoint = end;
              _this._bufferService.unContiguous(times[i]);
            case 19:
            case "end":
              return _context3.stop();
          }
      }, _callee3);
    })));
    _defineProperty(_assertThisInitialized(_this), "_onFlvScriptData", function(sample) {
      var _sample$data, _sample$data$onMetaDa, _sample$data2, _sample$data2$onMetaD;
      var keyframes = (_sample$data = sample.data) === null || _sample$data === void 0 ? void 0 : (_sample$data$onMetaDa = _sample$data.onMetaData) === null || _sample$data$onMetaDa === void 0 ? void 0 : _sample$data$onMetaDa.keyframes;
      var duration = (_sample$data2 = sample.data) === null || _sample$data2 === void 0 ? void 0 : (_sample$data2$onMetaD = _sample$data2.onMetaData) === null || _sample$data2$onMetaD === void 0 ? void 0 : _sample$data2$onMetaD.duration;
      if (keyframes) {
        _this._keyframes = keyframes;
      }
      if (!_this._opts.isLive && duration) {
        _this._bufferService.updateDuration(duration);
      }
    });
    _this._opts = getOption(_opts);
    _this.media = _this._opts.media || document.createElement("video");
    _this._opts.media = null;
    _this._firstProgressEmit = false;
    _this._mediaLoader = new NetLoader(_objectSpread2(_objectSpread2({}, _this._opts.fetchOptions), {}, {
      retry: _this._opts.retryCount,
      retryDelay: _this._opts.retryDelay,
      timeout: _this._opts.loadTimeout,
      onRetryError: _this._onRetryError,
      onProgress: _this._onProgress,
      responseType: "arraybuffer"
    }));
    _this._disconnectRetryCount = _this._opts.disconnectRetryCount;
    _this._transferCost = new TransferCost();
    _this._bufferService = new BufferService(_assertThisInitialized(_this), _this._opts.softDecode ? _this.media : void 0, _this._opts);
    _this._seiService = new SeiService(_assertThisInitialized(_this));
    _this._bandwidthService = new BandwidthService({
      chunkCountForSpeed: _this._opts.chunkCountForSpeed,
      skipChunkSize: _this._opts.skipChunkSize,
      longtimeNoReceived: _this._opts.longtimeNoReceived
    });
    _this._stats = new MediaStatsService(_assertThisInitialized(_this));
    if (!_this._opts.softDecode) {
      _this._gapService = new GapService();
    }
    _this.media.addEventListener("play", _this._onPlay);
    _this.media.addEventListener("loadeddata", _this._onLoadeddata);
    _this.media.addEventListener("seeking", _this._onSeeking);
    _this.media.addEventListener("timeupdate", _this._onTimeupdate);
    _this.media.addEventListener("progress", _this._onBufferUpdate);
    _this.media.addEventListener("waiting", _this._onWaiting);
    _this.on(EVENT.FLV_SCRIPT_DATA, _this._onFlvScriptData);
    return _this;
  }
  _createClass(Flv2, [{
    key: "version",
    get: function get() {
      return "3.0.21";
    }
  }, {
    key: "isLive",
    get: function get() {
      return this._opts.isLive;
    }
  }, {
    key: "baseDts",
    get: function get() {
      var _this$_bufferService2;
      return (_this$_bufferService2 = this._bufferService) === null || _this$_bufferService2 === void 0 ? void 0 : _this$_bufferService2.baseDts;
    }
  }, {
    key: "seekable",
    get: function get() {
      return !!this._keyframes && this._acceptRanges;
    }
  }, {
    key: "loader",
    get: function get() {
      return this._mediaLoader;
    }
  }, {
    key: "blobUrl",
    get: function get() {
      var _this$_bufferService3;
      return (_this$_bufferService3 = this._bufferService) === null || _this$_bufferService3 === void 0 ? void 0 : _this$_bufferService3.blobUrl;
    }
  }, {
    key: "speedInfo",
    value: function speedInfo() {
      return {
        speed: this._bandwidthService.getLatestSpeed(),
        avgSpeed: this._bandwidthService.getAvgSpeed(),
        totalSize: this._bandwidthService.getTotalSize(),
        totalCost: this._bandwidthService.getTotalCost()
      };
    }
  }, {
    key: "getStats",
    value: function getStats() {
      return this._stats.getStats();
    }
  }, {
    key: "bufferInfo",
    value: function bufferInfo() {
      var _this$media2;
      var maxHole = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : MAX_HOLE;
      return Buffer2.info(Buffer2.get(this.media), (_this$media2 = this.media) === null || _this$media2 === void 0 ? void 0 : _this$media2.currentTime, maxHole);
    }
  }, {
    key: "playbackQuality",
    value: function playbackQuality() {
      return getVideoPlaybackQuality(this.media);
    }
  }, {
    key: "load",
    value: function() {
      var _load = _asyncToGenerator(/* @__PURE__ */ _regeneratorRuntime().mark(function _callee4(url) {
        var reuseMse, _args4 = arguments;
        return _regeneratorRuntime().wrap(function _callee4$(_context4) {
          while (1)
            switch (_context4.prev = _context4.next) {
              case 0:
                reuseMse = _args4.length > 1 && _args4[1] !== void 0 ? _args4[1] : false;
                if (this._bufferService) {
                  _context4.next = 3;
                  break;
                }
                return _context4.abrupt("return");
              case 3:
                _context4.next = 5;
                return this._reset(reuseMse);
              case 5:
                this._loadData(url, this._opts.isLive ? [] : [0, this._opts.defaultVodLoadSize]);
                clearTimeout(this._tickTimer);
                this._tickTimer = setTimeout(this._tick, this._tickInterval);
              case 8:
              case "end":
                return _context4.stop();
            }
        }, _callee4, this);
      }));
      function load(_x5) {
        return _load.apply(this, arguments);
      }
      return load;
    }()
  }, {
    key: "replay",
    value: function() {
      var _replay = _asyncToGenerator(/* @__PURE__ */ _regeneratorRuntime().mark(function _callee5() {
        var _this2 = this;
        var seamlesslyReload, isPlayEmit, _args5 = arguments;
        return _regeneratorRuntime().wrap(function _callee5$(_context5) {
          while (1)
            switch (_context5.prev = _context5.next) {
              case 0:
                seamlesslyReload = _args5.length > 0 && _args5[0] !== void 0 ? _args5[0] : this._opts.seamlesslyReload;
                isPlayEmit = _args5.length > 1 ? _args5[1] : void 0;
                if (this.media) {
                  _context5.next = 4;
                  break;
                }
                return _context5.abrupt("return");
              case 4:
                this._resetDisconnectCount();
                if (!seamlesslyReload) {
                  _context5.next = 11;
                  break;
                }
                _context5.next = 8;
                return this._clear();
              case 8:
                setTimeout(function() {
                  _this2._seamlessSwitching = true;
                  _this2._loadData(_this2._opts.url);
                  _this2._bufferService.seamlessSwitch();
                });
                _context5.next = 13;
                break;
              case 11:
                _context5.next = 13;
                return this.load();
              case 13:
                return _context5.abrupt("return", this.media.play(!isPlayEmit).catch(function() {
                }));
              case 14:
              case "end":
                return _context5.stop();
            }
        }, _callee5, this);
      }));
      function replay() {
        return _replay.apply(this, arguments);
      }
      return replay;
    }()
  }, {
    key: "disconnect",
    value: function disconnect() {
      var _this$_bufferService4;
      logger3.debug("disconnect!");
      (_this$_bufferService4 = this._bufferService) === null || _this$_bufferService4 === void 0 ? void 0 : _this$_bufferService4.resetSeamlessSwitchStats();
      return this._clear();
    }
  }, {
    key: "switchURL",
    value: function() {
      var _switchURL = _asyncToGenerator(/* @__PURE__ */ _regeneratorRuntime().mark(function _callee7(url, seamless) {
        var _this3 = this;
        return _regeneratorRuntime().wrap(function _callee7$(_context7) {
          while (1)
            switch (_context7.prev = _context7.next) {
              case 0:
                if (this._bufferService) {
                  _context7.next = 2;
                  break;
                }
                return _context7.abrupt("return");
              case 2:
                this._resetDisconnectCount();
                if (!(this._loading && seamless)) {
                  _context7.next = 6;
                  break;
                }
                this._bufferService.seamlessLoadingSwitch = /* @__PURE__ */ function() {
                  var _ref5 = _asyncToGenerator(/* @__PURE__ */ _regeneratorRuntime().mark(function _callee6(pts) {
                    return _regeneratorRuntime().wrap(function _callee6$(_context6) {
                      while (1)
                        switch (_context6.prev = _context6.next) {
                          case 0:
                            _context6.next = 2;
                            return _this3._clear();
                          case 2:
                            _this3._bufferService.seamlessLoadingSwitching = true;
                            _this3._urlSwitching = true;
                            _this3._seamlessSwitching = true;
                            _this3._bufferService.seamlessSwitch();
                            _this3._loadData(url);
                          case 7:
                          case "end":
                            return _context6.stop();
                        }
                    }, _callee6);
                  }));
                  return function(_x8) {
                    return _ref5.apply(this, arguments);
                  };
                }();
                return _context7.abrupt("return");
              case 6:
                if (!(!seamless || !this._opts.isLive)) {
                  _context7.next = 11;
                  break;
                }
                _context7.next = 9;
                return this.load(url);
              case 9:
                this._urlSwitching = true;
                return _context7.abrupt("return", this.media.play(true).catch(function() {
                }));
              case 11:
                _context7.next = 13;
                return this._clear();
              case 13:
                setTimeout(function() {
                  _this3._urlSwitching = true;
                  _this3._seamlessSwitching = true;
                  _this3._loadData(url);
                  _this3._bufferService.seamlessSwitch();
                });
              case 14:
              case "end":
                return _context7.stop();
            }
        }, _callee7, this);
      }));
      function switchURL(_x6, _x7) {
        return _switchURL.apply(this, arguments);
      }
      return switchURL;
    }()
  }, {
    key: "destroy",
    value: function() {
      var _destroy = _asyncToGenerator(/* @__PURE__ */ _regeneratorRuntime().mark(function _callee8() {
        return _regeneratorRuntime().wrap(function _callee8$(_context8) {
          while (1)
            switch (_context8.prev = _context8.next) {
              case 0:
                if (this.media) {
                  _context8.next = 2;
                  break;
                }
                return _context8.abrupt("return");
              case 2:
                this.removeAllListeners();
                this._seiService.reset();
                this.media.removeEventListener("play", this._onPlay);
                this.media.removeEventListener("loadeddata", this._onLoadeddata);
                this.media.removeEventListener("seeking", this._onSeeking);
                this.media.removeEventListener("timeupdate", this._onTimeupdate);
                this.media.removeEventListener("waiting", this._onWaiting);
                this.media.removeEventListener("progress", this._onBufferUpdate);
                _context8.next = 12;
                return Promise.all([this._clear(), this._bufferService.destroy()]);
              case 12:
                this.media = null;
                this._bufferService = null;
              case 14:
              case "end":
                return _context8.stop();
            }
        }, _callee8, this);
      }));
      function destroy() {
        return _destroy.apply(this, arguments);
      }
      return destroy;
    }()
  }, {
    key: "_emitError",
    value: function _emitError(error) {
      var _this$media3;
      var endOfStream = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
      logger3.table(error);
      logger3.error(error);
      logger3.error((_this$media3 = this.media) === null || _this$media3 === void 0 ? void 0 : _this$media3.error);
      if (this._urlSwitching) {
        this._urlSwitching = false;
        this._seamlessSwitching = false;
        this.emit(EVENT.SWITCH_URL_FAILED, error);
      }
      this.emit(EVENT.ERROR, error);
      if (endOfStream) {
        this._seiService.reset();
        this._end();
      }
    }
  }, {
    key: "_reset",
    value: function() {
      var _reset2 = _asyncToGenerator(/* @__PURE__ */ _regeneratorRuntime().mark(function _callee9() {
        var reuseMse, _args9 = arguments;
        return _regeneratorRuntime().wrap(function _callee9$(_context9) {
          while (1)
            switch (_context9.prev = _context9.next) {
              case 0:
                reuseMse = _args9.length > 0 && _args9[0] !== void 0 ? _args9[0] : false;
                this._seiService.reset();
                this._bandwidthService.reset();
                this._stats.reset();
                _context9.next = 6;
                return this._clear();
              case 6:
                _context9.next = 8;
                return this._bufferService.reset(reuseMse);
              case 8:
              case "end":
                return _context9.stop();
            }
        }, _callee9, this);
      }));
      function _reset() {
        return _reset2.apply(this, arguments);
      }
      return _reset;
    }()
  }, {
    key: "_loadData",
    value: function() {
      var _loadData2 = _asyncToGenerator(/* @__PURE__ */ _regeneratorRuntime().mark(function _callee10(url, range) {
        var finnalUrl;
        return _regeneratorRuntime().wrap(function _callee10$(_context10) {
          while (1)
            switch (_context10.prev = _context10.next) {
              case 0:
                if (url)
                  this._opts.url = url;
                finnalUrl = url = this._opts.url;
                if (url) {
                  _context10.next = 4;
                  break;
                }
                throw new Error("Source url is missing");
              case 4:
                if (this._opts.preProcessUrl) {
                  finnalUrl = this._opts.preProcessUrl(url).url;
                }
                this._mediaLoader.finnalUrl = finnalUrl;
                this.emit(EVENT.LOAD_START, {
                  url: finnalUrl,
                  seamlessSwitching: this._seamlessSwitching
                });
                logger3.debug("load data, loading:", this._loading, finnalUrl);
                if (!this._loading) {
                  _context10.next = 11;
                  break;
                }
                _context10.next = 11;
                return this._mediaLoader.cancel();
              case 11:
                this._loading = true;
                _context10.prev = 12;
                _context10.next = 15;
                return this._mediaLoader.load({
                  url: finnalUrl,
                  range
                });
              case 15:
                _context10.next = 21;
                break;
              case 17:
                _context10.prev = 17;
                _context10.t0 = _context10["catch"](12);
                this._loading = false;
                return _context10.abrupt("return", this._emitError(StreamingError.network(_context10.t0), false));
              case 21:
              case "end":
                return _context10.stop();
            }
        }, _callee10, this, [[12, 17]]);
      }));
      function _loadData(_x9, _x10) {
        return _loadData2.apply(this, arguments);
      }
      return _loadData;
    }()
  }, {
    key: "_clear",
    value: function() {
      var _clear2 = _asyncToGenerator(/* @__PURE__ */ _regeneratorRuntime().mark(function _callee11() {
        return _regeneratorRuntime().wrap(function _callee11$(_context11) {
          while (1)
            switch (_context11.prev = _context11.next) {
              case 0:
                if (!this._mediaLoader) {
                  _context11.next = 3;
                  break;
                }
                _context11.next = 3;
                return this._mediaLoader.cancel();
              case 3:
                clearTimeout(this._maxChunkWaitTimer);
                clearTimeout(this._tickTimer);
                this._loading = false;
                this._firstProgressEmit = false;
              case 7:
              case "end":
                return _context11.stop();
            }
        }, _callee11, this);
      }));
      function _clear() {
        return _clear2.apply(this, arguments);
      }
      return _clear;
    }()
  }], [{
    key: "isSupported",
    value: function isSupported(mediaType) {
      if (!mediaType || mediaType === "video" || mediaType === "audio") {
        return MSE.isSupported();
      }
      return typeof WebAssembly !== "undefined";
    }
  }, {
    key: "enableLogger",
    value: function enableLogger() {
      Logger.enable();
      Logger2.enable();
    }
  }, {
    key: "disableLogger",
    value: function disableLogger() {
      Logger.disable();
      Logger2.disable();
    }
  }]);
  return Flv2;
}(import_eventemitter35.default);
try {
  if (localStorage.getItem("xgd")) {
    Flv.enableLogger();
  } else {
    Flv.disableLogger();
  }
} catch (error) {
}

// lib/hls.js
var import_hls_light = __toESM(require_hls_light(), 1);
var export_Hls = import_hls_light.default;
export {
  Flv,
  export_Hls as Hls
};
